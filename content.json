{"meta":{"title":"李世奇的技术专栏","subtitle":null,"description":"Fe Coder","author":"ConardLi","url":"www.conardli.top"},"pages":[{"title":"about","date":"2018-10-28T15:07:13.000Z","updated":"2018-11-03T15:46:49.634Z","comments":true,"path":"about/index.html","permalink":"www.conardli.top/about/index.html","excerpt":"","text":"关于，以后再说…….."}],"posts":[{"title":"【特效】看完这篇，你也可以实现一个360度全景插件","slug":"【特效】看完这篇，你也可以实现一个360度全景插件","date":"2019-05-05T01:17:16.000Z","updated":"2019-05-05T01:19:18.688Z","comments":true,"path":"2019/05/05/【特效】看完这篇，你也可以实现一个360度全景插件/","link":"","permalink":"www.conardli.top/2019/05/05/【特效】看完这篇，你也可以实现一个360度全景插件/","excerpt":"","text":"导读本文从绘图基础开始讲起，详细介绍了如何使用Three.js开发一个功能齐全的全景插件。 我们先来看一下插件的效果： 如果你对Three.js已经很熟悉了，或者你想跳过基础理论，那么你可以直接从全景预览开始看起。 本项目的github地址：https://github.com/ConardLi/tpanorama 一、理清关系1.1 OpenGL OpenGL是用于渲染2D、3D量图形的跨语言、跨平台的应用程序编程接口（API）。 这个接口由近350个不同的函数调用组成，用来从简单的图形比特绘制复杂的三维景象。 OpenGL ES 是OpenGL三维图形API的子集，针对手机、PDA和游戏主机等嵌入式设备而设计。 基于OpenGL，一般使用C或Cpp开发，对前端开发者来说不是很友好。 1.2 WebGLWebGL把JavaScript和OpenGL ES 2.0结合在一起，从而为前端开发者提供了使用JavaScript编写3D效果的能力。 WebGL为HTML5 Canvas提供硬件3D加速渲染，这样Web开发人员就可以借助系统显卡来在浏览器里更流畅地展示3D场景和模型了，还能创建复杂的导航和数据视觉化。 1.3 CanvasCanvas是一个可以自由制定大小的矩形区域，可以通过JavaScript可以对矩形区域进行操作，可以自由的绘制图形，文字等。 一般使用Canvas都是使用它的2d的context功能，进行2d绘图，这是其本身的能力。 和这个相对的，WebGL是三维，可以描画3D图形，WebGL，想要在浏览器上进行呈现，它必须需要一个载体，这个载体就是Canvas，区别于之前的2dcontext，还可以从Canvas中获取webglcontext。 1.4 Three.js 我们先来从字面意思理解下：Three代表3D，js代表JavaScript，即使用JavaScript来开发3D效果。 Three.js是使用JavaScript对 WebGL接口进行封装与简化而形成的一个易用的3D库。 直接使用WebGL进行开发对于开发者来说成本相对来说是比较高的，它需要你掌握较多的计算机图形学知识。 Three.js在一定程度上简化了一些规范和难以理解的概念，对很多API进行了简化，这大大降低了学习和开发三维效果成本。 下面我们来具体看一下使用Three.js必须要知道的知识。 二、Three.js基础知识使用Three.js绘制一个三维效果，至少需要以下几个步骤： 创建一个容纳三维空间的场景 — Sence 将需要绘制的元素加入到场景中，对元素的形状、材料、阴影等进行设置 给定一个观察场景的位置，以及观察角度，我们用相机对象（Camera）来控制 将绘制好的元素使用渲染器（Renderer）进行渲染，最终呈现在浏览器上 拿电影来类比的话，场景对应于整个布景空间，相机是拍摄镜头，渲染器用来把拍摄好的场景转换成胶卷。 2.1 场景场景允许你设置哪些对象被three.js渲染以及渲染在哪里。 我们在场景中放置对象、灯光和相机。 很简单，直接创建一个Scene的实例即可。 _scene = new Scene(); 2.2 元素有了场景，我们接下来就需要场景里应该展示哪些东西。 一个复杂的三维场景往往就是由非常多的元素搭建起来的，这些元素可能是一些自定义的几何体（Geometry），或者外部导入的复杂模型。 Three.js 为我们提供了非常多的Geometry，例如SphereGeometry（球体）、 TetrahedronGeometry（四面体）、TorusGeometry（圆环体）等等。 在Three.js中，材质（Material）决定了几何图形具体是以什么形式展现的。它包括了一个几何体如何形状以外的其他属性，例如色彩、纹理、透明度等等，Material和Geometry是相辅相成的，必须结合使用。 下面的代码我们创建了一个长方体体，赋予它基础网孔材料（MeshBasicMaterial） var geometry = new THREE.BoxGeometry(200, 100, 100);var material = new THREE.MeshBasicMaterial(&#123; color: 0x645d50 &#125;);var mesh = new THREE.Mesh(geometry, material); _scene.add(mesh); 能以这个角度看到几何体实际上是相机的功劳，这个我们下面的章节再介绍，这让我们看到一个几何体的轮廓，但是感觉怪怪的，这并不像一个几何体，实际上我们还需要为它添加光照和阴影，这会让几何体看起来更真实。 基础网孔材料（MeshBasicMaterial）不受光照影响的，它不会产生阴影，下面我们为几何体换一种受光照影响的材料：网格标准材质(Standard Material)，并为它添加一些光照： var geometry = new THREE.BoxGeometry(200, 100, 100);var material = new THREE.MeshStandardMaterial(&#123; color: 0x645d50 &#125;);var mesh = new THREE.Mesh(geometry, material);_scene.add(mesh);// 创建平行光-照亮几何体var directionalLight = new THREE.DirectionalLight(0xffffff, 1); directionalLight.position.set(-4, 8, 12);_scene.add(directionalLight);// 创建环境光var ambientLight = new THREE.AmbientLight(0xffffff);_scene.add(ambientLight); 有了光线的渲染，让几何体看起来更具有3D效果，Three.js中光源有很多种，我们上面使用了环境光(AmbientLight)和平行光(DirectionalLight)。 环境光会对场景中的所有物品进行颜色渲染。 平行光你可以认为像太阳光一样，从极远处射向场景中的光。它具有方向性，也可以启动物体对光的反射效果。 除了这两种光，Three.js还提供了其他几种光源，它们适用于不同情况下对不同材质的渲染，可以根据实际情况选择。 2.3 坐标系在说相机之前，我们还是先来了解一下坐标系的概念： 在三维世界中，坐标定义了一个元素所处于三维空间的位置，坐标系的原点即坐标的基准点。 最常用的，我们使用距离原点的三个长度（距离x轴、距离y轴、距离z轴）来定义一个位置，这就是直角坐标系。 在判定坐标系时，我们通常使用大拇指、食指和中指，并互为90度。大拇指代表X轴，食指代表Y轴，中指代表Z轴。 这就产生了两种坐标系：左手坐标系和右手坐标系。 Three.js中使用的坐标系即右手坐标系。 我们可以在我们的场景中添加一个坐标系，这样我们可以清楚的看到元素处于什么位置： var axisHelper = new THREE.AxisHelper(600);_scene.add(axisHelper); 其中红色代表X轴，绿色代表Y轴，蓝色代表Z轴。 2.4 相机上面看到的几何体的效果，如果不创建一个相机(Camera)，是什么也看不到的，因为默认的观察点在坐标轴原点，它处于几何体的内部。 相机(Camera)指定了我们在什么位置观察这个三维场景，以及以什么样的角度进行观察。 2.4.1 两种相机的区别目前Three.js提供了几种不同的相机，最常用的，也是下面插件中使用的两种相机是：PerspectiveCamera（透视相机）、 OrthographicCamera（正交投影相机）。 上面的图很清楚的解释了两种相机的区别： 右侧是 OrthographicCamera（正交投影相机）他不具有透视效果，即物体的大小不受远近距离的影响，对应的是投影中的正交投影。我们数学课本上所画的几何体大多数都采用这种投影。 左侧是PerspectiveCamera（透视相机），这符合我们正常人的视野，近大远小，对应的是投影中的透视投影。 如果你想让场景看起来更真实，更具有立体感，那么采用透视相机最合适，如果场景中有一些元素你不想让他随着远近放大缩小，那么采用正交投影相机最合适。 2.4.2 构造参数我们再分别来看看两个创建两个相机需要什么参数： _camera = new OrthographicCamera(left, right, top, bottom, near, far); OrthographicCamera接收六个参数，left, right, top, bottom分别对应上、下、左、右、远、近的一个距离，超过这些距离的元素将不会出现在视野范围内，也不会被浏览器绘制。实际上，这六个距离就构成了一个立方体，所以OrthographicCamera的可视范围永远在这个立方体内。 _camera = new PerspectiveCamera(fov, aspect, near, far); PerspectiveCamera接收四个参数，near、far和上面的相同，分别对应相机可观测的最远和最近距离；fov代表水平范围可观测的角度，fov越大，水平范围能观测到的范围越广；aspect代表水平方向和竖直方向可观测距离的比值，所以fov和aspect就可以确定垂直范围内能观测到的范围。 2.4.3 position、lookAt关于相机还有两个必须要知道的点，一个是position属性，一个是lookAt函数： position属性指定了相机所处的位置。 lookAt函数指定相机观察的方向。 实际上position的值和lookAt接收的参数都是一个类型为Vector3的对象，这个对象用来表示三维空间中的坐标，它有三个属性：x、y、z分别代表距离x轴、距离y轴、距离z轴的距离。 下面，我们让相机观察的方向指向原点，另外分别让x、y、z为0，另外两个参数不为0，看一下视野会发生什么变化： _camera = new OrthographicCamera(-window.innerWidth / 2, window.innerWidth / 2, window.innerHeight / 2, -window.innerHeight / 2, 0.1, 1000); _camera.lookAt(new THREE.Vector3(0, 0, 0)) _camera.position.set(0, 300, 600); // 1 - x为0 _camera.position.set(500, 0, 600); // 2 - y为0 _camera.position.set(500, 300, 0); // 3 - z为0 很清楚的看到position决定了我们视野的出发点，但是镜头指向的方向是不变的。 下面我们将position固定，改变相机观察的方向： _camera = new OrthographicCamera(-window.innerWidth / 2, window.innerWidth / 2, window.innerHeight / 2, -window.innerHeight / 2, 0.1, 1000);_camera.position.set(500, 300, 600); _camera.lookAt(new THREE.Vector3(0, 0, 0)) // 1 - 视野指向原点_camera.lookAt(new THREE.Vector3(200, 0, 0)) // 2 - 视野偏向x轴 可见：我们视野的出发点是相同的，但是视野看向的方向发生了改变。 2.4.4 两种相机对比好，有了上面的基础，我们再来写两个例子看一看两个相机的视角对比，为了方便观看，我们创建两个位置不同的几何体： var geometry = new THREE.BoxGeometry(200, 100, 100);var material = new THREE.MeshStandardMaterial(&#123; color: 0x645d50 &#125;);var mesh = new THREE.Mesh(geometry, material);_scene.add(mesh);var geometry = new THREE.SphereGeometry(50, 100, 100);var ball = new THREE.Mesh(geometry, material);ball.position.set(200, 0, -200);_scene.add(ball); 正交投影相机视野： _camera = new OrthographicCamera(-window.innerWidth / 2, window.innerWidth / 2, window.innerHeight / 2, -window.innerHeight / 2, 0.1, 1000);_camera.position.set(0, 300, 600);_camera.lookAt(new THREE.Vector3(0, 0, 0)) 透视相机视野： _camera = new PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1100);_camera.position.set(0, 300, 600);_camera.lookAt(new THREE.Vector3(0, 0, 0)) 可见，这印证了我们上面关于两种相机的理论 2.5 渲染器上面我们创建了场景、元素和相机，下面我们要告诉浏览器将这些东西渲染到浏览器上。 Three.js也为我们提供了几种不同的渲染器，这里我们主要看WebGL渲染器(WebGLRenderer)。顾名思义：WebGL渲染器使用WebGL来绘制场景，其够利用GPU硬件加速从而提高渲染性能。 _renderer = new THREE.WebGLRenderer(); 你需要将你使用Three.js绘制的元素添加到浏览器上，这个过程需要一个载体，上面我们介绍，这个载体就是Canvas，你可以通过_renderer.domElement获取到这个Canvas，并将它给定到真实DOM中。 _container = document.getElementById('conianer');_container.appendChild(_renderer.domElement); 使用setSize函数设定你要渲染的范围，实际上它改变的就是上面Canvas的范围： _renderer.setSize(window.innerWidth, window.innerHeight); 现在，你已经指定了一个渲染的载体和载体的范围，你可以通过render函数渲染上面指定的场景和相机： _renderer.render(_scene, _camera); 实际上，你如果依次执行上面的代码，可能屏幕上还是黑漆漆的一片，并没有任何元素渲染出来。 这是因为上面你要渲染的元素可能并未被加载完，你就执行了渲染，并且只执行了一次，这时我们需要一种方法，让场景和相机进行实时渲染，我们需要用到下面的方法： 2.6 requestAnimationFramewindow.requestAnimationFrame()告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。 该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。 window.requestAnimationFrame(callback); 若你想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调用window.requestAnimationFrame()。 使用者韩函数就意味着，你可以在requestAnimationFrame不停的执行绘制操作，浏览器就实时的知道它需要渲染的内容。 当然，某些时候你已经不需要实时绘制了，你也可以使用cancelAnimationFrame立即停止这个绘制： window.cancelAnimationFrame(myReq); 来看一个简单的例子： var i = 0;var animateName;animate();function animate() &#123; animateName = requestAnimationFrame(animate); console.log(i++); if (i &gt; 100) &#123; cancelAnimationFrame(animateName); &#125;&#125; 来看一下执行效果： 我们使用requestAnimationFrame和Three.js的渲染器结合使用，这样就能实时绘制三维动画了： function animate() &#123; requestAnimationFrame(animate); _renderer.render(_scene, _camera);&#125; 借助上面的代码，我们可以简单实现一些动画效果： var y = 100;var option = 'down';function animateIn() &#123; animateName = requestAnimationFrame(animateIn); mesh.rotateX(Math.PI / 40); if (option == 'up') &#123; ball.position.set(200, y += 8, 0); &#125; else &#123; ball.position.set(200, y -= 8, 0); &#125; if (y &lt; 1) &#123; option = 'up'; &#125; if (y &gt; 100) &#123; option = 'down' &#125;&#125; 2.7 总结上面的知识是Three.js中最基础的知识，也是最重要的和最主干的。 这些知识能够让你在看到一个复杂的三维效果时有一定的思路，当然，要实现还需要非常多的细节。这些细节你可以去官方文档中查阅。 下面的章节即告诉你如何使用Three.js进行实战 — 实现一个360度全景插件。 这个插件包括两部分，第一部分是对全景图进行预览。 第二部分是对全景图的标记进行配置，并关联预览的坐标。 我们首先来看看全景预览部分： 三、全景预览 3.1 基本逻辑 将一张全景图包裹在球体的内壁 设定一个观察点，在球的圆心 使用鼠标可以拖动球体，从而改变我们看到全景的视野 鼠标滚轮可以缩放，和放大，改变观察全景的远近 根据坐标在全景图上挂载一些标记，如文字、图标等，并且可以增加事件，如点击事件 3.2 初始化我们先把必要的基础设施搭建起来： 场景、相机（选择远景相机，这样可以让全景看起来更真实）、渲染器： _scene = new THREE.Scene();initCamera();initRenderer();animate();// 初始化相机function initCamera() &#123; _camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1100); _camera.position.set(0, 0, 2000); _camera.lookAt(new THREE.Vector3(0, 0, 0));&#125;// 初始化渲染器function initRenderer() &#123; _renderer = new THREE.WebGLRenderer(); _renderer.setSize(window.innerWidth, window.innerHeight); _container = document.getElementById('panoramaConianer'); _container.appendChild(_renderer.domElement);&#125;// 实时渲染function animate() &#123; requestAnimationFrame(animate); _renderer.render(_scene, _camera);&#125; 下面我们在场景内添加一个球体，并把全景图作为材料包裹在球体上面： var mesh = new THREE.Mesh(new THREE.SphereGeometry(1000, 100, 100),new THREE.MeshBasicMaterial( &#123; map: ImageUtils.loadTexture('img/p3.png') &#125; ));_scene.add(mesh); 然后我们看到的场景应该是这样的： 这不是我们想要的效果，我们想要的是从球的内部观察全景，并且全景图是附着外球的内壁的，而不是铺在外面： 我们只要需将Material的scale的一个属性设置为负值，材料即可附着在几何体的内部： mesh.scale.x = -1; 然后我们将相机的中心点移动到球的中心： _camera.position.set(0, 0, 0); 现在我们已经在全景球的内部啦： 3.3 事件处理全景图已经可以浏览了，但是你只能看到你眼前的这一块，并不能拖动它看到其他部分，为了精确的控制拖动的速度和缩放、放大等场景，我们手动为它增加一些事件： 监听鼠标的mousedown事件，在此时将开始拖动标记_isUserInteracting设置为true，并且记录起始的屏幕坐标，以及起始的相机lookAt的坐标。 _container.addEventListener('mousedown', (event)=&gt;&#123; event.preventDefault(); _isUserInteracting = true; _onPointerDownPointerX = event.clientX; _onPointerDownPointerY = event.clientY; _onPointerDownLon = _lon; _onPointerDownLat = _lat;&#125;); 监听鼠标的mousemove事件，当_isUserInteracting为true时，实时计算当前相机lookAt的真实坐标。 _container.addEventListener('mousemove', (event)=&gt;&#123; if (_isUserInteracting) &#123; _lon = (_onPointerDownPointerX - event.clientX) * 0.1 + _onPointerDownLon; _lat = (event.clientY - _onPointerDownPointerY) * 0.1 + _onPointerDownLat; &#125;&#125;); 监听鼠标的mouseup事件，将_isUserInteracting设置为false。 _container.addEventListener('mouseup', (event)=&gt;&#123; _isUserInteracting = false;&#125;); 当然，上面我们只是改变了坐标，并没有告诉相机它改变了，我们在animate函数中来做这件事： function animate() &#123; requestAnimationFrame(animate); calPosition(); _renderer.render(_scene, _camera); _renderer.render(_sceneOrtho, _cameraOrtho);&#125;function calPosition() &#123; _lat = Math.max(-85, Math.min(85, _lat)); var phi = tMath.degToRad(90 - _lat); var theta = tMath.degToRad(_lon); _camera.target.x = _pRadius * Math.sin(phi) * Math.cos(theta); _camera.target.y = _pRadius * Math.cos(phi); _camera.target.z = _pRadius * Math.sin(phi) * Math.sin(theta); _camera.lookAt(_camera.target);&#125; 监听mousewheel事件，对全景图进行放大和缩小，注意这里指定了最大缩放范围maxFocalLength和最小缩放范围minFocalLength。 _container.addEventListener('mousewheel', (event)=&gt;&#123; var ev = ev || window.event; var down = true; var m = _camera.getFocalLength(); down = ev.wheelDelta ? ev.wheelDelta &lt; 0 : ev.detail &gt; 0; if (down) &#123; if (m &gt; minFocalLength) &#123; m -= m * 0.05 _camera.setFocalLength(m); &#125; &#125; else &#123; if (m &lt; maxFocalLength) &#123; m += m * 0.05 _camera.setFocalLength(m); &#125; &#125;&#125;); 来看一下效果吧： 3.4 增加标记在浏览全景图的时候，我们往往需要对某些特殊的位置进行一些标记，并且这些标记可能附带一些事件，比如你需要点击一个标记才能到达下一张全景图。 下面我们来看看如何在全景中增加标记，以及如何为这些标记添加事件。 我们可能不需要让这些标记随着视野的变化而放大和缩小，基于此，我们使用正交投影相机来展现标记，只需给它一个固定的观察高度： _cameraOrtho = new THREE.OrthographicCamera(-window.innerWidth / 2, window.innerWidth / 2, window.innerHeight / 2, -window.innerHeight / 2, 1, 10);_cameraOrtho.position.z = 10;_sceneOrtho = new Scene(); 利用精灵材料(SpriteMaterial)来实现文字标记，或者图片标记： // 创建文字标记function createLableSprite(name) &#123; const canvas = document.createElement('canvas'); const context = canvas.getContext('2d'); const metrics = context.measureText(name); const width = metrics.width * 1.5; context.font = \"10px 宋体\"; context.fillStyle = \"rgba(0,0,0,0.95)\"; context.fillRect(2, 2, width + 4, 20 + 4); context.fillText(name, 4, 20); const texture = new Texture(canvas); const spriteMaterial = new SpriteMaterial(&#123; map: texture &#125;); const sprite = new Sprite(spriteMaterial); sprite.name = name; const lable = &#123; name: name, canvas: canvas, context: context, texture: texture, sprite: sprite &#125;; _sceneOrtho.add(lable.sprite); return lable;&#125;// 创建图片标记function createSprite(position, url, name) &#123; const textureLoader = new TextureLoader(); const ballMaterial = new SpriteMaterial(&#123; map: textureLoader.load(url) &#125;); const sp = &#123; pos: position, name: name, sprite: new Sprite(ballMaterial) &#125;; sp.sprite.scale.set(32, 32, 1.0); sp.sprite.name = name; _sceneOrtho.add(sp.sprite); return sp;&#125; 创建好这些标记，我们把它渲染到场景中。 我们必须告诉场景这些标记的位置，为了直观的理解，我们需要给这些标记赋予一种坐标，这种坐标很类似于经纬度，我们叫它lon和lat，具体是如何给定的我们在下面的章节：全景标记中会详细介绍。 在这个过程中，一共经历了两次坐标转换： 第一次转换：将“经纬度”转换为三维空间坐标，即我们上面讲的那种x、y、z形式的坐标。 使用geoPosition2World函数进行转换，得到一个Vector3对象，我们可以将当前相机_camera作为参数传入这个对象的project方法，这会得到一个标准化后的坐标，基于这个坐标可以帮我们判断标记是否在视野范围内，如下面的代码，若标准化坐标在-1和1的范围内，则它会出现在我们的视野中，我们将它进行准确渲染。 第二次转换：将三维空间坐标转换为屏幕坐标。 如果我们直接讲上面的三维空间坐标坐标应用到标记中，我们会发现无论视野如何移动，标记的位置是不会有任何变化的，因为这样算出来的坐标永远是一个常量。 所以我们需要借助上面的标准化坐标，将标记的三维空间坐标转换为真实的屏幕坐标，这个过程是worldPostion2Screen函数来实现的。 关于geoPosition2World和worldPostion2Screen两个函数的实现，大家有兴趣可以去我的github源码中查看，这里就不多做解释了，因为这又要牵扯到一大堆专业知识啦。😅 var wp = geoPosition2World(_sprites.lon, _sprites.lat);var sp = worldPostion2Screen(wp, _camera);var test = wp.clone();test.project(_camera);if (test.x &gt; -1 &amp;&amp; test.x &lt; 1 &amp;&amp; test.y &gt; -1 &amp;&amp; test.y &lt; 1 &amp;&amp; test.z &gt; -1 &amp;&amp; test.z &lt; 1) &#123; _sprites[i].sprite.scale.set(32, 32, 32); _sprites[i].sprite.position.set(sp.x, sp.y, 1);&#125;else &#123; _sprites[i].sprite.scale.set(1.0, 1.0, 1.0); _sprites[i].sprite.position.set(0, 0, 0);&#125; 现在，标记已经添加到全景上面了，我们来为它添加一个点击事件： Three.js并没有单独提供为Sprite添加事件的方法，我们可以借助光线投射器（Raycaster）来实现。 Raycaster提供了鼠标拾取的能力： 通过setFromCamera函数来建立当前点击的坐标（经过归一化处理）和相机的绑定关系。 通过intersectObjects来判定一组对象中有哪些被命中（点击），得到被命中的对象数组。 这样，我们就可以获取到点击的对象，并基于它做一些处理： _container.addEventListener('click', (event)=&gt;&#123; _mouse.x = (event.clientX / window.innerWidth) * 2 - 1; _mouse.y = -(event.clientY / window.innerHeight) * 2 + 1; _raycaster.setFromCamera(_mouse, _cameraOrtho); var intersects = _raycaster.intersectObjects(_clickableObjects); intersects.forEach(function (element) &#123; alert(\"点击到了: \" + element.object.name); &#125;);&#125;); 点击到一个标记，进入到下一张全景图： 四、全景标记为了让全景图知道，我要把标记标注在什么地方，我需要一个工具来把原图和全景图上的位置关联起来： 由于这部分代码和Three.js关系不大，这里我只说一下基本的实现逻辑，有兴趣可以去我的github仓库查看。 4.1 要求 建立坐标和全景的映射关系，为全景赋予一套虚拟坐标 在一张平铺的全景图上，可以在任意位置增加标记，并获取标记的坐标 使用坐标在预览全景增加标记，看到的标记位置和平铺全景中的位置相同 4.2 坐标在2D平面上，我们能监听屏幕的鼠标事件，我们可以获取的也只是当前的鼠标坐标，我们要做的是将鼠标坐标转换成三维空间坐标。 看起来好像是不可能的，二维坐标怎么能转换成三维坐标呢？ 但是，我们可以借助一种中间坐标来转换，可以把它称之为“经纬度”。 在这之前，我们先来看看我们常说的经纬度到底是什么。 4.3 经纬度使用经纬度，可以精确的定位到地球上任意一个点，它的计算规则是这样的： 通常把连接南极到北极的线叫做子午线也叫经线，其所对应的面叫做子午面，规定英国伦敦格林尼治天文台原址的那条经线称为0°经线，也叫本初子午线其对应的面即本初子午面。 经度：球面上某店对应的子午面与本初子午面间的夹角。东正西负。 纬度 ：球面上某点的法线（以该店作为切点与球面相切的面的法线）与赤道平面的夹角。北正南负。 由此，地球上每一个点都能被对应到一个经度和纬度，想对应的，也能对应到某条经线和纬线上。 这样，即使把球面展开称平面，我们仍然能用经纬度表示某店\b点的位置： 4.4 坐标转换基于上面的分析，我们完全可以给平面的全景图赋予一个虚拟的“经纬度”。我们使用Canvas为它绘制一张”经纬网”： 将鼠标坐标转换为”经纬度”： function calLonLat(e) &#123; var h = _setContainer.style.height.split(\"px\")[0]; var w = _setContainer.style.width.split(\"px\")[0]; var ix = _setContainer.offsetLeft; var iy = _setContainer.offsetTop; iy = iy + h; var x = e.clientX; var y = e.clientY; var lonS = (x - ix) / w; var lon = 0; if (lonS &gt; 0.5) &#123; lon = -(1 - lonS) * 360; &#125; else &#123; lon = 1 * 360 * lonS; &#125; var latS = (iy - y) / h; var lat = 0; if (latS &gt; 0.5) &#123; lat = (latS - 0.5) * 180; &#125; else &#123; lat = (0.5 - latS) * 180 * -1 &#125; lon = lon.toFixed(2); lat = lat.toFixed(2); return &#123; lon: lon, lat: lat &#125;;&#125; 这样平面地图上的某点就可以和三维坐标关联起来了，当然，这还需要一定的转换，有兴趣可以去源码研究下geoPosition2World和worldPostion2Screen两个函数。 五、插件封装上面的代码中，我们实现了全景预览和全景标记的功能，下面，我们要把这些功能封装成插件。 所谓插件，即可以直接引用你写的代码，并添加少量的配置就可以实现想要的功能。 5.1 全景预览封装我们来看看，究竟哪些配置是可以抽取出来的： var options = &#123; container: 'panoramaConianer', url: 'resources/img/panorama/pano-7.jpg', lables: [], widthSegments: 60, heightSegments: 40, pRadius: 1000, minFocalLength: 1, maxFocalLength: 100, sprite: 'label', onClick: () =&gt; &#123; &#125;&#125; container:dom容器的id url:图片路径 lables:全景中的标记数组，格式为{position:{lon:114,lat:38},logoUrl:&#39;lableLogo.png&#39;,text:&#39;name&#39;} widthSegments:水平切段数 heightSegments:垂直切段数（值小粗糙速度快，值大精细速度慢） pRadius:全景球的半径，推荐使用默认值 minFocalLength:镜头最小拉近距离 maxFocalLength:镜头最大拉近距离 sprite:展示的标记类型label,icon onClick:标记的点击事件 上面的配置是可以用户配置的，那么用户该如何传入插件呢？ 我们可以在插件中声明一些默认配置options，用户使用构造函数传入参数，然后使用Object.assign将传入配置覆盖到默认配置。 接下来，你就可以使用this.def来访问这些变量了，然后只需要把写死的代码改成这些配置即可。 options = &#123; // 默认配置...&#125;function tpanorama(opt) &#123; this.render(opt);&#125;tpanorama.prototype = &#123; constructor: this, def: &#123;&#125;, render: function (opt) &#123; this.def = Object.assign(options, opt); // 初始化操作... &#125;&#125; 5.2 全景标记封装基本逻辑和上面的类似，下面是提取出来的一些参数。 var setOpt = &#123; container: 'myDiv',//setting容器 imgUrl: 'resources/img/panorama/3.jpg', width: '',//指定宽度，高度自适应 showGrid: true,//是否显示格网 showPosition: true,//是否显示经纬度提示 lableColor: '#9400D3',//标记颜色 gridColor: '#48D1CC',//格网颜色 lables: [],//标记 &#123;lon:114,lat:38,text:'标记一'&#125; addLable: true,//开启后双击添加标记 (必须开启经纬度提示) getLable: true,//开启后右键查询标记 (必须开启经纬度提示) deleteLbale: true,//开启默认中键删除 （必须开启经纬度提示）&#125; 六、发布接下来，我们就好考虑如何将写好的插件让用户使用了。 我们主要考虑两种场景，直接引用和npm install 6.1 直接引用JS为了不污染全局变量，我们使用一个自执行函数(function(){}())将代码包起来，然后将我们写好的插件暴露给全局变量window。 我把它放在originSrc目录下。 (function (global, undefined) &#123; function tpanorama(opt) &#123; // ... &#125; tpanorama.prototype = &#123; // ... &#125; function tpanoramaSetting(opt) &#123; // ... &#125; tpanoramaSetting.prototype = &#123; // ... &#125; global.tpanorama = tpanorama; global.tpanoramaSetting = panoramaSetting;&#125;(window)) 6.2 使用npm install直接将写好的插件导出： module.exports = tpanorama;module.exports = panoramaSetting; 我把它放在src目录下。 同时，我们要把package.json中的main属性指向我们要导出的文件：&quot;main&quot;: &quot;lib/index.js&quot;，然后将name、description、version等信息补充完整。 下面，我们就可以开始发布了，首先你要有一个npm账号，并且登陆，如果你没有账号，使用下面的命令创建一个账号。 npm adduser --registry http://registry.npmjs.org 如果你已经有账号了，那么可以直接使用下面的命令进行登陆。 npm login --registry http://registry.npmjs.org 登陆成功之后，就可以发布了： npm publish --registry http://registry.npmjs.org 注意，上面每个命令我都手动指定了registry，这是因为当前你使用的npm源可能已经被更换了，可能使用的是淘宝源或者公司源，这时不手动指定会导致发布失败。 发布成功后直接在npm官网上看到你的包了。 然后，你可以直接使用npm install tpanorama进行安装，然后进行使用： var &#123; tpanorama,tpanoramaSetting &#125; = require('tpanorama'); 6.3 babel编译最后不要忘了，无论使用以上哪种方式，我们都要使用babel编译后才能暴露给用户。 在scripts中创建一个build命令，将源文件进行编译，最终暴露给用户使用的将是lib和origin。 \"build\": \"babel src --out-dir lib &amp;&amp; babel originSrc --out-dir origin\", 你还可以指定一些其他的命令来供用户测试，如我将写好的例子全部放在examples中，然后在scripts定义了expamle命令： \"example\": \"npm run webpack &amp;&amp; node ./server/www\" 这样，用户将代码克隆后直接在本地运行npm run example就可以进行调试了。 七、小结本项目的github地址：https://github.com/ConardLi/tpanorama 文中如有错误，欢迎在评论区指正，如果这篇文章帮助到了你，欢迎点赞和关注。","categories":[],"tags":[{"name":"特效","slug":"特效","permalink":"www.conardli.top/tags/特效/"}]},{"title":"【自检】前端知识清单","slug":"【自检】前端知识清单","date":"2019-04-26T01:11:22.000Z","updated":"2019-04-28T04:07:15.843Z","comments":true,"path":"2019/04/26/【自检】前端知识清单/","link":"","permalink":"www.conardli.top/2019/04/26/【自检】前端知识清单/","excerpt":"","text":"开篇前端开发是一个非常特殊的行业，它的历史实际上不是很长，但是知识之繁杂，技术迭代速度之快是其他技术所不能比拟的。 winter在他的《重学前端》课程中提到： 到现在为止，前端工程师已经成为研发体系中的重要岗位之一。可是，与此相对的是，我发现极少或者几乎没有大学的计算机专业愿意开设前端课程，更没有系统性的教学方案出现。大部分前端工程师的知识，其实都是来自于实践和工作中零散的学习。 这样是一个非常真实的现状，实际上很多前端开发者都是自学甚至转行过来的，前端入门简单，学习了几个API以后上手做项目也很简单，但是这往往成为了限制自身发展的瓶颈。 只是停留在会用阶段是远远不够的，我们还需要不断探索和深入。现在市面上并不缺少学习教程，技术文章，如果盲目的学习你会发现看过以后的知识留存率会很低，而且发现没有了解到的知识越来越多，这会让人产生焦虑。 实际上，除了坚持学习的强大的自驱力，你还需要一个很简单的学习方法。那就是：建立自己的知识体系。它能帮助你更系统性的学习，同时你也时刻能知道自己哪些地方是不足的。 我会把我工作和学习中接触到的知识全部归纳到我的知识体系中，其中不仅仅包括我已经学过的，还有很多我没有来得及学习的。 这不仅仅是我的知识体系，更是我时刻提醒自己的自检清单。 下面我会把我的自检清单分享给大家，你可以按照清单上的知识检测自己还有哪些不足和提升，我也建议大家建自己的知识体系，这样工作或者学习甚至面试时，你能快速定位到知识清单中的点，如果你有哪些我没归纳到的点，欢迎在评论区告诉我。 一、JavaScript基础 前端工程师吃饭的家伙，深度、广度一样都不能差。 变量和类型 1.JavaScript规定了几种语言类型 2.JavaScript对象的底层数据结构是什么 3.Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol 4.JavaScript中的变量在内存中的具体存储形式 5.基本类型对应的内置对象，以及他们之间的装箱拆箱操作 6.理解值类型和引用类型 7.null和undefined的区别 8.至少可以说出三种判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型 9.可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用 10.出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法 原型和原型链 1.理解原型设计模式以及JavaScript中的原型规则 2.instanceof的底层实现原理，手动实现一个instanceof 4.实现继承的几种方式以及他们的优缺点 5.至少说出一种开源项目(如Node)中应用原型继承的案例 6.可以描述new一个对象的详细过程，手动实现一个new操作符 7.理解es6 class构造以及继承的底层实现原理 作用域和闭包 1.理解词法作用域和动态作用域 2.理解JavaScript的作用域和作用域链 3.理解JavaScript的执行上下文栈，可以应用堆栈信息快速定位问题 4.this的原理以及几种不同使用场景的取值 5.闭包的实现原理和作用，可以列举几个开发中闭包的实际应用 6.理解堆栈溢出和内存泄漏的原理，如何防止 7.如何处理循环的异步操作 8.理解模块化解决的实际问题，可列举几个模块化方案并理解其中原理 执行机制 1.为何try里面放return，finally还会执行，理解其内部机制 2.JavaScript如何实现异步编程，可以详细描述EventLoop机制 3.宏任务和微任务分别有哪些 4.可以快速分析一个复杂的异步嵌套逻辑，并掌握分析方法 5.使用Promise实现串行 6.Node与浏览器EventLoop的差异 7.如何在保证页面运行流畅的情况下处理海量数据 语法和API 1.理解ECMAScript和JavaScript的关系 2.熟练运用es5、es6提供的语法规范， 3.熟练掌握JavaScript提供的全局对象（例如Date、Math）、全局函数（例如decodeURI、isNaN）、全局属性（例如Infinity、undefined） 4.熟练应用map、reduce、filter 等高阶函数解决问题 5.setInterval需要注意的点，使用settimeout实现setInterval 6.JavaScript提供的正则表达式API、可以使用正则表达式（邮箱校验、URL解析、去重等）解决常见问题 7.JavaScript异常处理的方式，统一的异常处理方案 二、HTML和CSSHTML 1.从规范的角度理解HTML，从分类和语义的角度使用标签 2.常用页面标签的默认样式、自带属性、不同浏览器的差异、处理浏览器兼容问题的方式 3.元信息类标签(head、title、meta)的使用目的和配置方法 4.HTML5离线缓存原理 5.可以使用Canvas API、SVG等绘制高性能的动画 CSS 1.CSS盒模型，在不同浏览器的差异 2.CSS所有选择器及其优先级、使用场景，哪些可以继承，如何运用at规则 3.CSS伪类和伪元素有哪些，它们的区别和实际应用 4.HTML文档流的排版规则，CSS几种定位的规则、定位参照物、对文档流的影响，如何选择最好的定位方式，雪碧图实现原理 5.水平垂直居中的方案、可以实现6种以上并对比它们的优缺点 6.BFC实现原理，可以解决的问题，如何创建BFC 7.可使用CSS函数复用代码，实现特殊效果 8.PostCSS、Sass、Less的异同，以及使用配置，至少掌握一种 9.CSS模块化方案、如何配置按需加载、如何防止CSS阻塞渲染 10.熟练使用CSS实现常见动画，如渐变、移动、旋转、缩放等等 11.CSS浏览器兼容性写法，了解不同API在不同浏览器下的兼容性情况 12.掌握一套完整的响应式布局方案 手写 1.手写图片瀑布流效果 2.使用CSS绘制几何图形（圆形、三角形、扇形、菱形等） 3.使用纯CSS实现曲线运动（贝塞尔曲线） 4.实现常用布局（三栏、圣杯、双飞翼、吸顶），可是说出多种方式并理解其优缺点 三、计算机基础 关于编译原理，不需要理解非常深入，但是最基本的原理和概念一定要懂，这对于学习一门编程语言非常重要 编译原理 1.理解代码到底是什么，计算机如何将代码转换为可以运行的目标程序 2.正则表达式的匹配原理和性能优化 3.如何将JavaScript代码解析成抽象语法树(AST) 4.base64的编码原理 5.几种进制的相互转换计算方法，在JavaScript中如何表示和转换 网络协议 1.理解什么是协议，了解TCP/IP网络协议族的构成，每层协议在应用程序中发挥的作用 2.三次握手和四次挥手详细原理，为什么要使用这种机制 3.有哪些协议是可靠，TCP有哪些手段保证可靠交付 4.DNS的作用、DNS解析的详细过程，DNS优化原理 5.CDN的作用和原理 6.HTTP请求报文和响应报文的具体组成，能理解常见请求头的含义，有几种请求方式，区别是什么 7.HTTP所有状态码的具体含义，看到异常状态码能快速定位问题 8.HTTP1.1、HTTP2.0带来的改变 9.HTTPS的加密原理，如何开启HTTPS，如何劫持HTTPS请求 10.理解WebSocket协议的底层原理、与HTTP的区别 设计模式 1.熟练使用前端常用的设计模式编写代码，如单例模式、装饰器模式、代理模式等 2.发布订阅模式和观察者模式的异同以及实际应用 3.可以说出几种设计模式在开发中的实际应用，理解框架源码中对设计模式的应用 四、数据结构和算法 据我了解的大部分前端对这部分知识有些欠缺，甚至抵触，但是，如果突破更高的天花板，这部分知识是必不可少的，而且我亲身经历——非常有用！ JavaScript编码能力 1.多种方式实现数组去重、扁平化、对比优缺点 2.多种方式实现深拷贝、对比优缺点 3.手写函数柯里化工具函数、并理解其应用场景和优势 4.手写防抖和节流工具函数、并理解其内部原理和应用场景 5.实现一个sleep函数 手动实现前端轮子 1.手动实现call、apply、bind 2.手动实现符合Promise/A+规范的Promise、手动实现async await 3.手写一个EventEmitter实现事件发布、订阅 4.可以说出两种实现双向绑定的方案、可以手动实现 5.手写JSON.stringify、JSON.parse 6.手写一个模版引擎，并能解释其中原理 7.手写懒加载、下拉刷新、上拉加载、预加载等效果 数据结构 1.理解常见数据结构的特点，以及他们在不同场景下使用的优缺点 2.理解数组、字符串的存储原理，并熟练应用他们解决问题 3.理解二叉树、栈、队列、哈希表的基本结构和特点，并可以应用它解决问题 4.了解图、堆的基本结构和使用场景 算法 1.可计算一个算法的时间复杂度和空间复杂度，可估计业务逻辑代码的耗时和内存消耗 2.至少理解五种排序算法的实现原理、应用场景、优缺点，可快速说出时间、空间复杂度 3.了解递归和循环的优缺点、应用场景、并可在开发中熟练应用 4.可应用回溯算法、贪心算法、分治算法、动态规划等解决复杂问题 5.前端处理海量数据的算法方案 五、运行环境我们需要理清语言和环境的关系： ECMAScript描述了JavaScript语言的语法和基本对象规范 浏览器作为JavaScript的一种运行环境，为它提供了：文档对象模型（DOM），描述处理网页内容的方法和接口、浏览器对象模型（BOM），描述与浏览器进行交互的方法和接口 Node也是JavaScript的一种运行环境，为它提供了操作I/O、网络等API 浏览器API 1.浏览器提供的符合W3C标准的DOM操作API、浏览器差异、兼容性 2.浏览器提供的浏览器对象模型 (BOM)提供的所有全局API、浏览器差异、兼容性 3.大量DOM操作、海量数据的性能优化(合并操作、Diff、requestAnimationFrame等) 4.浏览器海量数据存储、操作性能优化 5.DOM事件流的具体实现机制、不同浏览器的差异、事件代理 6.前端发起网络请求的几种方式及其底层实现、可以手写原生ajax、fetch、可以熟练使用第三方库 7.浏览器的同源策略，如何避免同源策略，几种方式的异同点以及如何选型 8.浏览器提供的几种存储机制、优缺点、开发中正确的选择 9.浏览器跨标签通信 浏览器原理 1.各浏览器使用的JavaScript引擎以及它们的异同点、如何在代码中进行区分 2.请求数据到请求结束与服务器进行了几次交互 3.可详细描述浏览器从输入URL到页面展现的详细过程 4.浏览器解析HTML代码的原理，以及构建DOM树的流程 5.浏览器如何解析CSS规则，并将其应用到DOM树上 6.浏览器如何将解析好的带有样式的DOM树进行绘制 7.浏览器的运行机制，如何配置资源异步同步加载 8.浏览器回流与重绘的底层原理，引发原因，如何有效避免 9.浏览器的垃圾回收机制，如何避免内存泄漏 10.浏览器采用的缓存方案，如何选择和控制合适的缓存方案 Node 1.理解Node在应用程序中的作用，可以使用Node搭建前端运行环境、使用Node操作文件、操作数据库等等 2.掌握一种Node开发框架，如Express，Express和Koa的区别 3.熟练使用Node提供的API如Path、Http、Child Process等并理解其实现原理 4.Node的底层运行原理、和浏览器的异同 5.Node事件驱动、非阻塞机制的实现原理 六、框架和类库 轮子层出不穷，从原理上理解才是正道 TypeScript 1.理解泛型、接口等面向对象的相关概念，TypeScript对面向对象理念的实现 2.理解使用TypeScript的好处，掌握TypeScript基础语法 3.TypeScript的规则检测原理 4.可以在React、Vue等框架中使用TypeScript进行开发 React 1.React和vue选型和优缺点、核心架构的区别 2.React中setState的执行机制，如何有效的管理状态 3.React的事件底层实现机制 4.React的虚拟DOM和Diff算法的内部实现 5.React的Fiber工作原理，解决了什么问题 6.React Router和Vue Router的底层实现原理、动态加载实现原理 7.可熟练应用React API、生命周期等，可应用HOC、render props、Hooks等高阶用法解决问题 8.基于React的特性和原理，可以手动实现一个简单的React Vue 1.熟练使用Vue的API、生命周期、钩子函数 2.MVVM框架设计理念 3.Vue双向绑定实现原理、Diff算法的内部实现 4.Vue的事件机制 5.从template转换成真实DOM的实现机制 多端开发 1.单页面应用（SPA）的原理和优缺点，掌握一种快速开发SPA的方案 2.理解Viewport、em、rem的原理和用法，分辨率、px、ppi、dpi、dp的区别和实际应用 3.移动端页面适配解决方案、不同机型适配方案 4.掌握一种JavaScript移动客户端开发技术，如React Native：可以搭建React Native开发环境，熟练进行开发，可理解React Native的运作原理，不同端适配 5.掌握一种JavaScript PC客户端开发技术，如Electron：可搭建Electron开发环境，熟练进行开发，可理解Electron的运作原理 6.掌握一种小程序开发框架或原生小程序开发 7.理解多端框架的内部实现原理，至少了解一个多端框架的使用 数据流管理 1.掌握React和Vue传统的跨组件通信方案，对比采用数据流管理框架的异同 2.熟练使用Redux管理数据流，并理解其实现原理，中间件实现原理 3.熟练使用Mobx管理数据流，并理解其实现原理，相比Redux有什么优势 4.熟练使用Vuex管理数据流，并理解其实现原理 5.以上数据流方案的异同和优缺点，不情况下的技术选型 实用库 1.至少掌握一种UI组件框架，如antd design，理解其设计理念、底层实现 2.掌握一种图表绘制框架，如Echart，理解其设计理念、底层实现，可以自己实现图表 3.掌握一种GIS开发框架，如百度地图API 4.掌握一种可视化开发框架，如Three.js、D3 5.工具函数库，如lodash、underscore、moment等，理解使用的工具类或工具函数的具体实现原理 开发和调试 1.熟练使用各浏览器提供的调试工具 2.熟练使用一种代理工具实现请求代理、抓包，如charls 3.可以使用Android、IOS模拟器进行调试，并掌握一种真机调试方案 4.了解Vue、React等框架调试工具的使用 七、前端工程 前端工程化：以工程化方法和工具提高开发生产效率、降低维护难度 项目构建 1.理解npm、yarn依赖包管理的原理，两者的区别 2.可以使用npm运行自定义脚本 3.理解Babel、ESLint、webpack等工具在项目中承担的作用 4.ESLint规则检测原理，常用的ESLint配置 5.Babel的核心原理，可以自己编写一个Babel插件 6.可以配置一种前端代码兼容方案，如Polyfill 7.Webpack的编译原理、构建流程、热更新原理，chunk、bundle和module的区别和应用 8.可熟练配置已有的loaders和plugins解决问题，可以自己编写loaders和plugins nginx 1.正向代理与反向代理的特点和实例 2.可手动搭建一个简单的nginx服务器、 3.熟练应用常用的nginx内置变量，掌握常用的匹配规则写法 4.可以用nginx实现请求过滤、配置gzip、负载均衡等，并能解释其内部原理 开发提速 1.熟练掌握一种接口管理、接口mock工具的使用，如yapi 2.掌握一种高效的日志埋点方案，可快速使用日志查询工具定位线上问题 3.理解TDD与BDD模式，至少会使用一种前端单元测试框架 版本控制 1.理解Git的核心原理、工作流程、和SVN的区别 2.熟练使用常规的Git命令、git rebase、git stash等进阶命令 3.可以快速解决线上分支回滚、线上分支错误合并等复杂问题 持续集成 1.理解CI/CD技术的意义，至少熟练掌握一种CI/CD工具的使用，如Jenkins 2.可以独自完成架构设计、技术选型、环境搭建、全流程开发、部署上线等一套完整的开发流程（包括Web应用、移动客户端应用、PC客户端应用、小程序、H5等等） 八、项目和业务后端技能 1.了解后端的开发方式，在应用程序中的作用，至少会使用一种后端语言 2.掌握数据最终在数据库中是如何落地存储的，能看懂表结构设计、表之间的关联，至少会使用一种数据库 性能优化 1.了解前端性能衡量指标、性能监控要点，掌握一种前端性能监控方案 2.了解常见的Web、App性能优化方案 3.SEO排名规则、SEO优化方案、前后端分离的SEO 4.SSR实现方案、优缺点、及其性能优化 5.Webpack的性能优化方案 6.Canvas性能优化方案 7.React、Vue等框架使用性能优化方案 前端安全 1.XSS攻击的原理、分类、具体案例，前端如何防御 2.CSRF攻击的原理、具体案例，前端如何防御 3.HTTP劫持、页面劫持的原理、防御措施 业务相关 1.能理解所开发项目的整体业务形态、业务目标、业务架构，可以快速定位线上业务问题 2.能理解所开发项目整体的技术架构、能快读的根据新需求进行开发规划、能快速根据业务报警、线上日志等定位并解决线上技术问题 3.可以将自己的想法或新技术在业务中落地实践，尽量在团队中拥有一定的不可替代性 九、学习提升vczh大神在知乎问题【如何能以后达到温赵轮三位大神的水平？】下的回答： 这十几年我一共做了三件事： 1、不以赚钱为目的选择学习的内容； 2、以自己是否能造出轮子来衡量学习的效果； 3、坚持每天写自己的代码，前10年每天至少6个小时，不包含学习和工作的时间。 上面几点可能有点难，第一点我就做不到，但是做到下面绩点还是比较容易的。 关于写博客说明下，能给别人讲明白的知识会比自己学习掌握的要深刻许多 1.拥有自己的技术博客，或者在一些博客平台上拥有自己的专栏 2.定期的将知识进行总结，不断完善自己的知识体系 3.尽量将自己的知识转换成真实的产出，不要仅仅停留在书面理解层面，更重要的是实际应用 4.坚持输出自己的代码，不要盲目的扎进公司业 十、技术之外 这部分可能比上面九条加起来重要！ 1.了解互联网人员术语：CEO、CTO、COO、CFO、PM、QA、UI、FE、DEV、DBA、OPS等 2.了解互联网行业术语：B2B、B2C、C2C、O2O等 3.掌握互联网行业沟通、问答、学习的 4.有一定的&quot;PPT&quot;能力 5.有一定的理财意识，至少了解储蓄、货币基金、保险、指数基金、股票等基本的理财知识 6.掌握在繁重的工作和长期的电脑辐射的情况下保持健康的方法，建立正确的养生知识体系 十一、资源推荐有了知识体系，在阅读一篇技术文章的时候就很容易把它归类，我一直以来就是这样做的。 事实证明，在阅读文章或书籍时，有目的和归类的阅读比”随便看看”后的只是留存率要高很多。 每阅读到一篇好的文章或者书籍，我都会收藏并归类到我的知识体系中。 下面是一些我觉得还不错的文章、博客或者书籍教程等等，分享给大家，资源不多，但都是精品。 学习一门知识，最好先阅读官方文档，把所有的API大概浏览一遍，再继续看大佬们总结的进阶知识，什么东西是搬运过来的，什么是干货，一目了然。 语言基础 [📚]JavaScript高级程序设计（必看）：https://book.douban.com/subject/10546125/ [📚]高性能JavaScript：https://book.douban.com/subject/5362856/ 现代JavaScript教程：https://zh.javascript.info/ 阮一峰的ECMAScript 6教程：http://es6.ruanyifeng.com/ ECMAScript 6标准：https://www.ecma-international.org/ecma-262/6.0/ HTML meta标签总结与属性使用介绍：https://segmentfault.com/a/1190000004279791 CSS编码指导：https://github.com/chadluo/CSS-Guidelines/blob/master/README.md 计算机基础 大前端开发者需要了解的基础编译原理和语言知识：http://fullstack.blog/2017/06/24/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%80%85%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%92%8C%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86 图解HTTP：https://book.douban.com/subject/25863515/ [📚]JavaScript设计模式与开发实践：https://book.douban.com/subject/26382780/ 正则表达式30分钟入门教程：https://link.juejin.im/?target=https%3A%2F%2Fdeerchao.net%2Ftutorials%2Fregex%2Fregex.htm 数据结构和算法 数据结构与算法之美：https://time.geekbang.org/column/intro/126 用动画的形式呈现解LeetCode题目的思路：https://github.com/MisterBooo/LeetCodeAnimation JavaScript数据结构和算法：https://github.com/ConardLi/awesome-coding-js 30-seconds-of-code（里面有很多js代码非常巧妙，我正在将它翻译成中文）：https://github.com/ConardLi/30-seconds-of-code-Zh-CN 运行环境 《重学前端》中的浏览器原理章节：https://time.geekbang.org/column/article/80240 图解浏览器的基本工作原理：https://zhuanlan.zhihu.com/p/47407398 七天学会NodeJS：https://github.com/nqdeng/7-days-nodejs Node.js模块加载与运行原理：https://efe.baidu.com/blog/nodejs-module-analyze/ 框架和类库 TypeScript Handbook：https://zhongsp.gitbooks.io/typescript-handbook/content/ React.js小书：http://huziketang.mangojuice.top/books/react/ React深入系列：https://juejin.im/post/5cad39b3f265da03502b1c0a Webpack React小书：https://fakefish.github.io/react-webpack-cookbook/index.html Vue.js技术揭秘：https://github.com/ustbhuangyi/vue-analysis Vuex-在Vue中管理状态：https://sabe.io/tutorials/getting-started-with-vuex 你需要Mobx还是Redux？：https://juejin.im/post/5a7fd72c5188257a766324ae Underscore源码分析：https://yoyoyohamapi.gitbooks.io/undersercore-analysis/content/ 微信小程序开发资源汇总：https://github.com/justjavac/awesome-wechat-weapp 腾讯移动Web前端知识库：https://github.com/AlloyTeam/Mars 前端工程 一口（很长的）气了解babel：https://zhuanlan.zhihu.com/p/43249121 Webpack傻瓜式指南：https://zhuanlan.zhihu.com/p/20367175 Webpack原理：https://segmentfault.com/a/1190000015088834?utm_source=tag-newest 廖雪峰的git教程：https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000 图解Git：https://marklodato.github.io/visual-git-guide/index-zh-cn.html 前端开发者必备的Nginx知识：https://juejin.im/post/5c85a64d6fb9a04a0e2e038c 使用Jenkins进行持续集成：https://www.liaoxuefeng.com/article/001463233913442cdb2d1bd1b1b42e3b0b29eb1ba736c5e000 项目和业务 常见六大Web安全攻防解析：https://github.com/ljianshu/Blog/issues/56 深入理解前端性能监控：https://juejin.im/post/5caaacc0e51d452b45296487#heading-5 [📚]高性能网站建设指南：https://book.douban.com/subject/3132277/ 新人如何快速融入技术实力强的前端团队：https://juejin.im/post/5cb860a86fb9a06890705f14 学习提升 印记中文（各种中文开发文档）：https://www.docschina.org/ 前端学习方法：https://github.com/helloqingfeng/Awsome-Front-End-learning-resource/tree/master/01-FE-learning-master 如何在工作内外获得持续的技术成长：https://juejin.im/post/5cbd7477f265da039d32834e 优秀的前端博客汇总：https://github.com/foru17/front-end-collect 另外推荐我一直在关注的几位大佬的个人博客： 冴羽的博客：https://github.com/mqyqingfeng/Blog 张鑫旭的博客：https://www.zhangxinxu.com/wordpress/ 左耳朵耗子：https://coolshell.cn/ 技术之外 互联网术语大全：https://www.jianshu.com/p/9a7ca206c1ab 互联网沟通、问答、学习的艺术：https://zhuanlan.zhihu.com/p/41431775 经常加班至深夜，怎样才能保持身体健康：https://www.zhihu.com/question/21790919 其实在这个信息发达的时代最不缺的就是资源，如何从众多的资源中获取到真正精华的部分，是非常重要的，资源在于精不在于多，强烈建议在保证深度的情况下再保证广度。 小结希望你阅读本篇文章后可以达到以下几点： 从知识清单中找到自己的知识盲点与欠缺 具有知识体系化的思想，开始建立自己的知识体系 阅读文章时将知识归类到知识体系中，并不断完善自己的知识体系 从文章中获取到了有用的资源 文中如有错误，欢迎在评论区指正，如果这篇文章帮助到了你，欢迎点赞和关注。 如果你有什么好的知识、资源推荐，欢迎在评论区留言。","categories":[],"tags":[{"name":"-学习提升","slug":"学习提升","permalink":"www.conardli.top/tags/学习提升/"}]},{"title":"【React深入】深入分析虚拟DOM的渲染原理和特性","slug":"【React深入】深入分析虚拟DOM的渲染原理和特性","date":"2019-04-17T03:15:27.000Z","updated":"2019-04-17T03:17:23.518Z","comments":true,"path":"2019/04/17/【React深入】深入分析虚拟DOM的渲染原理和特性/","link":"","permalink":"www.conardli.top/2019/04/17/【React深入】深入分析虚拟DOM的渲染原理和特性/","excerpt":"","text":"导读React的虚拟DOM和Diff算法是React的非常重要的核心特性，这部分源码也非常复杂，理解这部分知识的原理对更深入的掌握React是非常必要的。 本来想将虚拟DOM和Diff算法放到一篇文章，写完虚拟DOM发现文章已经很长了，所以本篇只分析虚拟DOM。 本篇文章从源码出发，分析虚拟DOM的核心渲染原理（首次渲染），以及React对它做的性能优化点。 说实话React源码真的很难读😅，如果本篇文章帮助到了你，那么请给个赞👍支持一下吧。 开发中的常见问题 为何必须引用React 自定义的React组件为何必须大写 React如何防止XSS React的Diff算法和其他的Diff算法有何区别 key在React中的作用 如何写出高性能的React组件 如果你对上面几个问题还存在疑问，说明你对React的虚拟DOM以及Diff算法实现原理还有所欠缺，那么请好好阅读本篇文章吧。 首先我们来看看到底什么是虚拟DOM: 虚拟DOM 在原生的JavaScript程序中，我们直接对DOM进行创建和更改，而DOM元素通过我们监听的事件和我们的应用程序进行通讯。 而React会先将你的代码转换成一个JavaScript对象，然后这个JavaScript对象再转换成真实DOM。这个JavaScript对象就是所谓的虚拟DOM。 比如下面一段html代码： &lt;div class=\"title\"&gt; &lt;span&gt;Hello ConardLi&lt;/span&gt; &lt;ul&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;橘子&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 在React可能存储为这样的JS代码： const VitrualDom = &#123; type: 'div', props: &#123; class: 'title' &#125;, children: [ &#123; type: 'span', children: 'Hello ConardLi' &#125;, &#123; type: 'ul', children: [ &#123; type: 'ul', children: '苹果' &#125;, &#123; type: 'ul', children: '橘子' &#125; ] &#125; ]&#125; 当我们需要创建或更新元素时，React首先会让这个VitrualDom对象进行创建和更改，然后再将VitrualDom对象渲染成真实DOM； 当我们需要对DOM进行事件监听时，首先对VitrualDom进行事件监听，VitrualDom会代理原生的DOM事件从而做出响应。 为何使用虚拟DOMReact为何采用VitrualDom这种方案呢？ 提高开发效率使用JavaScript，我们在编写应用程序时的关注点在于如何更新DOM。 使用React，你只需要告诉React你想让视图处于什么状态，React则通过VitrualDom确保DOM与该状态相匹配。你不必自己去完成属性操作、事件处理、DOM更新，React会替你完成这一切。 这让我们更关注我们的业务逻辑而非DOM操作，这一点即可大大提升我们的开发效率。 关于提升性能很多文章说VitrualDom可以提升性能，这一说法实际上是很片面的。 直接操作DOM是非常耗费性能的，这一点毋庸置疑。但是React使用VitrualDom也是无法避免操作DOM的。 如果是首次渲染，VitrualDom不具有任何优势，甚至它要进行更多的计算，消耗更多的内存。 VitrualDom的优势在于React的Diff算法和批处理策略，React在页面更新之前，提前计算好了如何进行更新和渲染DOM。实际上，这个计算过程我们在直接操作DOM时，也是可以自己判断和实现的，但是一定会耗费非常多的精力和时间，而且往往我们自己做的是不如React好的。所以，在这个过程中React帮助我们”提升了性能”。 所以，我更倾向于说，VitrualDom帮助我们提高了开发效率，在重复渲染时它帮助我们计算如何更高效的更新，而不是它比DOM操作更快。 如果您对本部分的分析有什么不同见解，欢迎在评论区拍砖。 跨浏览器兼容 React基于VitrualDom自己实现了一套自己的事件机制，自己模拟了事件冒泡和捕获的过程，采用了事件代理，批量更新等方法，抹平了各个浏览器的事件兼容性问题。 跨平台兼容 VitrualDom为React带来了跨平台渲染的能力。以React Native为例子。React根据VitrualDom画出相应平台的ui层，只不过不同平台画的姿势不同而已。 虚拟DOM实现原理如果你不想看繁杂的源码，或者现在没有足够时间，可以跳过这一章，直接👇虚拟DOM原理总结 在上面的图上我们继续进行扩展，按照图中的流程，我们依次来分析虚拟DOM的实现原理。 JSX和createElement我们在实现一个React组件时可以选择两种编码方式，第一种是使用JSX编写： class Hello extends Component &#123; render() &#123; return &lt;div&gt;Hello ConardLi&lt;/div&gt;; &#125;&#125; 第二种是直接使用React.createElement编写： class Hello extends Component &#123; render() &#123; return React.createElement('div', null, `Hello ConardLi`); &#125;&#125; 实际上，上面两种写法是等价的，JSX只是为 React.createElement(component, props, ...children)方法提供的语法糖。也就是说所有的JSX代码最后都会转换成React.createElement(...)，Babel帮助我们完成了这个转换的过程。 如下面的JSX &lt;div&gt; &lt;img src=\"avatar.png\" className=\"profile\" /&gt; &lt;Hello /&gt;&lt;/div&gt;; 将会被Babel转换为React.createElement(\"div\", null, React.createElement(\"img\", &#123; src: \"avatar.png\", className: \"profile\"&#125;), React.createElement(Hello, null)); 注意，babel在编译时会判断JSX中组件的首字母，当首字母为小写时，其被认定为原生DOM标签，createElement的第一个变量被编译为字符串；当首字母为大写时，其被认定为自定义组件，createElement的第一个变量被编译为对象； 另外，由于JSX提前要被Babel编译，所以JSX是不能在运行时动态选择类型的，比如下面的代码： function Story(props) &#123; // Wrong! JSX type can't be an expression. return &lt;components[props.storyType] story=&#123;props.story&#125; /&gt;;&#125; 需要变成下面的写法： function Story(props) &#123; // Correct! JSX type can be a capitalized variable. const SpecificStory = components[props.storyType]; return &lt;SpecificStory story=&#123;props.story&#125; /&gt;;&#125; 所以，使用JSX你需要安装Babel插件babel-plugin-transform-react-jsx &#123; \"plugins\": [ [\"transform-react-jsx\", &#123; \"pragma\": \"React.createElement\" &#125;] ]&#125; 创建虚拟DOM下面我们来看看虚拟DOM的真实模样，将下面的JSX代码在控制台打印出来： &lt;div className=\"title\"&gt; &lt;span&gt;Hello ConardLi&lt;/span&gt; &lt;ul&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;橘子&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 这个结构和我们上面自己描绘的结构很像，那么React是如何将我们的代码转换成这个结构的呢，下面我们来看看createElement函数的具体实现（文中的源码经过精简）。 createElement函数内部做的操作很简单，将props和子元素进行处理后返回一个ReactElement对象，下面我们来逐一分析： (1).处理props： 1.将特殊属性ref、key从config中取出并赋值 2.将特殊属性self、source从config中取出并赋值 3.将除特殊属性的其他属性取出并赋值给props 后面的文章会详细介绍这些特殊属性的作用。 (2).获取子元素 1.获取子元素的个数 —— 第二个参数后面的所有参数 2.若只有一个子元素，赋值给props.children 3.若有多个子元素，将子元素填充为一个数组赋值给props.children (3).处理默认props 将组件的静态属性defaultProps定义的默认props进行赋值 ReactElement ReactElement将传入的几个属性进行组合，并返回。 type：元素的类型，可以是原生html类型（字符串），或者自定义组件（函数或class） key：组件的唯一标识，用于Diff算法，下面会详细介绍 ref：用于访问原生dom节点 props：传入组件的props owner：当前正在构建的Component所属的Component $$typeof：一个我们不常见到的属性，它被赋值为REACT_ELEMENT_TYPE： var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &amp;&amp; Symbol.for &amp;&amp; Symbol.for('react.element')) || 0xeac7; 可见，$$typeof是一个Symbol类型的变量，这个变量可以防止XSS。 如果你的服务器有一个漏洞，允许用户存储任意JSON对象， 而客户端代码需要一个字符串，这可能会成为一个问题：// JSONlet expectedTextButGotJSON = &#123; type: 'div', props: &#123; dangerouslySetInnerHTML: &#123; __html: '/* put your exploit here */' &#125;, &#125;,&#125;;let message = &#123; text: expectedTextButGotJSON &#125;;&lt;p&gt; &#123;message.text&#125;&lt;/p&gt; JSON中不能存储Symbol类型的变量。 ReactElement.isValidElement函数用来判断一个React组件是否是有效的，下面是它的具体实现。 ReactElement.isValidElement = function (object) &#123; return typeof object === 'object' &amp;&amp; object !== null &amp;&amp; object.$$typeof === REACT_ELEMENT_TYPE;&#125;; 可见React渲染时会把没有$$typeof标识，以及规则校验不通过的组件过滤掉。 当你的环境不支持Symbol时，$$typeof被赋值为0xeac7，至于为什么，React开发者给出了答案： 0xeac7看起来有点像React。 self、source只有在非生产环境才会被加入对象中。 self指定当前位于哪个组件实例。 _source指定调试代码来自的文件(fileName)和代码行数(lineNumber)。 虚拟DOM转换为真实DOM上面我们分析了代码转换成了虚拟DOM的过程，下面来看一下React如何将虚拟DOM转换成真实DOM。 本部分逻辑较复杂，我们先用流程图梳理一下整个过程，整个过程大概可分为四步： 过程1：初始参数处理 在编写好我们的React组件后，我们需要调用ReactDOM.render(element, container[, callback])将组件进行渲染。 render函数内部实际调用了_renderSubtreeIntoContainer，我们来看看它的具体实现： render: function (nextElement, container, callback) &#123; return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);&#125;, 1.将当前组件使用TopLevelWrapper进行包裹 TopLevelWrapper只一个空壳，它为你需要挂载的组件提供了一个rootID属性，并在render函数中返回该组件。 TopLevelWrapper.prototype.render = function () &#123; return this.props.child;&#125;; ReactDOM.render函数的第一个参数可以是原生DOM也可以是React组件，包裹一层TopLevelWrapper可以在后面的渲染中将它们进行统一处理，而不用关心是否原生。 2.判断根结点下是否已经渲染过元素，如果已经渲染过，判断执行更新或者卸载操作 3.处理shouldReuseMarkup变量，该变量表示是否需要重新标记元素 4.调用将上面处理好的参数传入_renderNewRootComponent，渲染完成后调用callback。 在_renderNewRootComponent中调用instantiateReactComponent对我们传入的组件进行分类包装： 根据组件的类型，React根据原组件创建了下面四大类组件，对组件进行分类渲染： ReactDOMEmptyComponent:空组件 ReactDOMTextComponent:文本 ReactDOMComponent:原生DOM ReactCompositeComponent:自定义React组件 他们都具备以下三个方法： construct:用来接收ReactElement进行初始化。 mountComponent:用来生成ReactElement对应的真实DOM或DOMLazyTree。 unmountComponent:卸载DOM节点，解绑事件。 具体是如何渲染我们在过程3中进行分析。 过程2：批处理、事务调用 在_renderNewRootComponent中使用ReactUpdates.batchedUpdates调用batchedMountComponentIntoNode进行批处理。 ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context); 在batchedMountComponentIntoNode中，使用transaction.perform调用mountComponentIntoNode让其基于事务机制进行调用。 transaction.perform(mountComponentIntoNode, null, componentInstance, container, transaction, shouldReuseMarkup, context); 关于批处理事务，在我前面的分析setState执行机制中有更多介绍。 过程3：生成html 在mountComponentIntoNode函数中调用ReactReconciler.mountComponent生成原生DOM节点。 mountComponent内部实际上是调用了过程1生成的四种对象的mountComponent方法。首先来看一下ReactDOMComponent： 1.对特殊DOM标签、props进行处理。 2.根据标签类型创建DOM节点。 3.调用_updateDOMProperties将props插入到DOM节点，_updateDOMProperties也可用于props Diff，第一个参数为上次渲染的props，第二个参数为当前props，若第一个参数为空，则为首次创建。 4.生成一个DOMLazyTree对象并调用_createInitialChildren将孩子节点渲染到上面。 那么为什么不直接生成一个DOM节点而是要创建一个DOMLazyTree呢？我们先来看看_createInitialChildren做了什么： 判断当前节点的dangerouslySetInnerHTML属性、孩子节点是否为文本和其他节点分别调用DOMLazyTree的queueHTML、queueText、queueChild。 可以发现：DOMLazyTree实际上是一个包裹对象，node属性中存储了真实的DOM节点，children、html、text分别存储孩子、html节点和文本节点。 它提供了几个方法用于插入孩子、html以及文本节点，这些插入都是有条件限制的，当enableLazy属性为true时，这些孩子、html以及文本节点会被插入到DOMLazyTree对象中，当其为false时会插入到真实DOM节点中。 var enableLazy = typeof document !== 'undefined' &amp;&amp; typeof document.documentMode === 'number' || typeof navigator !== 'undefined' &amp;&amp; typeof navigator.userAgent === 'string' &amp;&amp; /\\bEdge\\/\\d/.test(navigator.userAgent); 可见：enableLazy是一个变量，当前浏览器是IE或Edge时为true。 在IE（8-11）和Edge浏览器中，一个一个插入无子孙的节点，效率要远高于插入一整个序列化完整的节点树。 所以lazyTree主要解决的是在IE（8-11）和Edge浏览器中插入节点的效率问题，在后面的过程4我们会分析到：若当前是IE或Edge，则需要递归插入DOMLazyTree中缓存的子节点，其他浏览器只需要插入一次当前节点，因为他们的孩子已经被渲染好了，而不用担心效率问题。 下面来看一下ReactCompositeComponent，由于代码非常多这里就不再贴这个模块的代码，其内部主要做了以下几步： 处理props、contex等变量，调用构造函数创建组件实例 判断是否为无状态组件，处理state 调用performInitialMount生命周期，处理子节点，获取markup。 调用componentDidMount生命周期 在performInitialMount函数中，首先调用了componentWillMount生命周期，由于自定义的React组件并不是一个真实的DOM，所以在函数中又调用了孩子节点的mountComponent。这也是一个递归的过程，当所有孩子节点渲染完成后，返回markup并调用componentDidMount。 过程4：渲染html 在mountComponentIntoNode函数中调用将上一步生成的markup插入container容器。 在首次渲染时，_mountImageIntoNode会清空container的子节点后调用DOMLazyTree.insertTreeBefore： 判断是否为fragment节点或者&lt;object&gt;插件： 如果是以上两种，首先调用insertTreeChildren将此节点的孩子节点渲染到当前节点上，再将渲染完的节点插入到html 如果是其他节点，先将节点插入到插入到html，再调用insertTreeChildren将孩子节点插入到html。 若当前不是IE或Edge，则不需要再递归插入子节点，只需要插入一次当前节点。 判断不是IE或bEdge时return 若children不为空，递归insertTreeBefore进行插入 渲染html节点 渲染文本节点 原生DOM事件代理有关虚拟DOM的事件机制，我曾专门写过一篇文章，有兴趣可以👇【React深入】React事件机制 虚拟DOM原理、特性总结React组件的渲染流程 使用React.createElement或JSX编写React组件，实际上所有的JSX代码最后都会转换成React.createElement(...)，Babel帮助我们完成了这个转换的过程。 createElement函数对key和ref等特殊的props进行处理，并获取defaultProps对默认props进行赋值，并且对传入的孩子节点进行处理，最终构造成一个ReactElement对象（所谓的虚拟DOM）。 ReactDOM.render将生成好的虚拟DOM渲染到指定容器上，其中采用了批处理、事务等机制并且对特定浏览器进行了性能优化，最终转换为真实DOM。 虚拟DOM的组成即ReactElementelement对象，我们的组件最终会被渲染成下面的结构： type：元素的类型，可以是原生html类型（字符串），或者自定义组件（函数或class） key：组件的唯一标识，用于Diff算法，下面会详细介绍 ref：用于访问原生dom节点 props：传入组件的props，chidren是props中的一个属性，它存储了当前组件的孩子节点，可以是数组（多个孩子节点）或对象（只有一个孩子节点） owner：当前正在构建的Component所属的Component self：（非生产环境）指定当前位于哪个组件实例 _source：（非生产环境）指定调试代码来自的文件(fileName)和代码行数(lineNumber) 防止XSSReactElement对象还有一个$$typeof属性，它是一个Symbol类型的变量Symbol.for(&#39;react.element&#39;)，当环境不支持Symbol时，$$typeof被赋值为0xeac7。 这个变量可以防止XSS。如果你的服务器有一个漏洞，允许用户存储任意JSON对象， 而客户端代码需要一个字符串，这可能为你的应用程序带来风险。JSON中不能存储Symbol类型的变量，而React渲染时会把没有$$typeof标识的组件过滤掉。 批处理和事务React在渲染虚拟DOM时应用了批处理以及事务机制，以提高渲染性能。 关于批处理以及事务机制，在我之前的文章【React深入】setState的执行机制中有详细介绍。 针对性的性能优化在IE（8-11）和Edge浏览器中，一个一个插入无子孙的节点，效率要远高于插入一整个序列化完整的节点树。 React通过lazyTree，在IE（8-11）和Edge中进行单个节点依次渲染节点，而在其他浏览器中则首先将整个大的DOM结构构建好，然后再整体插入容器。 并且，在单独渲染节点时，React还考虑了fragment等特殊节点，这些节点则不会一个一个插入渲染。 虚拟DOM事件机制React自己实现了一套事件机制，其将所有绑定在虚拟DOM上的事件映射到真正的DOM事件，并将所有的事件都代理到document上，自己模拟了事件冒泡和捕获的过程，并且进行统一的事件分发。 React自己构造了合成事件对象SyntheticEvent，这是一个跨浏览器原生事件包装器。 它具有与浏览器原生事件相同的接口，包括stopPropagation()和preventDefault()等等，在所有浏览器中他们工作方式都相同。这抹平了各个浏览器的事件兼容性问题。 上面只分析虚拟DOM首次渲染的原理和过程，当然这并不包括虚拟 DOM进行 Diff的过程，下一篇文章我们再来详细探讨。 关于开篇提的几个问题，我们在下篇文章中进行统一回答。 末尾文中如有错误，欢迎在评论区指正，或者您对文章的排版，阅读体验有什么好的建议，欢迎在评论区指出，谢谢阅读。 想阅读更多优质文章、下载文章中思维导图源文件、阅读文中demo源码、可关注我的github博客，你的star✨、点赞和关注是我持续创作的动力！","categories":[],"tags":[{"name":"React","slug":"React","permalink":"www.conardli.top/tags/React/"}]},{"title":"【React深入】从Mixin到HOC再到Hook","slug":"【React深入】从Mixin到HOC再到Hook","date":"2019-04-09T15:27:27.000Z","updated":"2019-04-09T15:28:00.607Z","comments":true,"path":"2019/04/09/【React深入】从Mixin到HOC再到Hook/","link":"","permalink":"www.conardli.top/2019/04/09/【React深入】从Mixin到HOC再到Hook/","excerpt":"","text":"导读前端发展速度非常之快，页面和组件变得越来越复杂，如何更好的实现状态逻辑复用一直都是应用程序中重要的一部分，这直接关系着应用程序的质量以及维护的难易程度。 本文介绍了React采用的三种实现状态逻辑复用的技术，并分析了他们的实现原理、使用方法、实际应用以及如何选择使用他们。 本文略长，下面是本文的思维导图，您可以从头开始阅读，也可以选择感兴趣的部分阅读： Mixin设计模式 Mixin（混入）是一种通过扩展收集功能的方式，它本质上是将一个对象的属性拷贝到另一个对象上面去，不过你可以拷贝任意多个对象的任意个方法到一个新对象上去，这是继承所不能实现的。它的出现主要就是为了解决代码复用问题。 很多开源库提供了Mixin的实现，如Underscore的_.extend方法、JQuery的extend方法。 使用_.extend方法实现代码复用： var LogMixin = &#123; actionLog: function() &#123; console.log('action...'); &#125;, requestLog: function() &#123; console.log('request...'); &#125;,&#125;;function User() &#123; /*..*/ &#125;function Goods() &#123; /*..*/ &#125;_.extend(User.prototype, LogMixin);_.extend(Goods.prototype, LogMixin);var user = new User();var good = new Goods();user.actionLog();good.requestLog(); 我们可以尝试手动写一个简单的Mixin方法： function setMixin(target, mixin) &#123; if (arguments[2]) &#123; for (var i = 2, len = arguments.length; i &lt; len; i++) &#123; target.prototype[arguments[i]] = mixin.prototype[arguments[i]]; &#125; &#125; else &#123; for (var methodName in mixin.prototype) &#123; if (!Object.hasOwnProperty(target.prototype, methodName)) &#123; target.prototype[methodName] = mixin.prototype[methodName]; &#125; &#125; &#125;&#125;setMixin(User,LogMixin,'actionLog');setMixin(Goods,LogMixin,'requestLog'); 您可以使用setMixin\b方法将任意对象的任意方法扩展到目标对象上。 React中应用MixinReact也提供了Mixin的实现，如果完全不同的组件有相似的功能，我们可以引入来实现代码复用，当然只有在使用createClass来创建React组件时才可以使用，因为在React组件的es6写法中它已经被废弃掉了。 例如下面的例子，很多组件或页面都需要记录用户行为，性能指标等。如果我们在每个组件都引入写日志的逻辑，会产生大量重复代码，通过Mixin我们可以解决这一问题： var LogMixin = &#123; log: function() &#123; console.log('log'); &#125;, componentDidMount: function() &#123; console.log('in'); &#125;, componentWillUnmount: function() &#123; console.log('out'); &#125;&#125;;var User = React.createClass(&#123; mixins: [LogMixin], render: function() &#123; return (&lt;div&gt;...&lt;/div&gt;) &#125;&#125;);var Goods = React.createClass(&#123; mixins: [LogMixin], render: function() &#123; return (&lt;div&gt;...&lt;/div&gt;) &#125;&#125;); Mixin带来的危害React官方文档在Mixins Considered Harmful一文中提到了Mixin带来了危害： Mixin 可能会相互依赖，相互耦合，不利于代码维护 不同的Mixin中的方法可能会相互冲突 Mixin非常多时，组件是可以感知到的，甚至还要为其做相关处理，这样会给代码造成滚雪球式的复杂性 React现在已经不再推荐使用Mixin来解决代码复用问题，因为Mixin带来的危害比他产生的价值还要巨大，并且React全面推荐使用高阶组件来替代它。另外，高阶组件还能实现更多其他更强大的功能，在学习高阶组件之前，我们先来看一个设计模式。 装饰模式 装饰者(decorator)模式能够在不改变对象自身的基础上，在程序运行期间给对像动态的添加职责。与继承相比，装饰者是一种更轻便灵活的做法。 高阶组件（HOC） 高阶组件可以看作React对装饰模式的一种实现，高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。 高阶组件（HOC）是React中的高级技术，用来重用组件逻辑。但高阶组件本身并不是React API。它只是一种模式，这种模式是由React自身的组合性质必然产生的。 function visible(WrappedComponent) &#123; return class extends Component &#123; render() &#123; const &#123; visible, ...props &#125; = this.props; if (visible === false) return null; return &lt;WrappedComponent &#123;...props&#125; /&gt;; &#125; &#125;&#125; 上面的代码就是一个HOC的简单应用，函数接收一个组件作为参数，并返回一个新组件，新组建可以接收一个visible props，根据visible的值来判断是否渲染Visible。 下面我们从以下几方面来具体探索HOC。 HOC的实现方式属性代理函数返回一个我们自己定义的组件，然后在render中返回要包裹的组件，这样我们就可以代理所有传入的props，并且决定如何渲染，实际上 ，这种方式生成的高阶组件就是原组件的父组件，上面的函数visible就是一个HOC属性代理的实现方式。 function proxyHOC(WrappedComponent) &#123; return class extends Component &#123; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; /&gt;; &#125; &#125;&#125; 对比原生组件增强的项： 可操作所有传入的props 可操作组件的生命周期 可操作组件的static方法 获取refs 反向继承返回一个组件，继承原组件，在render中调用原组件的render。由于继承了原组件，能通过this访问到原组件的生命周期、props、state、render等，相比属性代理它能操作更多的属性。 function inheritHOC(WrappedComponent) &#123; return class extends WrappedComponent &#123; render() &#123; return super.render(); &#125; &#125;&#125; 对比原生组件增强的项： 可操作所有传入的props 可操作组件的生命周期 可操作组件的static方法 获取refs 可操作state 可以渲染劫持 HOC可以实现什么功能组合渲染可使用任何其他组件和原组件进行组合渲染，达到样式、布局复用等效果。 通过属性代理实现 function stylHOC(WrappedComponent) &#123; return class extends Component &#123; render() &#123; return (&lt;div&gt; &lt;div className=\"title\"&gt;&#123;this.props.title&#125;&lt;/div&gt; &lt;WrappedComponent &#123;...this.props&#125; /&gt; &lt;/div&gt;); &#125; &#125;&#125; 通过反向继承实现 function styleHOC(WrappedComponent) &#123; return class extends WrappedComponent &#123; render() &#123; return &lt;div&gt; &lt;div className=\"title\"&gt;&#123;this.props.title&#125;&lt;/div&gt; &#123;super.render()&#125; &lt;/div&gt; &#125; &#125;&#125; 条件渲染根据特定的属性决定原组件是否渲染 通过属性代理实现 function visibleHOC(WrappedComponent) &#123; return class extends Component &#123; render() &#123; if (this.props.visible === false) return null; return &lt;WrappedComponent &#123;...props&#125; /&gt;; &#125; &#125;&#125; 通过反向继承实现 function visibleHOC(WrappedComponent) &#123; return class extends WrappedComponent &#123; render() &#123; if (this.props.visible === false) &#123; return null &#125; else &#123; return super.render() &#125; &#125; &#125;&#125; 操作props可以对传入组件的props进行增加、修改、删除或者根据特定的props进行特殊的操作。 通过属性代理实现 function proxyHOC(WrappedComponent) &#123; return class extends Component &#123; render() &#123; const newProps = &#123; ...this.props, user: 'ConardLi' &#125; return &lt;WrappedComponent &#123;...newProps&#125; /&gt;; &#125; &#125;&#125; 获取refs高阶组件中可获取原组件的ref，通过ref获取组件实力，如下面的代码，当程序初始化完成后调用原组件的log方法。(不知道refs怎么用，请👇Refs &amp; DOM) 通过属性代理实现 function refHOC(WrappedComponent) &#123; return class extends Component &#123; componentDidMount() &#123; this.wapperRef.log() &#125; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; ref=&#123;ref =&gt; &#123; this.wapperRef = ref &#125;&#125; /&gt;; &#125; &#125;&#125; 这里注意：调用高阶组件的时候并不能获取到原组件的真实ref，需要手动进行传递，具体请看传递refs 状态管理将原组件的状态提取到HOC中进行管理，如下面的代码，我们将Input的value提取到HOC中进行管理，使它变成受控组件，同时不影响它使用onChange方法进行一些其他操作。基于这种方式，我们可以实现一个简单的双向绑定，具体请看双向绑定。 通过属性代理实现 function proxyHoc(WrappedComponent) &#123; return class extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: '' &#125;; &#125; onChange = (event) =&gt; &#123; const &#123; onChange &#125; = this.props; this.setState(&#123; value: event.target.value, &#125;, () =&gt; &#123; if(typeof onChange ==='function')&#123; onChange(event); &#125; &#125;) &#125; render() &#123; const newProps = &#123; value: this.state.value, onChange: this.onChange, &#125; return &lt;WrappedComponent &#123;...this.props&#125; &#123;...newProps&#125; /&gt;; &#125; &#125;&#125;class HOC extends Component &#123; render() &#123; return &lt;input &#123;...this.props&#125;&gt;&lt;/input&gt; &#125;&#125;export default proxyHoc(HOC); 操作state上面的例子通过属性代理利用HOC的state对原组件进行了一定的增强，但并不能直接控制原组件的state，而通过反向继承，我们可以直接操作原组件的state。但是并不推荐直接修改或添加原组件的state，因为这样有可能和组件内部的操作构成冲突。 通过反向继承实现 function debugHOC(WrappedComponent) &#123; return class extends WrappedComponent &#123; render() &#123; console.log('props', this.props); console.log('state', this.state); return ( &lt;div className=\"debuging\"&gt; &#123;super.render()&#125; &lt;/div&gt; ) &#125; &#125;&#125; 上面的HOC在render中将props和state打印出来，可以用作调试阶段，当然你可以在里面写更多的调试代码。想象一下，只需要在我们想要调试的组件上加上@debug就可以对该组件进行调试，而不需要在每次调试的时候写很多冗余代码。(如果你还不知道怎么使用HOC，请👇如何使用HOC) 渲染劫持高阶组件可以在render函数中做非常多的操作，从而控制原组件的渲染输出。只要改变了原组件的渲染，我们都将它称之为一种渲染劫持。 实际上，上面的组合渲染和条件渲染都是渲染劫持的一种，通过反向继承，不仅可以实现以上两点，还可直接增强由原组件render函数产生的React元素。 通过反向继承实现 function hijackHOC(WrappedComponent) &#123; return class extends WrappedComponent &#123; render() &#123; const tree = super.render(); let newProps = &#123;&#125;; if (tree &amp;&amp; tree.type === 'input') &#123; newProps = &#123; value: '渲染被劫持了' &#125;; &#125; const props = Object.assign(&#123;&#125;, tree.props, newProps); const newTree = React.cloneElement(tree, props, tree.props.children); return newTree; &#125; &#125;&#125; 注意上面的说明我用的是增强而不是更改。render函数内实际上是调用React.creatElement产生的React元素： 虽然我们能拿到它，但是我们不能直接修改它里面的属性，我们通过getOwnPropertyDescriptors函数来打印下它的配置项： 可以发现，所有的writable属性均被配置为了false，即所有属性是不可变的。（对这些配置项有疑问，请👇defineProperty） 不能直接修改，我们可以借助cloneElement方法来在原组件的基础上增强一个新组件： React.cloneElement()克隆并返回一个新的React元素，使用element作为起点。生成的元素将会拥有原始元素props与新props的浅合并。新的子级会替换现有的子级。来自原始元素的 key 和 ref 将会保留。 React.cloneElement()几乎相当于： &lt;element.type &#123;...element.props&#125; &#123;...props&#125;&gt;&#123;children&#125;&lt;/element.type&gt; 如何使用HOC上面的示例代码都写的是如何声明一个HOC，HOC实际上是一个函数，所以我们将要增强的组件作为参数调用HOC函数，得到增强后的组件。 class myComponent extends Component &#123; render() &#123; return (&lt;span&gt;原组件&lt;/span&gt;) &#125;&#125;export default inheritHOC(myComponent); compose在实际应用中，一个组件可能被多个HOC增强，我们使用的是被所有的HOC增强后的组件，借用一张装饰模式的图来说明，可能更容易理解： 假设现在我们有logger，visible，style等多个HOC，现在要同时增强一个Input组件： logger(visible(style(Input))) 这种代码非常的难以阅读，我们可以手动封装一个简单的函数组合工具，将写法改写如下： const compose = (...fns) =&gt; fns.reduce((f, g) =&gt; (...args) =&gt; g(f(...args)));compose(logger,visible,style)(Input); compose函数返回一个所有函数组合后的函数，compose(f, g, h) 和 (...args) =&gt; f(g(h(...args)))是一样的。 很多第三方库都提供了类似compose的函数，例如lodash.flowRight，Redux提供的combineReducers函数等。 Decorators我们还可以借助ES7为我们提供的Decorators来让我们的写法变的更加优雅： @logger@visible@styleclass Input extends Component &#123; // ...&#125; Decorators是ES7的一个提案，还没有被标准化，但目前Babel转码器已经支持，我们需要提前配置babel-plugin-transform-decorators-legacy： \"plugins\": [\"transform-decorators-legacy\"] 还可以结合上面的compose函数使用： const hoc = compose(logger, visible, style);@hocclass Input extends Component &#123; // ...&#125; HOC的实际应用下面是一些我在公司项目中实际对HOC的实际应用场景，由于文章篇幅原因，代码经过很多简化，如有问题欢迎在评论区指出： 日志打点实际上这属于一类最常见的应用，多个组件拥有类似的逻辑，我们要对重复的逻辑进行复用，官方文档中CommentList的示例也是解决了代码复用问题，写的很详细，有兴趣可以👇使用高阶组件（HOC）解决横切关注点。 某些页面需要记录用户行为，性能指标等等，通过高阶组件做这些事情可以省去很多重复代码。 function logHoc(WrappedComponent) &#123; return class extends Component &#123; componentWillMount() &#123; this.start = Date.now(); &#125; componentDidMount() &#123; this.end = Date.now(); console.log(`$&#123;WrappedComponent.dispalyName&#125; 渲染时间：$&#123;this.end - this.start&#125; ms`); console.log(`$&#123;user&#125;进入$&#123;WrappedComponent.dispalyName&#125;`); &#125; componentWillUnmount() &#123; console.log(`$&#123;user&#125;退出$&#123;WrappedComponent.dispalyName&#125;`); &#125; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; /&gt; &#125; &#125;&#125; 可用、权限控制function auth(WrappedComponent) &#123; return class extends Component &#123; render() &#123; const &#123; visible, auth, display = null, ...props &#125; = this.props; if (visible === false || (auth &amp;&amp; authList.indexOf(auth) === -1)) &#123; return display &#125; return &lt;WrappedComponent &#123;...props&#125; /&gt;; &#125; &#125;&#125; authList是我们在进入程序时向后端请求的所有权限列表，当组件所需要的权限不列表中，或者设置的visible是false，我们将其显示为传入的组件样式，或者null。我们可以将任何需要进行权限校验的组件应用HOC： @authclass Input extends Component &#123; ... &#125;@authclass Button extends Component &#123; ... &#125;&lt;Button auth=\"user/addUser\"&gt;添加用户&lt;/Button&gt;&lt;Input auth=\"user/search\" visible=&#123;false&#125; &gt;添加用户&lt;/Input&gt; 双向绑定在vue中，绑定一个变量后可实现双向数据绑定，即表单中的值改变后绑定的变量也会自动改变。而React中没有做这样的处理，在默认情况下，表单元素都是非受控组件。给表单元素绑定一个状态后，往往需要手动书写onChange方法来将其改写为受控组件，在表单元素非常多的情况下这些重复操作是非常痛苦的。 我们可以借助高阶组件来实现一个简单的双向绑定，代码略长，可以结合下面的思维导图进行理解。 首先我们自定义一个Form组件，该组件用于包裹所有需要包裹的表单组件，通过contex向子组件暴露两个属性： model：当前Form管控的所有数据，由表单name和value组成，如{name:&#39;ConardLi&#39;,pwd:&#39;123&#39;}。model可由外部传入，也可自行管控。 changeModel：改变model中某个name的值。 class Form extends Component &#123; static childContextTypes = &#123; model: PropTypes.object, changeModel: PropTypes.func &#125; constructor(props, context) &#123; super(props, context); this.state = &#123; model: props.model || &#123;&#125; &#125;; &#125; componentWillReceiveProps(nextProps) &#123; if (nextProps.model) &#123; this.setState(&#123; model: nextProps.model &#125;) &#125; &#125; changeModel = (name, value) =&gt; &#123; this.setState(&#123; model: &#123; ...this.state.model, [name]: value &#125; &#125;) &#125; getChildContext() &#123; return &#123; changeModel: this.changeModel, model: this.props.model || this.state.model &#125;; &#125; onSubmit = () =&gt; &#123; console.log(this.state.model); &#125; render() &#123; return &lt;div&gt; &#123;this.props.children&#125; &lt;button onClick=&#123;this.onSubmit&#125;&gt;提交&lt;/button&gt; &lt;/div&gt; &#125;&#125; 下面定义用于双向绑定的HOC，其代理了表单的onChange属性和value属性： 发生onChange事件时调用上层Form的changeModel方法来改变context中的model。 在渲染时将value改为从context中取出的值。 function proxyHoc(WrappedComponent) &#123; return class extends Component &#123; static contextTypes = &#123; model: PropTypes.object, changeModel: PropTypes.func &#125; onChange = (event) =&gt; &#123; const &#123; changeModel &#125; = this.context; const &#123; onChange &#125; = this.props; const &#123; v_model &#125; = this.props; changeModel(v_model, event.target.value); if(typeof onChange === 'function')&#123;onChange(event);&#125; &#125; render() &#123; const &#123; model &#125; = this.context; const &#123; v_model &#125; = this.props; return &lt;WrappedComponent &#123;...this.props&#125; value=&#123;model[v_model]&#125; onChange=&#123;this.onChange&#125; /&gt;; &#125; &#125;&#125;@proxyHocclass Input extends Component &#123; render() &#123; return &lt;input &#123;...this.props&#125;&gt;&lt;/input&gt; &#125;&#125; 上面的代码只是简略的一部分，除了input，我们还可以将HOC应用在select等其他表单组件，甚至还可以将上面的HOC兼容到span、table等展示组件，这样做可以大大简化代码，让我们省去了很多状态管理的工作，使用如下： export default class extends Component &#123; render() &#123; return ( &lt;Form &gt; &lt;Input v_model=\"name\"&gt;&lt;/Input&gt; &lt;Input v_model=\"pwd\"&gt;&lt;/Input&gt; &lt;/Form&gt; ) &#125;&#125; 表单校验基于上面的双向绑定的例子，我们再来一个表单验证器，表单验证器可以包含验证函数以及提示信息，当验证不通过时，展示错误信息： function validateHoc(WrappedComponent) &#123; return class extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; error: '' &#125; &#125; onChange = (event) =&gt; &#123; const &#123; validator &#125; = this.props; if (validator &amp;&amp; typeof validator.func === 'function') &#123; if (!validator.func(event.target.value)) &#123; this.setState(&#123; error: validator.msg &#125;) &#125; else &#123; this.setState(&#123; error: '' &#125;) &#125; &#125; &#125; render() &#123; return &lt;div&gt; &lt;WrappedComponent onChange=&#123;this.onChange&#125; &#123;...this.props&#125; /&gt; &lt;div&gt;&#123;this.state.error || ''&#125;&lt;/div&gt; &lt;/div&gt; &#125; &#125;&#125; const validatorName = &#123; func: (val) =&gt; val &amp;&amp; !isNaN(val), msg: '请输入数字'&#125;const validatorPwd = &#123; func: (val) =&gt; val &amp;&amp; val.length &gt; 6, msg: '密码必须大于6位'&#125;&lt;HOCInput validator=&#123;validatorName&#125; v_model=\"name\"&gt;&lt;/HOCInput&gt;&lt;HOCInput validator=&#123;validatorPwd&#125; v_model=\"pwd\"&gt;&lt;/HOCInput&gt; 当然，还可以在Form提交的时候判断所有验证器是否通过，验证器也可以设置为数组等等，由于文章篇幅原因，代码被简化了很多，有兴趣的同学可以自己实现。 Redux的connect redux中的connect，其实就是一个HOC，下面就是一个简化版的connect实现： export const connect = (mapStateToProps, mapDispatchToProps) =&gt; (WrappedComponent) =&gt; &#123; class Connect extends Component &#123; static contextTypes = &#123; store: PropTypes.object &#125; constructor () &#123; super() this.state = &#123; allProps: &#123;&#125; &#125; &#125; componentWillMount () &#123; const &#123; store &#125; = this.context this._updateProps() store.subscribe(() =&gt; this._updateProps()) &#125; _updateProps () &#123; const &#123; store &#125; = this.context let stateProps = mapStateToProps ? mapStateToProps(store.getState(), this.props): &#123;&#125; let dispatchProps = mapDispatchToProps? mapDispatchToProps(store.dispatch, this.props) : &#123;&#125; this.setState(&#123; allProps: &#123; ...stateProps, ...dispatchProps, ...this.props &#125; &#125;) &#125; render () &#123; return &lt;WrappedComponent &#123;...this.state.allProps&#125; /&gt; &#125; &#125; return Connect&#125; 代码非常清晰，connect函数其实就做了一件事，将mapStateToProps和mapDispatchToProps分别解构后传给原组件，这样我们在原组件内就可以直接用props获取state以及dispatch函数了。 使用HOC的注意事项告诫—静态属性拷贝当我们应用HOC去增强另一个组件时，我们实际使用的组件已经不是原组件了，所以我们拿不到原组件的任何静态属性，我们可以在HOC的结尾手动拷贝他们： function proxyHOC(WrappedComponent) &#123; class HOCComponent extends Component &#123; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; /&gt;; &#125; &#125; HOCComponent.staticMethod = WrappedComponent.staticMethod; // ... return HOCComponent;&#125; 如果原组件有非常多的静态属性，这个过程是非常痛苦的，而且你需要去了解需要增强的所有组件的静态属性是什么，我们可以使用hoist-non-react-statics来帮助我们解决这个问题，它可以自动帮我们拷贝所有非React的静态方法，使用方式如下： import hoistNonReactStatic from 'hoist-non-react-statics';function proxyHOC(WrappedComponent) &#123; class HOCComponent extends Component &#123; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; /&gt;; &#125; &#125; hoistNonReactStatic(HOCComponent,WrappedComponent); return HOCComponent;&#125; 告诫—传递refs使用高阶组件后，获取到的ref实际上是最外层的容器组件，而非原组件，但是很多情况下我们需要用到原组件的ref。 高阶组件并不能像透传props那样将refs透传，我们可以用一个回调函数来完成ref的传递：function hoc(WrappedComponent) &#123; return class extends Component &#123; getWrappedRef = () =&gt; this.wrappedRef; render() &#123; return &lt;WrappedComponent ref=&#123;ref =&gt; &#123; this.wrappedRef = ref &#125;&#125; &#123;...this.props&#125; /&gt;; &#125; &#125;&#125;@hocclass Input extends Component &#123; render() &#123; return &lt;input&gt;&lt;/input&gt; &#125;&#125;class App extends Component &#123; render() &#123; return ( &lt;Input ref=&#123;ref =&gt; &#123; this.inpitRef = ref.getWrappedRef() &#125;&#125; &gt;&lt;/Input&gt; ); &#125;&#125; React 16.3版本提供了一个forwardRef API来帮助我们进行refs传递，这样我们在高阶组件上获取的ref就是原组件的ref了，而不需要再手动传递，如果你的React版本大于16.3，可以使用下面的方式: function hoc(WrappedComponent) &#123; class HOC extends Component &#123; render() &#123; const &#123; forwardedRef, ...props &#125; = this.props; return &lt;WrappedComponent ref=&#123;forwardedRef&#125; &#123;...props&#125; /&gt;; &#125; &#125; return React.forwardRef((props, ref) =&gt; &#123; return &lt;HOC forwardedRef=&#123;ref&#125; &#123;...props&#125; /&gt;; &#125;);&#125; 告诫—不要在render方法内使用高阶组件React Diff算法的原则是： 使用组件标识确定是卸载还是更新组件 如果组件的和前一次渲染时标识是相同的，递归更新子组件 如果标识不同卸载组件重新挂载新组件 每次调用高阶组件生成的都是是一个全新的组件，组件的唯一标识响应的也会改变，如果在render方法调用了高阶组件，这会导致组件每次都会被卸载后重新挂载。 约定-不要改变原始组件官方文档对高阶组件的说明： 高阶组件就是一个没有副作用的纯函数。 我们再来看看纯函数的定义： 如果函数的调用参数相同，则永远返回相同的结果。它不依赖于程序执行期间函数外部任何状态或数据的变化，必须只依赖于其输入参数。该函数不会产生任何可观察的副作用，例如网络请求，输入和输出设备或数据突变。 如果我们在高阶组件对原组件进行了修改，例如下面的代码： InputComponent.prototype.componentWillReceiveProps = function(nextProps) &#123; ... &#125; 这样就破坏了我们对高阶组件的约定，同时也改变了使用高阶组件的初衷：我们使用高阶组件是为了增强而非改变原组件。 约定-透传不相关的props使用高阶组件，我们可以代理所有的props，但往往特定的HOC只会用到其中的一个或几个props。我们需要把其他不相关的props透传给原组件，如下面的代码： function visible(WrappedComponent) &#123; return class extends Component &#123; render() &#123; const &#123; visible, ...props &#125; = this.props; if (visible === false) return null; return &lt;WrappedComponent &#123;...props&#125; /&gt;; &#125; &#125;&#125; 我们只使用visible属性来控制组件的显示可隐藏，把其他props透传下去。 约定-displayName在使用React Developer Tools进行调试时，如果我们使用了HOC，调试界面可能变得非常难以阅读，如下面的代码： @visibleclass Show extends Component &#123; render() &#123; return &lt;h1&gt;我是一个标签&lt;/h1&gt; &#125;&#125;@visibleclass Title extends Component &#123; render() &#123; return &lt;h1&gt;我是一个标题&lt;/h1&gt; &#125;&#125; 为了方便调试，我们可以手动为HOC指定一个displayName，官方推荐使用HOCName(WrappedComponentName)： static displayName = `Visible($&#123;WrappedComponent.displayName&#125;)` 这个约定帮助确保高阶组件最大程度的灵活性和可重用性。 使用HOC的动机回顾下上文提到的 Mixin 带来的风险： Mixin 可能会相互依赖，相互耦合，不利于代码维护 不同的Mixin中的方法可能会相互冲突 Mixin非常多时，组件是可以感知到的，甚至还要为其做相关处理，这样会给代码造成滚雪球式的复杂性 而HOC的出现可以解决这些问题： 高阶组件就是一个没有副作用的纯函数，各个高阶组件不会互相依赖耦合 高阶组件也有可能造成冲突，但我们可以在遵守约定的情况下避免这些行为 高阶组件并不关心数据使用的方式和原因，而被包裹的组件也不关心数据来自何处。高阶组件的增加不会为原组件增加负担 HOC的缺陷 HOC需要在原组件上进行包裹或者嵌套，如果大量使用HOC，将会产生非常多的嵌套，这让调试变得非常困难。 HOC可以劫持props，在不遵守约定的情况下也可能造成冲突。 Hooks Hooks是React v16.7.0-alpha中加入的新特性。它可以让你在class以外使用state和其他React特性。 使用Hooks，你可以在将含有state的逻辑从组件中抽象出来，这将可以让这些逻辑容易被测试。同时，Hooks可以帮助你在不重写组件结构的情况下复用这些逻辑。所以，它也可以作为一种实现状态逻辑复用的方案。 阅读下面的章节使用Hook的动机你可以发现，它可以同时解决Mixin和HOC带来的问题。 官方提供的HooksState Hook我们要使用class组件实现一个计数器功能，我们可能会这样写： export default class Count extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125; &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; &#123; this.setState(&#123; count: this.state.count + 1 &#125;) &#125;&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 通过useState，我们使用函数式组件也能实现这样的功能： export default function HookTest() &#123; const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1); setNumber(number + 1); &#125;&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; useState是一个钩子，他可以为函数式组件增加一些状态，并且提供改变这些状态的函数，同时它接收一个参数，这个参数作为状态的默认值。 Effect Hook Effect Hook 可以让你在函数组件中执行一些具有 side effect（副作用）的操作 参数 useEffect方法接收传入两个参数： 1.回调函数：在第组件一次render和之后的每次update后运行，React保证在DOM已经更新完成之后才会运行回调。 2.状态依赖(数组)：当配置了状态依赖项后，只有检测到配置的状态变化时，才会调用回调函数。 useEffect(() =&gt; &#123; // 只要组件render后就会执行&#125;);useEffect(() =&gt; &#123; // 只有count改变时才会执行&#125;,[count]); 回调返回值 useEffect的第一个参数可以返回一个函数，当页面渲染了下一次更新的结果后，执行下一次useEffect之前，会调用这个函数。这个函数常常用来对上一次调用useEffect进行清理。 export default function HookTest() &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; console.log('执行...', count); return () =&gt; &#123; console.log('清理...', count); &#125; &#125;, [count]); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1); setNumber(number + 1); &#125;&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; 执行上面的代码，并点击几次按钮，会得到下面的结果： 注意，如果加上浏览器渲染的情况，结果应该是这样的： 页面渲染...1执行... 1页面渲染...2清理... 1执行... 2页面渲染...3清理... 2执行... 3页面渲染...4清理... 3执行... 4 那么为什么在浏览器渲染完后，再执行清理的方法还能找到上次的state呢？原因很简单，我们在useEffect中返回的是一个函数，这形成了一个闭包，这能保证我们上一次执行函数存储的变量不被销毁和污染。 你可以尝试下面的代码可能更好理解 var flag = 1;var clean;function effect(flag) &#123; return function () &#123; console.log(flag); &#125;&#125;clean = effect(flag);flag = 2;clean();clean = effect(flag);flag = 3;clean();clean = effect(flag);// 执行结果effect... 1clean... 1effect... 2clean... 2effect... 3 模拟componentDidMount componentDidMount等价于useEffect的回调仅在页面初始化完成后执行一次，当useEffect的第二个参数传入一个空数组时可以实现这个效果。 function useDidMount(callback) &#123; useEffect(callback, []);&#125; 官方不推荐上面这种写法，因为这有可能导致一些错误。 模拟componentWillUnmount function useUnMount(callback) &#123; useEffect(() =&gt; callback, []);&#125; 不像 componentDidMount 或者 componentDidUpdate，useEffect 中使用的 effect 并不会阻滞浏览器渲染页面。这让你的 app 看起来更加流畅。 ref Hook使用useRef Hook，你可以轻松的获取到dom的ref。 export default function Input() &#123; const inputEl = useRef(null); const onButtonClick = () =&gt; &#123; inputEl.current.focus(); &#125;; return ( &lt;div&gt; &lt;input ref=&#123;inputEl&#125; type=\"text\" /&gt; &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;/button&gt; &lt;/div&gt; );&#125; 注意useRef()并不仅仅可以用来当作获取ref使用，使用useRef产生的ref的current属性是可变的，这意味着你可以用它来保存一个任意值。 模拟componentDidUpdate componentDidUpdate就相当于除去第一次调用的useEffect，我们可以借助useRef生成一个标识，来记录是否为第一次执行： function useDidUpdate(callback, prop) &#123; const init = useRef(true); useEffect(() =&gt; &#123; if (init.current) &#123; init.current = false; &#125; else &#123; return callback(); &#125; &#125;, prop);&#125; 使用Hook的注意事项使用范围 只能在React函数式组件或自定义Hook中使用Hook。 Hook的提出主要就是为了解决class组件的一系列问题，所以我们能在class组件中使用它。 声明约束 不要在循环，条件或嵌套函数中调用Hook。 Hook通过数组实现的，每次useState 都会改变下标，React需要利用调用顺序来正确更新相应的状态，如果useState 被包裹循环或条件语句中，那每就可能会引起调用顺序的错乱，从而造成意想不到的错误。 我们可以安装一个eslint插件来帮助我们避免这些问题。// 安装npm install eslint-plugin-react-hooks --save-dev// 配置&#123; \"plugins\": [ // ... \"react-hooks\" ], \"rules\": &#123; // ... \"react-hooks/rules-of-hooks\": \"error\" &#125;&#125; 自定义Hook像上面介绍的HOC和mixin一样，我们同样可以通过自定义的Hook将组件中类似的状态逻辑抽取出来。 自定义Hook非常简单，我们只需要定义一个函数，并且把相应需要的状态和effect封装进去，同时，Hook之间也是可以相互引用的。使用use开头命名自定义Hook，这样可以方便eslint进行检查。 下面我们看几个具体的Hook封装： 日志打点我们可以使用上面封装的生命周期Hook。 const useLogger = (componentName, ...params) =&gt; &#123; useDidMount(() =&gt; &#123; console.log(`$&#123;componentName&#125;初始化`, ...params); &#125;); useUnMount(() =&gt; &#123; console.log(`$&#123;componentName&#125;卸载`, ...params); &#125;) useDidUpdate(() =&gt; &#123; console.log(`$&#123;componentName&#125;更新`, ...params); &#125;);&#125;;function Page1(props)&#123; useLogger('Page1',props); return (&lt;div&gt;...&lt;/div&gt;)&#125; 修改title根据不同的页面名称修改页面title: function useTitle(title) &#123; useEffect( () =&gt; &#123; document.title = title; return () =&gt; (document.title = \"主页\"); &#125;, [title] );&#125;function Page1(props)&#123; useTitle('Page1'); return (&lt;div&gt;...&lt;/div&gt;)&#125; 双向绑定我们将表单onChange的逻辑抽取出来封装成一个Hook，这样所有需要进行双向绑定的表单组件都可以进行复用：function useBind(init) &#123; let [value, setValue] = useState(init); let onChange = useCallback(function(event) &#123; setValue(event.currentTarget.value); &#125;, []); return &#123; value, onChange &#125;;&#125;function Page1(props)&#123; let value = useBind(''); return &lt;input &#123;...value&#125; /&gt;;&#125; 当然，你可以向上面的HOC那样，结合context和form来封装一个更通用的双向绑定，有兴趣可以手动实现一下。 使用Hook的动机减少状态逻辑复用的风险Hook和Mixin在用法上有一定的相似之处，但是Mixin引入的逻辑和状态是可以相互覆盖的，而多个Hook之间互不影响，这让我们不需要在把一部分精力放在防止避免逻辑复用的冲突上。 在不遵守约定的情况下使用HOC也有可能带来一定冲突，比如props覆盖等等，使用Hook则可以避免这些问题。 避免地狱式嵌套大量使用HOC的情况下让我们的代码变得嵌套层级非常深，使用HOC，我们可以实现扁平式的状态逻辑复用，而避免了大量的组件嵌套。 让组件更容易理解在使用class组件构建我们的程序时，他们各自拥有自己的状态，业务逻辑的复杂使这些组件变得越来越庞大，各个生命周期中会调用越来越多的逻辑，越来越难以维护。使用Hook，可以让你更大限度的将公用逻辑抽离，将一个组件分割成更小的函数，而不是强制基于生命周期方法进行分割。 使用函数代替class相比函数，编写一个class可能需要掌握更多的知识，需要注意的点也越多，比如this指向、绑定事件等等。另外，计算机理解一个class比理解一个函数更快。Hooks让你可以在classes之外使用更多React的新特性。 理性的选择实际上，Hook在react 16.8.0才正式发布Hook稳定版本，笔者也还未在生产环境下使用，目前笔者在生产环境下使用的最多的是HOC。 React官方完全没有把classes从React中移除的打算，class组件和Hook完全可以同时存在，官方也建议避免任何“大范围重构”，毕竟这是一个非常新的版本，如果你喜欢它，可以在新的非关键性的代码中使用Hook。 小结mixin已被抛弃，HOC正当壮年，Hook初露锋芒，前端圈就是这样，技术迭代速度非常之快，但我们在学习这些知识之时一定要明白为什么要学，学了有没有用，要不要用。不忘初心，方得始终。 文中如有错误，欢迎在评论区指正，谢谢阅读。","categories":[],"tags":[{"name":"React","slug":"React","permalink":"www.conardli.top/tags/React/"}]},{"title":"全面分析前端的网络请求方式","slug":"【浏览器和网络】全面分析前端的网络请求方式","date":"2019-03-28T12:38:59.000Z","updated":"2019-04-06T05:14:21.095Z","comments":true,"path":"2019/03/28/【浏览器和网络】全面分析前端的网络请求方式/","link":"","permalink":"www.conardli.top/2019/03/28/【浏览器和网络】全面分析前端的网络请求方式/","excerpt":"","text":"一、前端进行网络请求的关注点大多数情况下，在前端发起一个网络请求我们只需关注下面几点： 传入基本参数（url，请求方式） 请求参数、请求参数类型 设置请求头 获取响应的方式 获取响应头、响应状态、响应结果 异常处理 携带cookie设置 跨域请求 二、前端进行网络请求的方式 form表单、ifream、刷新页面 Ajax - 异步网络请求的开山鼻祖 jQuery - 一个时代 fetch - Ajax的替代者 axios、request等众多开源库 三、关于网络请求的疑问 Ajax的出现解决了什么问题 原生Ajax如何使用 jQuery的网络请求方式 fetch的用法以及坑点 如何正确的使用fetch 如何选择合适的跨域方式 带着以上这些问题、关注点我们对几种网络请求进行一次全面的分析。 四、Ajax的出现解决了什么问题在Ajax出现之前，web程序是这样工作的： 这种交互的的缺陷是显而易见的，任何和服务器的交互都需要刷新页面，用户体验非常差，Ajax的出现解决了这个问题。Ajax全称Asynchronous JavaScript + XML（异步JavaScript和XML） 使用Ajax，网页应用能够快速地将增量更新呈现在用户界面上，而不需要重载（刷新）整个页面。 Ajax本身不是一种新技术，而是用来描述一种使用现有技术集合实现的一个技术方案，浏览器的XMLHttpRequest是实现Ajax最重要的对象（IE6以下使用ActiveXObject）。 尽管X在Ajax中代表XML, 但由于JSON的许多优势，比如更加轻量以及作为Javascript的一部分，目前JSON的使用比XML更加普遍。 五、原生Ajax的用法这里主要分析XMLHttpRequest对象，下面是它的一段基础使用： var xhr = new XMLHttpRequest();xhr.open('post','www.xxx.com',true)// 接收返回值xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4 )&#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; console.log(xhr.responseText); &#125; &#125;&#125;// 处理请求参数postData = &#123;\"name1\":\"value1\",\"name2\":\"value2\"&#125;;postData = (function(value)&#123;var dataString = \"\";for(var key in value)&#123; dataString += key+\"=\"+value[key]+\"&amp;\";&#125;; return dataString;&#125;(postData));// 设置请求头xhr.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");// 异常处理xhr.onerror = function() &#123; console.log('Network request failed')&#125;// 跨域携带cookiexhr.withCredentials = true;// 发出请求xhr.send(postData); 下面分别对XMLHttpRequest对象常用的的函数、属性、事件进行分析。 函数open 用于初始化一个请求，用法： xhr.open(method, url, async); method：请求方式，如get、post url：请求的url async：是否为异步请求 send 用于发送HTTP请求，即调用该方法后HTTP请求才会被真正发出，用法： xhr.send(param) param：http请求的参数，可以为string、Blob等类型。 abort 用于终止一个ajax请求，调用此方法后readyState将被设置为0，用法： xhr.abort() setRequestHeader 用于设置HTTP请求头，此方法必须在open()方法和send()之间调用，用法： xhr.setRequestHeader(header, value); getResponseHeader 用于获取http返回头，如果在返回头中有多个一样的名称，那么返回的值就会是用逗号和空格将值分隔的字符串，用法： var header = xhr.getResponseHeader(name); 属性readyState 用来标识当前XMLHttpRequest对象所处的状态，XMLHttpRequest对象总是位于下列状态中的一个： 值 状态 描述 0 UNSENT 代理被创建，但尚未调用 open() 方法。 1 OPENED open() 方法已经被调用。 2 HEADERS_RECEIVED send()方法已经被调用，并且头部和状态已经可获得。 3 LOADING 下载中； responseText 属性已经包含部分数据。 4 DONE 下载操作已完成。 status 表示http请求的状态, 初始值为0。如果服务器没有显式地指定状态码, 那么status将被设置为默认值, 即200。 responseType 表示响应的数据类型，并允许我们手动设置，如果为空，默认为text类型，可以有下面的取值： 值 描述 &quot;&quot; 将 responseType设为空字符串与设置为&quot;text&quot;相同， 是默认类型 （实际上是 DOMString）。 &quot;arraybuffer&quot; response 是一个包含二进制数据的JavaScript ArrayBuffer 。 &quot;blob&quot; response是一个包含二进制数据的 Blob 对象 。 &quot;document&quot; response 是一个HTML Document或XML XMLDocument，这取决于接收到的数据的 MIME 类型。 &quot;json&quot; response 是一个 JavaScript 对象。这个对象是通过将接收到的数据类型视为JSON解析得到的。 &quot;text&quot; response是包含在DOMString对象中的文本。 response 返回响应的正文，返回的类型由上面的responseType决定。 withCredentials ajax请求默认会携带同源请求的cookie，而跨域请求则不会携带cookie，设置xhr的withCredentials的属性为true将允许携带跨域cookie。 事件回调onreadystatechange xhr.onreadystatechange = callback; 当readyState属性发生变化时，callback会被触发。 onloadstart xhr.onloadstart = callback; 在ajax请求发送之前（readyState==1后, readyState==2前），callback会被触发。 onprogress xhr.onprogress = function(event)&#123; console.log(event.loaded / event.total);&#125; 回调函数可以获取资源总大小total，已经加载的资源大小loaded，用这两个值可以计算加载进度。 onload xhr.onload = callback; 当一个资源及其依赖资源已完成加载时，将触发callback，通常我们会在onload事件中处理返回值。 异常处理onerror xhr.onerror = callback; 当ajax资源加载失败时会触发callback。 ontimeout xhr.ontimeout = callback; 当进度由于预定时间到期而终止时，会触发callback，超时时间可使用timeout属性进行设置。 六、jQuery对Ajax的封装在很长一段时间里，人们使用jQuery提供的ajax封装进行网络请求，包括$.ajax、$.get、$.post等，这几个方法放到现在，我依然觉得很实用。 $.ajax(&#123; dataType: 'json', // 设置返回值类型 contentType: 'application/json', // 设置参数类型 headers: &#123;'Content-Type','application/json'&#125;,// 设置请求头 xhrFields: &#123; withCredentials: true &#125;, // 跨域携带cookie data: JSON.stringify(&#123;a: [&#123;b:1, a:1&#125;]&#125;), // 传递参数 error:function(xhr,status)&#123; // 错误处理 console.log(xhr,status); &#125;, success: function (data,status) &#123; // 获取结果 console.log(data,status); &#125;&#125;) $.ajax只接收一个参数，这个参数接收一系列配置，其自己封装了一个jqXHR对象，有兴趣可以阅读一下jQuary-ajax 源码 常用配置： url 当前页地址。发送请求的地址。 type 类型：String 请求方式 (&quot;POST&quot; 或&quot;GET&quot;)， 默认为 &quot;GET&quot;。注意：其它HTTP请求方法，如PUT和 DELETE也可以使用，但仅部分浏览器支持。 timeout 类型：Number设置请求超时时间（毫秒）。此设置将覆盖全局设置。 success 类型：Function 请求成功后的回调函数。 jsonp 在一个jsonp请求中重写回调函数的名字。这个值用来替代在&quot;callback=?&quot;这种GET或POST请求中URL参数里的&quot;callback&quot;部分。 error 类型：Function 。请求失败时调用此函数。 注意：源码里对错误的判定： isSuccess = status &gt;= 200 &amp;&amp; status &lt; 300 || status === 304; 返回值除了这几个状态码都会进error回调。 dataType \"xml\": 返回 XML 文档，可用 jQuery 处理。\"html\": 返回纯文本 HTML 信息；包含的 script 标签会在插入 dom 时执行。\"script\": 返回纯文本 JavaScript 代码。不会自动缓存结果。除非设置了 \"cache\" 参数。注意：在远程请求时(不在同一个域下)，所有 POST 请求都将转为 GET 请求。（因为将使用 DOM 的 script标签来加载）\"json\": 返回 JSON 数据 。\"jsonp\": JSONP 格式。使用 JSONP 形式调用函数时，如 \"myurl?callback=?\" jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。\"text\": 返回纯文本字符串 data 类型：String 使用JSON.stringify转码 complete 类型：Function请求完成后回调函数 (请求成功或失败之后均调用)。 async 类型：Boolean 默认值:true。默认设置下，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为 false。 contentType 类型：String默认值: &quot;application/x-www-form-urlencoded&quot;。发送信息至服务器时内容编码类型。 键值对这样组织在一般的情况下是没有什么问题的，这里说的一般是，不带嵌套类型JSON，也就是 简单的JSON，形如这样： &#123; a: 1, b: 2, c: 3&#125; 但是在一些复杂的情况下就有问题了。 例如在 Ajax中你要传一个复杂的 json 对像，也就说是对象嵌数组，数组中包括对象，你这样传：application/x-www-form-urlencoded 这种形式是没有办法将复杂的JSON组织成键值对形式。 &#123; data: &#123; a: [&#123; x: 2 &#125;] &#125;&#125; 可以用如下方式传递复杂的json对象 $.ajax(&#123; dataType: 'json', contentType: 'application/json', data: JSON.stringify(&#123;a: [&#123;b:1, a:1&#125;]&#125;)&#125;) 七、jQuery的替代者近年来前端MV*的发展壮大，人们越来越少的使用jQuery，我们不可能单独为了使用jQuery的Ajax api来单独引入他，无可避免的，我们需要寻找新的技术方案。 尤雨溪在他的文档中推荐大家用axios进行网络请求。axios基于Promise对原生的XHR进行了非常全面的封装，使用方式也非常的优雅。另外，axios同样提供了在node环境下的支持，可谓是网络请求的首选方案。 未来必定还会出现更优秀的封装，他们有非常周全的考虑以及详细的文档，这里我们不多做考究，我们把关注的重点放在更底层的APIfetch。 Fetch API是一个用用于访问和操纵HTTP管道的强大的原生 API。 这种功能以前是使用 XMLHttpRequest实现的。Fetch提供了一个更好的替代方法，可以很容易地被其他技术使用，例如 Service Workers。Fetch还提供了单个逻辑位置来定义其他HTTP相关概念，例如CORS和HTTP的扩展。 可见fetch是作为XMLHttpRequest的替代品出现的。 使用fetch，你不需要再额外加载一个外部资源。但它还没有被浏览器完全支持，所以你仍然需要一个polyfill。 八、fetch的使用一个基本的 fetch请求： const options = &#123; method: \"POST\", // 请求参数 headers: &#123; \"Content-Type\": \"application/json\"&#125;, // 设置请求头 body: JSON.stringify(&#123;name:'123'&#125;), // 请求参数 credentials: \"same-origin\", // cookie设置 mode: \"cors\", // 跨域&#125;fetch('http://www.xxx.com') .then(function(response) &#123; return response.json(); &#125;) .then(function(myJson) &#123; console.log(myJson); // 响应数据 &#125;) .catch(function(err)&#123; console.log(err); // 异常处理 &#125;) Fetch API提供了一个全局的fetch()方法，以及几个辅助对象来发起一个网络请求。 fetch() fetch()方法用于发起获取资源的请求。它返回一个promise，这个 promise 会在请求响应后被 resolve，并传回 Response 对象。 Headers 可以通过Headers()构造函数来创建一个你自己的headers对象，相当于 response/request 的头信息，可以使你查询到这些头信息，或者针对不同的结果做不同的操作。var myHeaders = new Headers();myHeaders.append(\"Content-Type\", \"text/plain\"); Request 通过Request()构造函数可以创建一个Request对象，这个对象可以作为fetch函数的第二个参数。 Response 在fetch()处理完promises之后返回一个Response实例，也可以手动创建一个Response实例。 九、fetch polyfill源码分析由于fetch是一个非常底层的API，所以我们无法进一步的探究它的底层，但是我们可以借助它的polyfill探究它的基本原理，并找出其中的坑点。 代码结构 由代码可见，polyfill主要对Fetch API提供的四大对象进行了封装： fetch 封装 代码非常清晰： 构造一个Promise对象并返回 创建一个Request对象 创建一个XMLHttpRequest对象 取出Request对象中的请求url，请求方发，open一个xhr请求，并将Request对象中存储的headers取出赋给xhr xhr onload后取出response的status、headers、body封装Response对象，调用resolve。 异常处理 可以发现，调用reject有三种可能： 1.请求超时 2.请求失败 注意：当和服务器建立简介，并收到服务器的异常状态码如404、500等并不能触发onerror。当网络故障时或请求被阻止时，才会标记为 reject，如跨域、url不存在，网络异常等会触发onerror。 所以使用fetch当接收到异常状态码都是会进入then而不是catch。这些错误请求往往要手动处理。 3.手动终止 可以在request参数中传入signal对象，并对signal对象添加abort事件监听，当xhr.readyState变为4（响应内容解析完成）后将signal对象的abort事件监听移除掉。 这表示，在一个fetch请求结束之前可以调用signal.abort将其终止。在浏览器中可以使用AbortController()构造函数创建一个控制器，然后使用AbortController.signal属性 这是一个实验中的功能，此功能某些浏览器尚在开发中 Headers封装 在header对象中维护了一个map对象，构造函数中可以传入Header对象、数组、普通对象类型的header，并将所有的值维护到map中。 之前在fetch函数中看到调用了header的forEach方法，下面是它的实现： 可见header的遍历即其内部map的遍历。 另外Header还提供了append、delete、get、set等方法，都是对其内部的map对象进行操作。 Request对象 Request对象接收的两个参数即fetch函数接收的两个参数，第一个参数可以直接传递url，也可以传递一个构造好的request对象。第二个参数即控制不同配置的option对象。 可以传入credentials、headers、method、mode、signal、referrer等属性。 这里注意： 传入的headers被当作Headers构造函数的参数来构造header对象。 cookie处理fetch函数中还有如下的代码： if (request.credentials === 'include') &#123; xhr.withCredentials = true&#125; else if (request.credentials === 'omit') &#123; xhr.withCredentials = false&#125; 默认的credentials类型为same-origin,即可携带同源请求的coodkie。 然后我发现这里polyfill的实现和MDN-使用Fetch以及很多资料是不一致的： mdn: 默认情况下，fetch 不会从服务端发送或接收任何 cookies 于是我分别实验了下使用polyfill和使用原生fetch携带cookie的情况，发现在不设置credentials的情况下居然都是默认携带同源cookie的，这和文档的说明说不一致的，查阅了许多资料后都是说fetch默认不会携带cookie，下面是使用原生fetch在浏览器进行请求的情况： 然后我发现在MDN-Fetch-Request已经指出新版浏览器credentials默认值已更改为same-origin，旧版依然是omit。 确实MDN-使用Fetch这里的文档更新的有些不及时，误人子弟了… Response对象Response对象是fetch调用成功后的返回值： 回顾下fetch中对Response`的操作： xhr.onload = function () &#123; var options = &#123; status: xhr.status, statusText: xhr.statusText, headers: parseHeaders(xhr.getAllResponseHeaders() || '') &#125; options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL') var body = 'response' in xhr ? xhr.response : xhr.responseText resolve(new Response(body, options))&#125; Response构造函数： 可见在构造函数中主要对options中的status、statusText、headers、url等分别做了处理并挂载到Response对象上。 构造函数里面并没有对responseText的明确处理，最后交给了_initBody函数处理，而Response并没有主动声明_initBody属性，代码最后使用Response调用了Body函数，实际上_initBody函数是通过Body函数挂载到Response身上的，先来看看_initBody函数： 可见，_initBody函数根据xhr.response的类型（Blob、FormData、String...），为不同的参数进行赋值，这些参数在Body方法中得到不同的应用，下面具体看看Body函数还做了哪些其他的操作： Body函数中还为Response对象挂载了四个函数，text、json、blob、formData，这些函数中的操作就是将_initBody中得到的不同类型的返回值返回。 这也说明了，在fetch执行完毕后，不能直接在response中获取到返回值而必须调用text()、json()等函数才能获取到返回值。 这里还有一点需要说明：几个函数中都有类似下面的逻辑： var rejected = consumed(this)if (rejected) &#123; return rejected&#125; consumed函数：function consumed(body) &#123; if (body.bodyUsed) &#123; return Promise.reject(new TypeError('Already read')) &#125; body.bodyUsed = true&#125; 每次调用text()、json()等函数后会将bodyUsed变量变为true，用来标识返回值已经读取过了，下一次再读取直接抛出TypeError(&#39;Already read&#39;)。这也遵循了原生fetch的原则： 因为Responses对象被设置为了 stream 的方式，所以它们只能被读取一次 十、fetch的坑点VUE的文档中对fetch有下面的描述： 使用fetch还有很多别的注意事项，这也是为什么大家现阶段还是更喜欢axios 多一些。当然这个事情在未来可能会发生改变。 由于fetch是一个非常底层的API，它并没有被进行很多封装，还有许多问题需要处理： 不能直接传递JavaScript对象作为参数 需要自己判断返回值类型，并执行响应获取返回值的方法 获取返回值方法只能调用一次，不能多次调用 无法正常的捕获异常 老版浏览器不会默认携带cookie 不支持jsonp 十一、对fetch的封装请求参数处理支持传入不同的参数类型：function stringify(url, data) &#123; var dataString = url.indexOf('?') == -1 ? '?' : '&amp;'; for (var key in data) &#123; dataString += key + '=' + data[key] + '&amp;'; &#125;; return dataString;&#125;if (request.formData) &#123; request.body = request.data;&#125; else if (/^get$/i.test(request.method)) &#123; request.url = `$&#123;request.url&#125;$&#123;stringify(request.url, request.data)&#125;`;&#125; else if (request.form) &#123; request.headers.set('Content-Type', 'application/x-www-form-urlencoded;charset=UTF-8'); request.body = stringify(request.data);&#125; else &#123; request.headers.set('Content-Type', 'application/json;charset=UTF-8'); request.body = JSON.stringify(request.data);&#125; cookie携带fetch在新版浏览器已经开始默认携带同源cookie，但在老版浏览器中不会默认携带，我们需要对他进行统一设置： request.credentials = 'same-origin'; // 同源携带request.credentials = 'include'; // 可跨域携带 异常处理 当接收到一个代表错误的 HTTP 状态码时，从 fetch()返回的 Promise 不会被标记为 reject， 即使该 HTTP 响应的状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 ok 属性设置为 false ），仅当网络故障时或请求被阻止时，才会标记为 reject。 因此我们要对fetch的异常进行统一处理 .then(response =&gt; &#123; if (response.ok) &#123; return Promise.resolve(response); &#125;else&#123; const error = new Error(`请求失败! 状态码: $&#123;response.status&#125;, 失败信息: $&#123;response.statusText&#125;`); error.response = response; return Promise.reject(error); &#125;&#125;); 返回值处理对不同的返回值类型调用不同的函数接收，这里必须提前判断好类型，不能多次调用获取返回值的方法： .then(response =&gt; &#123; let contentType = response.headers.get('content-type'); if (contentType.includes('application/json')) &#123; return response.json(); &#125; else &#123; return response.text(); &#125;&#125;); jsonpfetch本身没有提供对jsonp的支持，jsonp本身也不属于一种非常好的解决跨域的方式，推荐使用cors或者nginx解决跨域，具体请看下面的章节。 fetch封装好了，可以愉快的使用了。 嗯，axios真好用… 十二、跨域总结谈到网络请求，就不得不提跨域。 浏览器的同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。通常不允许不同源间的读操作。 跨域条件：协议，域名，端口，有一个不同就算跨域。 下面是解决跨域的几种方式： nginx使用nginx反向代理实现跨域，参考我这篇文章：前端开发者必备的nginx知识 corsCORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求。 服务端设置Access-Control-Allow-Origin就可以开启CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。 app.all('*', function (req, res, next) &#123; res.header(\"Access-Control-Allow-Origin\", \"*\"); res.header(\"Access-Control-Allow-Headers\", \"X-Requested-With\"); res.header(\"Access-Control-Allow-Methods\", \"PUT,POST,GET,DELETE,OPTIONS\"); next();&#125;); jsonpscript标签的src属性中的链接可以访问跨域的js脚本，利用这个特性，服务端不再返回JSON格式的数据，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。 jquery对jsonp的支持： $.ajax(&#123; type : \"get\", url : \"http://xxxx\" dataType: \"jsonp\", jsonp:\"callback\", jsonpCallback: \"doo\", success : function(data) &#123; console.log(data); &#125;&#125;); fetch、axios等并没有直接提供对jsonp的支持，如果需要使用这种方式，我们可以尝试进行手动封装： (function (window,document) &#123; \"use strict\"; var jsonp = function (url,data,callback) &#123; // 1.将传入的data数据转化为url字符串形式 // &#123;id:1,name:'jack'&#125; =&gt; id=1&amp;name=jack var dataString = url.indexof('?') == -1? '?': '&amp;'; for(var key in data)&#123; dataString += key + '=' + data[key] + '&amp;'; &#125;; // 2 处理url中的回调函数 // cbFuncName回调函数的名字 ：my_json_cb_名字的前缀 + 随机数（把小数点去掉） var cbFuncName = 'my_json_cb_' + Math.random().toString().replace('.',''); dataString += 'callback=' + cbFuncName; // 3.创建一个script标签并插入到页面中 var scriptEle = document.createElement('script'); scriptEle.src = url + dataString; // 4.挂载回调函数 window[cbFuncName] = function (data) &#123; callback(data); // 处理完回调函数的数据之后，删除jsonp的script标签 document.body.removeChild(scriptEle); &#125; document.body.appendChild(scriptEle); &#125; window.$jsonp = jsonp;&#125;)(window,document) postMessage跨域postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。 //捕获iframevar domain = 'http://scriptandstyle.com';var iframe = document.getElementById('myIFrame').contentWindow;//发送消息setInterval(function()&#123; var message = 'Hello! The time is: ' + (new Date().getTime()); console.log('blog.local: sending message: ' + message); //send the message and target URI iframe.postMessage(message,domain); &#125;,6000); //响应事件window.addEventListener('message',function(event) &#123; if(event.origin !== 'http://davidwalsh.name') return; console.log('message received: ' + event.data,event); event.source.postMessage('holla back youngin!',event.origin);&#125;,false); postMessage跨域适用于以下场景：同浏览器多窗口间跨域通信、iframe间跨域通信。 WebSocketWebSocket 是一种双向通信协议，在建立连接之后，WebSocket的 server与 client都能主动向对方发送或接收数据而不受同源策略的限制。 function WebSocketTest()&#123; if (\"WebSocket\" in window)&#123; alert(\"您的浏览器支持 WebSocket!\"); // 打开一个 web socket var ws = new WebSocket(\"ws://localhost:3000/abcd\"); ws.onopen = function()&#123; // Web Socket 已连接上，使用 send() 方法发送数据 ws.send(\"发送数据\"); alert(\"数据发送中...\"); &#125;; ws.onmessage = function (evt) &#123; var received_msg = evt.data; alert(\"数据已接收...\"); &#125;; ws.onclose = function()&#123; // 关闭 websocket alert(\"连接已关闭...\"); &#125;; &#125; else&#123; // 浏览器不支持 WebSocket alert(\"您的浏览器不支持 WebSocket!\"); &#125;&#125; 文中如有错误，欢迎在评论区指正，谢谢阅读。","categories":[],"tags":[{"name":"浏览器和网络","slug":"浏览器和网络","permalink":"www.conardli.top/tags/浏览器和网络/"}]},{"title":"前端开发者必备的nginx知识","slug":"【前端工程】前端开发者必备的nginx知识","date":"2019-03-12T06:50:35.000Z","updated":"2019-04-06T05:25:56.565Z","comments":true,"path":"2019/03/12/【前端工程】前端开发者必备的nginx知识/","link":"","permalink":"www.conardli.top/2019/03/12/【前端工程】前端开发者必备的nginx知识/","excerpt":"","text":"nginx在应用程序中的作用 解决跨域 请求过滤 配置gzip 负载均衡 静态资源服务器 nginx是一个高性能的HTTP和反向代理服务器，也是一个通用的TCP/UDP代理服务器，最初由俄罗斯人Igor Sysoev编写。 nginx现在几乎是众多大型网站的必用技术，大多数情况下，我们不需要亲自去配置它，但是了解它在应用程序中所担任的角色，以及如何解决这些问题是非常必要的。 下面我将从nginx在企业中的真实应用来解释nginx在应用程序中起到的作用。 为了便于理解，首先先来了解一下一些基础知识，nginx是一个高性能的反向代理服务器那么什么是反向代理呢？ 正向代理与反向代理代理是在服务器和客户端之间假设的一层服务器，代理将接收客户端的请求并将它转发给服务器，然后将服务端的响应转发给客户端。 不管是正向代理还是反向代理，实现的都是上面的功能。 正向代理 正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。 正向代理是为我们服务的，即为客户端服务的，客户端可以根据正向代理访问到它本身无法访问到的服务器资源。 正向代理对我们是透明的，对服务端是非透明的，即服务端并不知道自己收到的是来自代理的访问还是来自真实客户端的访问。 反向代理 反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。 反向代理是为服务端服务的，反向代理可以帮助服务器接收来自客户端的请求，帮助服务器做请求转发，负载均衡等。 反向代理对服务端是透明的，对我们是非透明的，即我们并不知道自己访问的是代理服务器，而服务器知道反向代理在为他服务。 基本配置配置结构下面是一个nginx配置文件的基本结构： events &#123; &#125;http &#123; server &#123; location path &#123; ... &#125; location path &#123; ... &#125; &#125; server &#123; ... &#125;&#125; main:nginx的全局配置，对全局生效。 events:配置影响nginx服务器或与用户的网络连接。 http：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。 server：配置虚拟主机的相关参数，一个http中可以有多个server。 location：配置请求的路由，以及各种页面的处理情况。 upstream：配置后端服务器具体地址，负载均衡配置不可或缺的部分。 内置变量下面是nginx一些配置中常用的内置全局变量，你可以在配置的任何位置使用它们。 变量名 功能 $host 请求信息中的Host，如果请求中没有Host行，则等于设置的服务器名 $request_method 客户端请求类型，如GET、POST $remote_addr 客户端的IP地址 $args 请求中的参数 $content_length 请求头中的Content-length字段 $http_user_agent 客户端agent信息 $http_cookie 客户端cookie信息 $remote_addr 客户端的IP地址 $remote_port 客户端的端口 $server_protocol 请求使用的协议，如HTTP/1.0、·HTTP/1.1` $server_addr 服务器地址 $server_name 服务器名称 $server_port 服务器的端口号 解决跨域先追本溯源以下，跨域究竟是怎么回事。 跨域的定义同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。通常不允许不同源间的读操作。 同源的定义如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源。 nginx解决跨域的原理例如： 前端server的域名为：fe.server.com 后端服务的域名为：dev.server.com 现在我在fe.server.com对dev.server.com发起请求一定会出现跨域。 现在我们只需要启动一个nginx服务器，将server_name设置为fe.server.com,然后设置相应的location以拦截前端需要跨域的请求，最后将请求代理回dev.server.com。如下面的配置： server &#123; listen 80; server_name fe.server.com; location / &#123; proxy_pass dev.server.com; &#125;&#125; 这样可以完美绕过浏览器的同源策略：fe.server.com访问nginx的fe.server.com属于同源访问，而nginx对服务端转发的请求不会触发浏览器的同源策略。 请求过滤 根据状态码过滤error_page 500 501 502 503 504 506 /50x.html; location = /50x.html &#123; #将跟路径改编为存放html的路径。 root /root/static/html; &#125; 根据URL名称过滤，精准匹配URL，不匹配的URL全部重定向到主页。 location / &#123; rewrite ^.*$ /index.html redirect;&#125; 根据请求类型过滤。if ( $request_method !~ ^(GET|POST|HEAD)$ ) &#123; return 403; &#125; 配置gzip GZIP是规定的三种标准HTTP压缩格式之一。目前绝大多数的网站都在使用GZIP传输 HTML、CSS、JavaScript 等资源文件。 对于文本文件，GZip 的效果非常明显，开启后传输所需流量大约会降至 1/4 ~ 1/3。 并不是每个浏览器都支持gzip的，如何知道客户端是否支持gzip呢，请求头中的Accept-Encoding来标识对压缩的支持。 启用gzip同时需要客户端和服务端的支持，如果客户端支持gzip的解析，那么只要服务端能够返回gzip的文件就可以启用gzip了,我们可以通过nginx的配置来让服务端支持gzip。下面的respone中content-encoding:gzip，指服务端开启了gzip的压缩方式。 gzip on;gzip_http_version 1.1; gzip_comp_level 5;gzip_min_length 1000;gzip_types text/csv text/xml text/css text/plain text/javascript application/javascript application/x-javascript application/json application/xml; gzip 开启或者关闭gzip模块 默认值为off 可配置为on / off gzip_http_version 启用 GZip 所需的HTTP 最低版本 默认值为HTTP/1.1 这里为什么默认版本不是1.0呢？ HTTP 运行在TCP 连接之上，自然也有着跟TCP 一样的三次握手、慢启动等特性。 启用持久连接情况下，服务器发出响应后让TCP连接继续打开着。同一对客户/服务器之间的后续请求和响应可以通过这个连接发送。 为了尽可能的提高 HTTP 性能，使用持久连接就显得尤为重要了。 HTTP/1.1默认支持TCP持久连接，HTTP/1.0 也可以通过显式指定 Connection: keep-alive 来启用持久连接。对于TCP持久连接上的HTTP 报文，客户端需要一种机制来准确判断结束位置，而在 HTTP/1.0中，这种机制只有Content-Length。而在HTTP/1.1中新增的 Transfer-Encoding: chunked 所对应的分块传输机制可以完美解决这类问题。 nginx同样有着配置chunked的属性chunked_transfer_encoding，这个属性是默认开启的。 Nginx在启用了GZip的情况下，不会等文件 GZip 完成再返回响应，而是边压缩边响应，这样可以显著提高 TTFB(Time To First Byte，首字节时间，WEB 性能优化重要指标)。这样唯一的问题是，Nginx 开始返回响应时，它无法知道将要传输的文件最终有多大，也就是无法给出Content-Length这个响应头部。 所以，在HTTP1.0中如果利用Nginx启用了GZip，是无法获得Content-Length的，这导致HTTP1.0中开启持久链接和使用GZip只能二选一，所以在这里gzip_http_version默认设置为1.1。 gzip_comp_level 压缩级别，级别越高压缩率越大，当然压缩时间也就越长（传输快但比较消耗cpu）。 默认值为 1 压缩级别取值为1-9 gzip_min_length 设置允许压缩的页面最小字节数，Content-Length小于该值的请求将不会被压缩 默认值:0 当设置的值较小时，压缩后的长度可能比原文件大，建议设置1000以上 gzip_types 要采用gzip压缩的文件类型(MIME类型) 默认值:text/html(默认不压缩js/css) 负载均衡什么是负载均衡 如上面的图，前面是众多的服务窗口，下面有很多用户需要服务，我们需要一个工具或策略来帮助我们将如此多的用户分配到每个窗口，来达到资源的充分利用以及更少的排队时间。 把前面的服务窗口想像成我们的后端服务器，而后面终端的人则是无数个客户端正在发起请求。负载均衡就是用来帮助我们将众多的客户端请求合理的分配到各个服务器，以达到服务端资源的充分利用和更少的请求时间。 nginx如何实现负载均衡Upstream指定后端服务器地址列表 upstream balanceServer &#123; server 10.1.22.33:12345; server 10.1.22.34:12345; server 10.1.22.35:12345;&#125; 在server中拦截响应请求，并将请求转发到Upstream中配置的服务器列表。 server &#123; server_name fe.server.com; listen 80; location /api &#123; proxy_pass http://balanceServer; &#125;&#125; 上面的配置只是指定了nginx需要转发的服务端列表，并没有指定分配策略。 nginx实现负载均衡的策略 轮询策略 默认情况下采用的策略，将所有客户端请求轮询分配给服务端。这种策略是可以正常工作的，但是如果其中某一台服务器压力太大，出现延迟，会影响所有分配在这台服务器下的用户。 upstream balanceServer &#123; server 10.1.22.33:12345; server 10.1.22.34:12345; server 10.1.22.35:12345;&#125; 最小连接数策略 将请求优先分配给压力较小的服务器，它可以平衡每个队列的长度，并避免向压力大的服务器添加更多的请求。 upstream balanceServer &#123; least_conn; server 10.1.22.33:12345; server 10.1.22.34:12345; server 10.1.22.35:12345;&#125; 最快响应时间策略 依赖于NGINX Plus，优先分配给响应时间最短的服务器。 upstream balanceServer &#123; fair; server 10.1.22.33:12345; server 10.1.22.34:12345; server 10.1.22.35:12345;&#125; 客户端ip绑定 来自同一个ip的请求永远只分配一台服务器，有效解决了动态网页存在的session共享问题。upstream balanceServer &#123; ip_hash; server 10.1.22.33:12345; server 10.1.22.34:12345; server 10.1.22.35:12345;&#125; 静态资源服务器location ~* \\.(png|gif|jpg|jpeg)$ &#123; root /root/static/; autoindex on; access_log off; expires 10h;# 设置过期时间为10小时 &#125; 匹配以png|gif|jpg|jpeg为结尾的请求，并将请求转发到本地路径，root中指定的路径即nginx本地路径。同时也可以进行一些缓存的设置。 小结nginx的功能非常强大，还有很多需要探索，上面的一些配置都是公司配置的真实应用（精简过了），如果您有什么意见或者建议，欢迎在下方留言…","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"www.conardli.top/tags/nginx/"}]},{"title":"深入分析前端小数计算问题","slug":"【JavaScript】深入分析前端小数计算问题","date":"2019-03-06T08:22:51.000Z","updated":"2019-04-06T05:28:05.940Z","comments":true,"path":"2019/03/06/【JavaScript】深入分析前端小数计算问题/","link":"","permalink":"www.conardli.top/2019/03/06/【JavaScript】深入分析前端小数计算问题/","excerpt":"","text":"话不多说，先上代码function judgeFloat(n, m) &#123; const binaryN = n.toString(2); const binaryM = m.toString(2); console.log(`$&#123;n&#125;的二进制是 $&#123;binaryN&#125;`); console.log(`$&#123;m&#125;的二进制是 $&#123;binaryM&#125;`); const MN = m + n; const accuracyMN = (m * 100 + n * 100) / 100; const binaryMN = MN.toString(2); const accuracyBinaryMN = accuracyMN.toString(2); console.log(`$&#123;n&#125;+$&#123;m&#125;的二进制是$&#123;binaryMN&#125;`); console.log(`$&#123;accuracyMN&#125;的二进制是 $&#123;accuracyBinaryMN&#125;`); console.log(`$&#123;n&#125;+$&#123;m&#125;的二进制再转成十进制是$&#123;to10(binaryMN)&#125;`); console.log(`$&#123;accuracyMN&#125;的二进制是再转成十进制是$&#123;to10(accuracyBinaryMN)&#125;`); console.log(`$&#123;n&#125;+$&#123;m&#125;在js中计算是$&#123;(to10(binaryMN) === to10(accuracyBinaryMN)) ? '' : '不'&#125;准确的`);&#125;function to10(n) &#123; const pre = (n.split('.')[0] - 0).toString(2); const arr = n.split('.')[1].split(''); let i = 0; let result = 0; while (i &lt; arr.length) &#123; result += arr[i] * Math.pow(2, -(i + 1)); i++; &#125; return result;&#125;judgeFloat(0.1, 0.2);judgeFloat(0.6, 0.7); 由于JavaScript中没有将小数的二进制转换成十进制的方法，于是手动实现了一个。 先来一个简单的结论计算机中所有的数据都是以二进制存储的，所以在计算时计算机要把数据先转换成二进制进行计算，然后在把计算结果转换成十进制。 由上面的代码不难看出，在计算0.1+0.2时，二进制计算发生了精度丢失，导致再转换成十进制后和预计的结果不符。 其实有些标题党了，一个函数并不能让你深入理解，还得继续看下面… 对结果的分析—更多的问题0.1和0.2的二进制都是以1100无限循环的小数，下面逐个来看JS帮我们计算所得的结果： 0.1的二进制： 0.0001100110011001100110011001100110011001100110011001101 0.2的二进制：0.001100110011001100110011001100110011001100110011001101 理论上讲，由上面的结果相加应该：： 0.0100110011001100110011001100110011001100110011001100111 实际JS计算得到的0.1+0.2的二进制 0.0100110011001100110011001100110011001100110011001101 作为一个代码强迫症的我又产生的新的问题： Why js计算出的 0.1的二进制 是这么多位而不是更多位？？？ Why js计算的（0.1+0.2）的二进制和我们自己计算的（0.1+0.2）的二进制结果不一样呢？？？ Why 0.1的二进制 + 0.2的二进制 != 0.3的二进制？？？ js对二进制小数的存储方式小数的二进制大多数都是无限循环的，JavaScript是怎么来存储他们的呢？ 在ECMAScript®语言规范中可以看到，ECMAScript中的Number类型遵循IEEE 754标准。使用64位固定长度来表示。 事实上有很多语言的数字类型都遵循这个标准，例如JAVA,所以很多语言同样有着上面同样的问题。 所以下次遇到这种问题不要上来就喷JavaScript… 有兴趣可以看看下这个网站http://0.30000000000000004.com/，是的，你没看错，就是http://0.30000000000000004.com/！！！ IEEE 754IEEE754标准包含一组实数的二进制表示法。它有三部分组成： 符号位 指数位 尾数位 三种精度的浮点数各个部分位数如下： JavaScript使用的是64位双精度浮点数编码，所以它的符号位占1位，指数位占11位，尾数位占52位。 下面我们在理解下什么是符号位、指数位、尾数位，以0.1为例： 它的二进制为：0.0001100110011001100... 为了节省存储空间，在计算机中它是以科学计数法表示的，也就是 1.100110011001100... X 2-4 如果这里不好理解可以想一下十进制的数： 1100的科学计数法为11 X 102 所以： 符号位就是标识正负的，1表示负，0表示正； 指数位存储科学计数法的指数； 尾数位存储科学计数法后的有效数字； 所以我们通常看到的二进制，其实是计算机实际存储的尾数位。 js中的toString(2)由于尾数位只能存储52个数字，这就能解释toString(2)的执行结果了： 如果计算机没有存储空间的限制，那么0.1的二进制应该是：0.00011001100110011001100110011001100110011001100110011001... 科学计数法尾数位 1.1001100110011001100110011001100110011001100110011001... 但是由于限制，有效数字第53位及以后的数字是不能存储的，它遵循，如果是1就向前一位进1，如果是0就舍弃的原则。 0.1的二进制科学计数法第53位是1，所以就有了下面的结果： 0.0001100110011001100110011001100110011001100110011001101 0.2有着同样的问题，其实正是由于这样的存储，在这里有了精度丢失，导致了0.1+0.2!=0.3。 事实上有着同样精度问题的计算还有很多，我们无法把他们都记下来，所以当程序中有数字计算时，我们最好用工具库来帮助我们解决，下面是两个推荐使用的开源库： number-precision mathjs/ 下面我们再来看上面的其他两个问题。 Why JavaScript计算出的 0.1的二进制 是这么多位而不是更多位？？？上面的toString原理帮我们解答了这个问题，在有效数字第53位以后的数字将遵循1进0舍的原则，内存中只允许存储52位有效数字。 Why JavaScript计算的（0.1+0.2）的二进制和我们自己计算的（0.1+0.2）的二进制结果不一样呢？？？我们自己计算的0.1+0.2：： 0.0100110011001100110011001100110011001100110011001100111 实际上这个结果的有效数字已经超过了52位，我们要从末尾进行1进0舍得到下面的结果 0.0100110011001100110011001100110011001100110011001101 JavaScript能表示的最大数字由与IEEE 754双精度64位规范的限制： 指数位能表示的最大数字：1023(十进制) 尾数位能表达的最大数字即尾数位都位1的情况 所以JavaScript能表示的最大数字即位 1.111...X 21023 这个结果转换成十进制是1.7976931348623157e+308,这个结果即为Number.MAX_VALUE。 最大安全数字JavaScript中Number.MAX_SAFE_INTEGER表示最大安全数字,计算结果是9007199254740991，即在这个数范围内不会出现精度丢失（小数除外）,这个数实际上是1.111...X 252。 我们同样可以用一些开源库来处理大整数： node-bignum node-bigint 其实官方也考虑到了这个问题，bigInt类型在es10中被提出，现在Chrome中已经可以使用。 bigInt类型BigInt 是第七种原始类型。 BigInt 是一个任意精度的整数。这意味着变量现在可以计算9007199254740991即最大安全整数以上的数字。 const b = 1n; // 追加 n 以创建 BigInt 在过去，不支持大于 9007199254740992 的整数值。如果超过，该值将锁定为MAX_SAFE_INTEGER + 1: const limit = Number.MAX_SAFE_INTEGER;⇨ 9007199254740991limit + 1;⇨ 9007199254740992limit + 2;⇨ 9007199254740992 &lt;--- MAX_SAFE_INTEGER + 1 exceededconst larger = 9007199254740991n;⇨ 9007199254740991nconst integer = BigInt(9007199254740991); // initialize with number⇨ 9007199254740991nconst same = BigInt(&quot;9007199254740991&quot;); // initialize with &quot;string&quot;⇨ 9007199254740991n typeoftypeof 10;⇨ &apos;number&apos;typeof 10n;⇨ &apos;bigint&apos;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"www.conardli.top/tags/JavaScript/"}]},{"title":"【React深入】React事件机制","slug":"【React深入】React事件机制","date":"2019-03-06T08:19:35.000Z","updated":"2019-04-16T11:42:58.977Z","comments":true,"path":"2019/03/06/【React深入】React事件机制/","link":"","permalink":"www.conardli.top/2019/03/06/【React深入】React事件机制/","excerpt":"","text":"关于React事件的疑问 1.为什么要手动绑定this 2.React事件和原生事件有什么区别 3.React事件和原生事件的执行顺序，可以混用吗 4.React事件如何解决跨浏览器兼容 5.什么是合成事件 下面是我阅读过源码后，将所有的执行流程总结出来的流程图，不会贴代码，如果你想阅读代码看看具体是如何实现的，可以根据流程图去源码里寻找。 事件注册 组件装载 / 更新。 通过lastProps、nextProps判断是否新增、删除事件分别调用事件注册、卸载方法。 调用EventPluginHub的enqueuePutListener进行事件存储 获取document对象。 根据事件名称（如onClick、onCaptureClick）判断是进行冒泡还是捕获。 判断是否存在addEventListener方法，否则使用attachEvent（兼容IE）。 给document注册原生事件回调为dispatchEvent（统一的事件分发机制）。 事件存储 EventPluginHub负责管理React合成事件的callback，它将callback存储在listenerBank中，另外还存储了负责合成事件的Plugin。 EventPluginHub的putListener方法是向存储容器中增加一个listener。 获取绑定事件的元素的唯一标识key。 将callback根据事件类型，元素的唯一标识key存储在listenerBank中。 listenerBank的结构是：listenerBank[registrationName][key]。 例如： &#123; onClick:&#123; nodeid1:()=&gt;&#123;...&#125; nodeid2:()=&gt;&#123;...&#125; &#125;, onChange:&#123; nodeid3:()=&gt;&#123;...&#125; nodeid4:()=&gt;&#123;...&#125; &#125;&#125; 事件触发 / 执行 这里的事件执行利用了React的批处理机制，在前一篇的【React深入】setState执行机制中已经分析过，这里不再多加分析。 触发document注册原生事件的回调dispatchEvent 获取到触发这个事件最深一级的元素 例如下面的代码：首先会获取到this.child &lt;div onClick=&#123;this.parentClick&#125; ref=&#123;ref =&gt; this.parent = ref&#125;&gt; &lt;div onClick=&#123;this.childClick&#125; ref=&#123;ref =&gt; this.child = ref&#125;&gt; test &lt;/div&gt;&lt;/div&gt; 遍历这个元素的所有父元素，依次对每一级元素进行处理。 构造合成事件。 将每一级的合成事件存储在eventQueue事件队列中。 遍历eventQueue。 通过isPropagationStopped判断当前事件是否执行了阻止冒泡方法。 如果阻止了冒泡，停止遍历，否则通过executeDispatch执行合成事件。 释放处理完成的事件。 react在自己的合成事件中重写了stopPropagation方法，将isPropagationStopped设置为true，然后在遍历每一级事件的过程中根据此遍历判断是否继续执行。这就是react自己实现的冒泡机制。 合成事件 调用EventPluginHub的extractEvents方法。 循环所有类型的EventPlugin（用来处理不同事件的工具方法）。 在每个EventPlugin中根据不同的事件类型，返回不同的事件池。 在事件池中取出合成事件，如果事件池是空的，那么创建一个新的。 根据元素nodeid(唯一标识key)和事件类型从listenerBink中取出回调函数 返回带有合成事件参数的回调函数 总流程将上面的四个流程串联起来。 为什么要手动绑定this通过事件触发过程的分析，dispatchEvent调用了invokeGuardedCallback方法。 function invokeGuardedCallback(name, func, a) &#123; try &#123; func(a); &#125; catch (x) &#123; if (caughtError === null) &#123; caughtError = x; &#125; &#125;&#125; 可见，回调函数是直接调用调用的，并没有指定调用的组件，所以不进行手动绑定的情况下直接获取到的this是undefined。 这里可以使用实验性的属性初始化语法 ，也就是直接在组件声明箭头函数。箭头函数不会创建自己的this，它只会从自己的作用域链的上一层继承this。因此这样我们在React事件中获取到的就是组件本身了。 和原生事件有什么区别 React 事件使用驼峰命名，而不是全部小写。 通过 JSX , 你传递一个函数作为事件处理程序，而不是一个字符串。 例如，HTML：&lt;button onclick=\"activateLasers()\"&gt; Activate Lasers&lt;/button&gt; 在 React 中略有不同：&lt;button onClick=&#123;activateLasers&#125;&gt; Activate Lasers&lt;/button&gt; 另一个区别是，在 React 中你不能通过返回false 来阻止默认行为。必须明确调用 preventDefault。 由上面执行机制我们可以得出：React自己实现了一套事件机制，自己模拟了事件冒泡和捕获的过程，采用了事件代理，批量更新等方法，并且抹平了各个浏览器的兼容性问题。 React事件和原生事件的执行顺序componentDidMount() &#123; this.parent.addEventListener('click', (e) =&gt; &#123; console.log('dom parent'); &#125;) this.child.addEventListener('click', (e) =&gt; &#123; console.log('dom child'); &#125;) document.addEventListener('click', (e) =&gt; &#123; console.log('document'); &#125;)&#125;childClick = (e) =&gt; &#123; console.log('react child');&#125;parentClick = (e) =&gt; &#123; console.log('react parent');&#125;render() &#123; return ( &lt;div onClick=&#123;this.parentClick&#125; ref=&#123;ref =&gt; this.parent = ref&#125;&gt; &lt;div onClick=&#123;this.childClick&#125; ref=&#123;ref =&gt; this.child = ref&#125;&gt; test &lt;/div&gt; &lt;/div&gt;)&#125; 执行结果： 由上面的流程我们可以理解： react的所有事件都挂载在document中 当真实dom触发后冒泡到document后才会对react事件进行处理 所以原生的事件会先执行 然后执行react合成事件 最后执行真正在document上挂载的事件 react事件和原生事件可以混用吗？react事件和原生事件最好不要混用。 原生事件中如果执行了stopPropagation方法，则会导致其他react事件失效。因为所有元素的事件将无法冒泡到document上。 由上面的执行机制不难得出，所有的react事件都将无法被注册。 合成事件、浏览器兼容function handleClick(e) &#123; e.preventDefault(); console.log(&apos;The link was clicked.&apos;);&#125; 这里， e 是一个合成的事件。 React 根据 W3C 规范 定义了这个合成事件，所以你不需要担心跨浏览器的兼容性问题。 事件处理程序将传递 SyntheticEvent 的实例，这是一个跨浏览器原生事件包装器。 它具有与浏览器原生事件相同的接口，包括stopPropagation() 和 preventDefault() ，在所有浏览器中他们工作方式都相同。 每个SyntheticEvent对象都具有以下属性： boolean bubblesboolean cancelableDOMEventTarget currentTargetboolean defaultPreventednumber eventPhaseboolean isTrustedDOMEvent nativeEventvoid preventDefault()boolean isDefaultPrevented()void stopPropagation()boolean isPropagationStopped()DOMEventTarget targetnumber timeStampstring type React合成的SyntheticEvent采用了事件池，这样做可以大大节省内存，而不会频繁的创建和销毁事件对象。 另外，不管在什么浏览器环境下，浏览器会将该事件类型统一创建为合成事件，从而达到了浏览器兼容的目的。 推荐阅读【React深入】setState的执行机制","categories":[],"tags":[{"name":"React","slug":"React","permalink":"www.conardli.top/tags/React/"}]},{"title":"【React深入】setState的执行机制","slug":"【React深入】setState的执行机制","date":"2019-03-06T08:12:35.000Z","updated":"2019-04-06T05:27:16.846Z","comments":true,"path":"2019/03/06/【React深入】setState的执行机制/","link":"","permalink":"www.conardli.top/2019/03/06/【React深入】setState的执行机制/","excerpt":"","text":"一.几个开发中经常会遇到的问题以下几个问题是我们在实际开发中经常会遇到的场景，下面用几个简单的示例代码来还原一下。 1.setState是同步还是异步的，为什么有的时候不能立即拿到更新结果而有的时候可以?1.1 钩子函数和React合成事件中的setState现在有两个组件 componentDidMount() &#123; console.log('parent componentDidMount');&#125;render() &#123; return ( &lt;div&gt; &lt;SetState2&gt;&lt;/SetState2&gt; &lt;SetState&gt;&lt;/SetState&gt; &lt;/div&gt; );&#125; 组件内部放入同样的代码，并在Setstate1中的componentDidMount中放入一段同步延时代码，打印延时时间： componentWillUpdate() &#123; console.log('componentWillUpdate');&#125;componentDidUpdate() &#123; console.log('componentDidUpdate');&#125;componentDidMount() &#123; console.log('SetState调用setState'); this.setState(&#123; index: this.state.index + 1 &#125;) console.log('state', this.state.index); console.log('SetState调用setState'); this.setState(&#123; index: this.state.index + 1 &#125;) console.log('state', this.state.index);&#125; 下面是执行结果： 说明： 1.调用setState不会立即更新 2.所有组件使用的是同一套更新机制，当所有组件didmount后，父组件didmount，然后执行更新 3.更新时会把每个组件的更新合并，每个组件只会触发一次更新的生命周期。 1.2 异步函数和原生事件中的setstate？在setTimeout中调用setState（例子和在浏览器原生事件以及接口回调中执行效果相同）componentDidMount() &#123; setTimeout(() =&gt; &#123; console.log(&apos;调用setState&apos;); this.setState(&#123; index: this.state.index + 1 &#125;) console.log(&apos;state&apos;, this.state.index); console.log(&apos;调用setState&apos;); this.setState(&#123; index: this.state.index + 1 &#125;) console.log(&apos;state&apos;, this.state.index); &#125;, 0);&#125; 执行结果： 说明： 1.在父组件didmount后执行 2.调用setState同步更新 2.为什么有时连续两次setState只有一次生效？分别执行以下代码： componentDidMount() &#123; this.setState(&#123; index: this.state.index + 1 &#125;, () =&gt; &#123; console.log(this.state.index); &#125;) this.setState(&#123; index: this.state.index + 1 &#125;, () =&gt; &#123; console.log(this.state.index); &#125;)&#125; componentDidMount() &#123; this.setState((preState) =&gt; (&#123; index: preState.index + 1 &#125;), () =&gt; &#123; console.log(this.state.index); &#125;) this.setState(preState =&gt; (&#123; index: preState.index + 1 &#125;), () =&gt; &#123; console.log(this.state.index); &#125;)&#125; 执行结果： 11 22 说明： 1.直接传递对象的setstate会被合并成一次 2.使用函数传递state不会被合并 二.setState执行过程由于源码比较复杂，就不贴在这里了，有兴趣的可以去github上clone一份然后按照下面的流程图去走一遍。 1.流程图 partialState：setState传入的第一个参数，对象或函数 _pendingStateQueue：当前组件等待执行更新的state队列 isBatchingUpdates：react用于标识当前是否处于批量更新状态，所有组件公用 dirtyComponent：当前所有处于待更新状态的组件队列 transcation：react的事务机制，在被事务调用的方法外包装n个waper对象，并一次执行：waper.init、被调用方法、waper.close FLUSH_BATCHED_UPDATES：用于执行更新的waper，只有一个close方法 2.执行过程对照上面流程图的文字说明，大概可分为以下几步： 1.将setState传入的partialState参数存储在当前组件实例的state暂存队列中。 2.判断当前React是否处于批量更新状态，如果是，将当前组件加入待更新的组件队列中。 3.如果未处于批量更新状态，将批量更新状态标识设置为true，用事务再次调用前一步方法，保证当前组件加入到了待更新组件队列中。 4.调用事务的waper方法，遍历待更新组件队列依次执行更新。 5.执行生命周期componentWillReceiveProps。 6.将组件的state暂存队列中的state进行合并，获得最终要更新的state对象，并将队列置为空。 7.执行生命周期componentShouldUpdate，根据返回值判断是否要继续更新。 8.执行生命周期componentWillUpdate。 9.执行真正的更新，render。 10.执行生命周期componentDidUpdate。 三.总结1.钩子函数和合成事件中：在react的生命周期和合成事件中，react仍然处于他的更新机制中，这时isBranchUpdate为true。 按照上述过程，这时无论调用多少次setState，都会不会执行更新，而是将要更新的state存入_pendingStateQueue，将要更新的组件存入dirtyComponent。 当上一次更新机制执行完毕，以生命周期为例，所有组件，即最顶层组件didmount后会将isBranchUpdate设置为false。这时将执行之前累积的setState。 2.异步函数和原生事件中由执行机制看，setState本身并不是异步的，而是如果在调用setState时，如果react正处于更新过程，当前更新会被暂存，等上一次更新执行后在执行，这个过程给人一种异步的假象。 在生命周期，根据JS的异步机制，会将异步函数先暂存，等所有同步代码执行完毕后在执行，这时上一次更新过程已经执行完毕，isBranchUpdate被设置为false，根据上面的流程，这时再调用setState即可立即执行更新，拿到更新结果。 3.partialState合并机制我们看下流程中_processPendingState的代码，这个函数是用来合并state暂存队列的，最后返回一个合并后的state。 _processPendingState: function (props, context) &#123; var inst = this._instance; var queue = this._pendingStateQueue; var replace = this._pendingReplaceState; this._pendingReplaceState = false; this._pendingStateQueue = null; if (!queue) &#123; return inst.state; &#125; if (replace &amp;&amp; queue.length === 1) &#123; return queue[0]; &#125; var nextState = _assign(&#123;&#125;, replace ? queue[0] : inst.state); for (var i = replace ? 1 : 0; i &lt; queue.length; i++) &#123; var partial = queue[i]; _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial); &#125; return nextState;&#125;, 我们只需要关注下面\b这段代码： _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial); 如果传入的是对象，很明显会被合并成一次： Object.assign( nextState, &#123;index: state.index+ 1&#125;, &#123;index: state.index+ 1&#125;) 如果传入的是函数，函数的参数preState是前一次合并后的结果，所以计算结果是准确的。 4.componentDidMount调用setstate 在componentDidMount()中，你 可以立即调用setState()。它将会触发一次额外的渲染，但是它将在浏览器刷新屏幕之前发生。这保证了在此情况下即使render()将会调用两次，用户也不会看到中间状态。谨慎使用这一模式，因为它常导致性能问题。在大多数情况下，你可以 在constructor()中使用赋值初始状态来代替。然而，有些情况下必须这样，比如像模态框和工具提示框。这时，你需要先测量这些DOM节点，才能渲染依赖尺寸或者位置的某些东西。 以上是官方文档的说明，不推荐直接在componentDidMount直接调用setState，由上面的分析：componentDidMount本身处于一次更新中，我们又调用了一次setState，就会在未来再进行一次render，造成不必要的性能浪费，大多数情况可以设置初始值来搞定。 当然在componentDidMount我们可以调用接口，再回调中去修改state，这是正确的做法。 当state初始值依赖dom属性时，在componentDidMount中setState是无法避免的。 5.componentWillUpdate componentDidUpdate这两个生命周期中不能调用setState。 由上面的流程图很容易发现，在它们里面调用setState会造成死循环，导致程序崩溃。 6.推荐使用方式在调用setState时使用函数传递state值，在回调函数中获取最新更新后的state。","categories":[],"tags":[{"name":"React","slug":"React","permalink":"www.conardli.top/tags/React/"}]},{"title":"前端性能优化总结","slug":"【性能优化】前端性能优化总结","date":"2018-12-28T14:33:19.000Z","updated":"2019-03-28T13:03:55.501Z","comments":true,"path":"2018/12/28/【性能优化】前端性能优化总结/","link":"","permalink":"www.conardli.top/2018/12/28/【性能优化】前端性能优化总结/","excerpt":"","text":"1.原则多使用内存，缓存或者其他方法 减少CPU计算，减少网络请求 减少IO操作（硬盘读写） 2.加载资源优化静态资源的合并和压缩。 静态资源缓存（浏览器缓存策略）。 使用CDN让静态资源加载更快。 3. 渲染优化CSS放head中，JS放body后 图片懒加载 减少DOM操作，对DOM操作做缓存 减少DOM操作，多个操作尽量合并在一起执行 事件节流 尽早执行操作 DOMContentLoaded 4. 示例4.1 资源合并a.js b.js c.js --- abc.js 4.2 缓存通过连接名称控制缓存 &lt;script src=\"abc_1.js\" &gt;&lt;/script&gt; 只有改变内容的时候，链接名称才会改变。 4.3 懒加载&lt;img src=\"preview.png\" realsrc=\"abc.png\" id=\"img1\" /&gt;&lt;script&gt; var i = document.getElementById('img1'); i.src = i.getAttribute('realsrc');&lt;/script&gt; 4.4 缓存dom查询//没有缓存domfor (let i = 0; i &lt; document.getElementsByTagName('p').length; i++) &#123;&#125;//缓存domvar p = document.getElementsByTagName('p');for (let i = 0; i &lt; p.length; i++) &#123;&#125; 4.5 合并dom插入var listNode = document.getElementById('list');var flag = document.createDocumentFragment();var li;for (let i = 0; i &lt; 10; i++) &#123; li = document.createElement('li'); li.innerHTML = i; flag.appendChild(li);&#125;listNode.appendChild(flag); 10次dom插入 —&gt; 1次dom插入 4.6 事件节流监听文字改变事件，无操作100毫秒后执行操作，不用每次触发。var textarea = document.getElementById('ta');var timeoutId;textarea.addEventListener('keyup',function()&#123; if(i)&#123; clearTimeout(i); &#125; timeoutId = setTimeout(() =&gt; &#123; //操作 &#125;, 100);&#125;); 事件节流主要用于触发频率较高的事件，设定一个缓冲触发事件。 补充异步加载非核心代码异步加载 – 异步加载的方式 – 区别 1.动态脚本加载 用js创建 2.defer 3.async &lt;script src=\"script.js\"&gt;&lt;/script&gt;没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。&lt;script async src=\"script.js\"&gt;&lt;/script&gt;有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。&lt;script defer src=\"myscript.js\"&gt;&lt;/script&gt;有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。 关于 defer，我们还要记住的是它是按照加载顺序执行脚本的 标记为async的脚本并不保证按照指定它们的先后顺序执行。对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，只要它加载完了就会立刻执行。 浏览器缓存总结的非常好 浏览器缓存 – 缓存的分类 – 缓存的原理 缓存就是html文件在本地存在的副本， 强缓存 发现有缓存直接用。 Expires: 绝对时间，判断客户端日期是否超过这个时间Cache-Control：相对时间，判断访问间隔是否大于3600秒//在设定时间之前不会和服务端进行通信了//如果两个都下发以后者为准 协商缓存 询问服务器缓存是否可以用，在进行判断是否用。 Last-Modified/If-Modified-Since 第一次请求，respone的header加上Last-Modified（最后修改时间）再次请求，在request的header上加上If-Modified-Since 和服务端的最后修改时间对比，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。浏览器收到304的响应后，就会从缓存中加载资源如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified的Header在重新加载的时候会被更新 Etag/If-None-Match 这两个值是由服务器生成的每个资源的唯一标识字符串，只要资源有变化就这个值就会改变；其判断过程与Last-Modified/If-Modified-Since类似，他可以精确到秒的更高级别。 DNS预解析&lt;meta http-equiv=\"x-dns-prefetch-control\" content=\"on\"&gt;&lt;link rel=\"dns-prefetch\" href=\"//www.zhix.net\"&gt; 在一些浏览器的a标签是默认打开dns预解析的，在https协议下dns预解析是关闭的，加入mate后会打开。","categories":[],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"www.conardli.top/tags/性能优化/"}]},{"title":"指令控制 windows 电源选项","slug":"【electron】指令控制-windows-电源选项","date":"2018-12-17T10:07:12.000Z","updated":"2019-04-16T11:42:14.380Z","comments":true,"path":"2018/12/17/【electron】指令控制-windows-电源选项/","link":"","permalink":"www.conardli.top/2018/12/17/【electron】指令控制-windows-电源选项/","excerpt":"","text":"1.powercfg命令。使用powercfg.exe控制电源计划（也称为电源使用方案）。 2.ac和dc一般电源有两种供电模式： ac代表交流电源 dc代表直流电源 一般情况下ac就是直接接通电源，dc是使用电池供电。 一般电源命令都需要分别设置在ac和dc下的模式。 3.电源选项的唯一标识每个电源选项都有一个唯一的guid标识，我们可以使用某些命令通过这个唯一标识来设定这个电源选项。 例如官方文档中的电源计划： 如图：电源计划 节电，平衡，高性能分别对应了一个guid。 我们可以通过查阅windows文档或者使用 powercfg /query 命令来查询每个选项对应的guid。 4.设置电源计划powercfg -setactive guid 可以通过-setactive来设置当前电源计划。 例如下面的代码将电源设置为平衡模式 powercfg -setactive 381b4222-f694-41f0-9685-ff5bb260df2e 5.修改电源计划中的电源选项直接查看控制面板中的电源选项可以看到下面的界面 我们可以通过下面的命令来修改powercfg -change value 后面的value有如下几个选项 monitor-timeout-ac &lt;分钟&gt;monitor-timeout-dc &lt;分钟&gt;disk-timeout-ac &lt;分钟&gt;disk-timeout-dc &lt;分钟&gt;standby-timeout-ac &lt;分钟&gt;standby-timeout-dc &lt;分钟&gt;hibernate-timeout-ac &lt;分钟&gt;hibernate-timeout-dc &lt;分钟&gt; monitor:屏幕disk:磁盘standby:待机hibernate:休眠 实例： powercfg /change monitor-timeout-ac 5 表示：在接通电源模式下设置屏幕5分钟后关闭。 powercfg /change monitor-hibernate-dc 0 表示：在不接通电源模式下永不休眠 6.高级选项还有一些其他选项，例如按下电源按钮，睡眠按钮，关闭盖子等发生的操作。 可以使用如下命令设置： powercfg /setacvalueindex scheme_GUID sub_GUID setting_GUID setting_indexpowercfg /setdcvalueindex scheme_GUID sub_GUID setting_GUID setting_index scheme_GUID : 电源计划guid，可以通过powercfg /list查询 sub_GUID：子组guid，可以解释成在众多的电源选项上又分的一层组，可以通过过powercfg /query查询 setting_GUID：选项guid，具体的电源选项。 setting_index：具体设置的索引，如下图： 不采取任何操作，睡眠，休眠，关机 例如： powercfg -SetAcValueIndex 381b4222-f694-41f0-9685-ff5bb260df2e 4f971e89-eebd-4455-a8de-9e59040e7347 5ca83367-6e45-459f-a27b-476b1d01c936 0 表示：设置接通电源的情况下，电源关盖后不采取任何操作。 powercfg -SetDcValueIndex 381b4222-f694-41f0-9685-ff5bb260df2e 4f971e89-eebd-4455-a8de-9e59040e7347 7648efa3-dd9c-4e3e-b566-50f929386280 1 表示：设置未接通电源的情况下，按下电源键使电脑进入睡眠。 7.总结有了这些操作，我们就可以使用某些语言比如node，来批处理windows电源选项了。 更详细的选项可以查询windows官方文档： https://docs.microsoft.com/en-us/windows-hardware/design/device-experiences/powercfg-command-line-options#option_getactivescheme","categories":[],"tags":[{"name":"electron","slug":"electron","permalink":"www.conardli.top/tags/electron/"}]},{"title":"react中key的正确使用方式","slug":"【React深入】react中key的正确使用方式","date":"2018-11-26T17:50:45.000Z","updated":"2019-04-16T11:42:43.649Z","comments":true,"path":"2018/11/27/【React深入】react中key的正确使用方式/","link":"","permalink":"www.conardli.top/2018/11/27/【React深入】react中key的正确使用方式/","excerpt":"","text":"在开发react程序时我们经常会遇到这样的警告，然后就会想到：哦！循环子组件忘记加key了～ 出于方便，有时候会不假思索的使用循环的索引作为key，但是这样真的好吗？什么样的值才是key的最佳选择？ 为了弄明白，本文将从三个方面来分析”key”： 1.为什么要使用key 2.使用index做key存在的问题 3.正确的选择key 1.为什么要使用keyreact官方文档是这样描述key的： Keys可以在DOM中的某些元素被增加或删除的时候帮助React识别哪些元素发生了变化。因此你应当给数组中的每一个元素赋予一个确定的标识。 react的diff算法是把key当成唯一id然后比对组件的value来确定是否需要更新的，所以如果没有key，react将不会知道该如何更新组件。 你不传key也能用是因为react检测到子组件没有key后，会默认将数组的索引作为key。 react根据key来决定是销毁重新创建组件还是更新组件，原则是： key相同，组件有所变化，react会只更新组件对应变化的属性。 key不同，组件会销毁之前的组件，将整个组件重新渲染。 2.使用index做key存在的问题2.1 受控组件单纯的展示组件比如span，这些组件是受控组件，意味着他们的值将是我们给定好的。 如果子组件只是受控组件，使用index作为key，可能表面上不会有什么问题，实际上性能会受很大的影响。例如下面的代码： // ['张三','李四','王五']=&gt;&lt;ul&gt; &lt;li key=\"0\"&gt;张三&lt;/li&gt; &lt;li key=\"1\"&gt;李四&lt;/li&gt; &lt;li key=\"2\"&gt;王五&lt;/li&gt;&lt;/ul&gt;// 数组重排 -&gt; ['王五','张三','李四'] =&gt;&lt;ul&gt; &lt;li key=\"0\"&gt;王五&lt;/li&gt; &lt;li key=\"1\"&gt;张三&lt;/li&gt; &lt;li key=\"2\"&gt;李四&lt;/li&gt;&lt;/ul&gt; 当元素数据源的顺序发生改变时，对应的： key为0，1，2的组件都发生了变化，三个子组件都会被重新渲染。（这里的重新渲染不是销毁，因为key还在） 相反，我们使用唯一id作为key： // ['张三','李四','王五']=&gt;&lt;ul&gt; &lt;li key=\"000\"&gt;张三&lt;/li&gt; &lt;li key=\"111\"&gt;李四&lt;/li&gt; &lt;li key=\"222\"&gt;王五&lt;/li&gt;&lt;/ul&gt;// 数组重排 -&gt; ['王五','张三','李四'] =&gt;&lt;ul&gt; &lt;li key=\"222\"&gt;王五&lt;/li&gt; &lt;li key=\"000\"&gt;张三&lt;/li&gt; &lt;li key=\"111\"&gt;李四&lt;/li&gt;&lt;/ul&gt; 根据上面的更新原则，子组件的值和key均未发生变化，只是顺序发生改变，因此react只是将他们做了移动，并未重新渲染。 2.2 非受控组件像input这样可以由用户任意改变值，不受我们控制的组件，在使用了index作为key时可能会发生问题，看如下的栗子： 子组件： render() &#123; return ( &lt;div&gt; &lt;p &gt;值：&#123;this.props.value&#125;&lt;/p&gt; &lt;input /&gt; &lt;/div&gt; ); &#125;&#125; 父组件&#123;this.state.data.map((element, index) =&gt; &#123; return &lt;Child value=&#123;element&#125; key=&#123;index&#125; /&gt; &#125;)&#125; 我们在前两个输入框分别输入对应的值： 然后在头部添加一个元素： 很明显，这个结果并不符合我们的预期，我们来分析一下发生了什么： &lt;div key=\"0\"&gt; &lt;p &gt;值：0&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=\"1\"&gt; &lt;p &gt;值：1&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=\"2\"&gt; &lt;p &gt;值：2&lt;/p&gt; &lt;input /&gt;&lt;/div&gt; 变化后： &lt;div key=\"0\"&gt; &lt;p &gt;值：5&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=\"1\"&gt; &lt;p &gt;值：0&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=\"2\"&gt; &lt;p &gt;值：1&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=\"3\"&gt; &lt;p &gt;值：2&lt;/p&gt; &lt;input /&gt;&lt;/div&gt; 可以发现：key 0，1，2并没有发生改变，根据规则，不会卸载组件，只会更新改变的属性。 react只diff到了p标签内值的变化，而input框中的值并未发生改变，因此不会重新渲染，只更新的p标签的值。 当使用唯一id作为key后： &lt;div key=\"000\"&gt; &lt;p &gt;值：0&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=\"111\"&gt; &lt;p &gt;值：1&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=\"222\"&gt; &lt;p &gt;值：2&lt;/p&gt; &lt;input /&gt;&lt;/div&gt; 变化后： &lt;div key=\"555\"&gt; &lt;p &gt;值：5&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=\"000\"&gt; &lt;p &gt;值：0&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=\"111\"&gt; &lt;p &gt;值：1&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=\"222\"&gt; &lt;p &gt;值：2&lt;/p&gt; &lt;input /&gt;&lt;/div&gt; 可以很明显的发现：key为 111，222，333的组件没有发生任何改变，react不会更新他们，只是新插入了子组件555，并改变了其他组件的位置。 3.正确的选择key3.1 纯展示如果组件单纯的用于展示，不会发生其他变更，那么使用index或者其他任何不相同的值作为key是没有任何问题的，因为不会发生diff，就不会用到key。 3.2 推荐使用index的情况并不是任何情况使用index作为key会有缺陷，比如如下情况： 你要分页渲染一个列表，每次点击翻页会重新渲染： 使用唯一id： 第一页&lt;ul&gt; &lt;li key=\"000\"&gt;张三&lt;/li&gt; &lt;li key=\"111\"&gt;李四&lt;/li&gt; &lt;li key=\"222\"&gt;王五&lt;/li&gt;&lt;/ul&gt;第二页&lt;ul&gt; &lt;li key=\"333\"&gt;张三三&lt;/li&gt; &lt;li key=\"444\"&gt;李四四&lt;/li&gt; &lt;li key=\"555\"&gt;王五五&lt;/li&gt;&lt;/ul&gt; 翻页后，三条记录的key和组件都发生了改变，因此三个子组件都会被卸载然后重新渲染。 使用index： 第一页&lt;ul&gt; &lt;li key=\"0\"&gt;张三&lt;/li&gt; &lt;li key=\"1\"&gt;李四&lt;/li&gt; &lt;li key=\"2\"&gt;王五&lt;/li&gt;&lt;/ul&gt;第二页&lt;ul&gt; &lt;li key=\"0\"&gt;张三三&lt;/li&gt; &lt;li key=\"1\"&gt;李四四&lt;/li&gt; &lt;li key=\"2\"&gt;王五五&lt;/li&gt;&lt;/ul&gt; 翻页后，key不变，子组件值发生改变，组件并不会被卸载，只发生更新。 3.3 子组件可能发生变更/使用了非受控组件大多数情况下，使用唯一id作为子组件的key是不会有任何问题的。 这个id一定要是唯一，并且稳定的，意思是这条记录对应的id一定是独一无二的，并且永远不会发生改变。 不推荐使用math.random或者其他的第三方库来生成唯一值作为key。 因为当数据变更后，相同的数据的key也有可能会发生变化，从而重新渲染，引起不必要的性能浪费。 如果数据源不满足我们这样的需求，我们可以在渲染之前为数据源手动添加唯一id，而不是在渲染时添加。","categories":[],"tags":[{"name":"React","slug":"React","permalink":"www.conardli.top/tags/React/"}]},{"title":"electron程序保护措施（崩溃监控，开机自启，托盘关闭）","slug":"【electron】electron程序保护措施（崩溃监控，开机自启，托盘关闭）","date":"2018-11-07T12:11:41.000Z","updated":"2019-04-20T11:48:03.886Z","comments":true,"path":"2018/11/07/【electron】electron程序保护措施（崩溃监控，开机自启，托盘关闭）/","link":"","permalink":"www.conardli.top/2018/11/07/【electron】electron程序保护措施（崩溃监控，开机自启，托盘关闭）/","excerpt":"","text":"在某种情况下，我们可能希望我们的客户端程序尽可能连续不断的运行在我们的系统中，并保持稳定。 以下几种方式可以帮助我们做到这一点： 1.崩溃监控electron为我们提供了监听程序崩溃的事件： Event: 'crashed'返回:event Eventkilled Boolean当渲染进程崩溃或被结束时触发 此事件是用来家庭渲染进程崩溃的，但是当主进程意外崩溃时也会触发该事件。 在监测到程序崩溃后，我们要让程序重新启动，此时我们要首先判断window对象是否被销毁，也就是主进程是否被杀死，还是渲染进程崩溃，同时作出不同的处理。 当mainWin被销毁时我们直接重启整个应用，使用如下api： app.relaunch([options])options Object (可选)args StringexecPath String (可选)从当前实例退出，重启应用。默认情况下，新的实例会和当前实例使用相同的工作目录以及命令行参数。 当设置了 args 参数时， args 将作为命令行参数传递。 当设置了 execPath ，execPath 将被执行以重新启动，而不是当前的应用程序。请注意, 此方法在执行时不会退出当前的应用程序, 你需要在调用 app.relaunch 方法后再执行 app. quit 或者 app.exit 来让应用重启。 只是渲染进程崩溃，我们只需将其他窗体销毁，然后重新load我们的主窗口。 崩溃重启逻辑： if (mainWin.isDestroyed()) &#123; app.relaunch(); app.exit(0);&#125; else &#123; BrowserWindow.getAllWindows().forEach((w) =&gt; &#123; if (w.id !== mainWin.id) w.destroy(); &#125;); mainWin.reload();&#125; 当然，我们还要记录一下程序的崩溃日志，我们要确保日志接口发出成功后再重启我们的程序： 下面是程序崩溃后的完整逻辑： import &#123; BrowserWindow, app, dialog&#125; from 'electron'; const mainWindow = BrowserWindow.fromId(global.mainId);mainWindow.webContents.on('crashed', () =&gt; &#123; const options = &#123; type: 'error', title: '进程崩溃了', message: '这个进程已经崩溃.', buttons: ['重载', '退出'], &#125;; recordCrash().then(() =&gt; &#123; dialog.showMessageBox(options, (index) =&gt; &#123; if (index === 0) reloadWindow(mainWindow); else app.quit(); &#125;); &#125;).catch((e) =&gt; &#123; console.log('err', e); &#125;);&#125;)function recordCrash() &#123; return new Promise(resolve =&gt; &#123; // 崩溃日志请求成功.... resolve(); &#125;)&#125; function reloadWindow(mainWin) &#123; if (mainWin.isDestroyed()) &#123; app.relaunch(); app.exit(0); &#125; else &#123; BrowserWindow.getAllWindows().forEach((w) =&gt; &#123; if (w.id !== mainWin.id) w.destroy(); &#125;); mainWin.reload(); &#125;&#125; 写好代码之后，我们可以直接在控制台输入 process.crash()来进行测试，或者直接在任务管理器杀掉我们的进程进行测试。 2.开机自启开机自启是保证我们的程序能长时间在机器上运行很重要的一点。 电脑上有很多程序都设置了开机自启动，比如qq，微信，迅雷等，他们都是通过修改注册表来实现的，我们可以看一下注册表\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run: 所以我们也要将我们程序的路径写到这里。 发现了一个非常好的写注册表的模块，winreg注意mac不能使用这个模块，所以首先要判断是否为window再引用这个模块。 借助这个模块我们可以非常简单的修改注册表： const WinReg = require('winreg');const startOnBoot = &#123; enableAutoStart: function (name, file, callback) &#123; var key = getKey(); key.set(name, WinReg.REG_SZ, file, callback || noop); &#125;, disableAutoStart: function (name, callback) &#123; var key = getKey(); key.remove(name, callback || noop); &#125;, getAutoStartValue: function (name, callback) &#123; var key = getKey(); key.get(name, function (error, result) &#123; if (result) &#123; callback(result.value); &#125; else &#123; callback(null, error); &#125; &#125;); &#125;&#125;;function noop() &#123; &#125;const RUN_LOCATION = '\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run';function getKey() &#123; return new WinReg(&#123; hive: WinReg.HKCU, //CurrentUser, key: RUN_LOCATION &#125;);&#125;export default function autoStart() &#123; startOnBoot.getAutoStartValue('MY_CLIENT_AUTOSTART', function (value) &#123; if (!value) &#123; startOnBoot.enableAutoStart('MY_CLIENT_AUTOSTART', process.execPath, function () &#123; console.log('开机自动启设置'); &#125;); &#125; &#125;);&#125; 执行完程序之后，再看注册表，发现我们程序的路径已经写进去了： 然后电脑重启后你的程序就自动启动了。 3.托盘关闭向qq和微信一样，有的时候我们并不想让用户通过点关闭按钮的时候就关闭程序，而是把程序最小化到托盘，在托盘上做真正的退出操作。 首先要监听窗口的关闭事件，阻止用户关闭操作的默认行为。 mainWindow.on('close', (event) =&gt; &#123; mainWindow.hide(); event.preventDefault();&#125;); 然而这时你发现，这只是最小化了程序，任务栏里程序依然存在，我们需要让程序在任务栏里也消失： mainWindow.on('close', (event) =&gt; &#123; mainWindow.hide(); mainWindow.setSkipTaskbar(true); event.preventDefault();&#125;); 这时程序就再也找不到了，任务托盘中也没有我们的程序，所以我们要先创建好任务托盘，并做好事件监听： function createTray() &#123; const mainWindow = BrowserWindow.fromId(global.mainId); tray = new Tray(path.join(global.__dirname, 'icon.ico')); const contextMenu = Menu.buildFromTemplate([ &#123; label: '退出', click: () =&gt; &#123; mainWindow.destroy(); app.quit(); &#125; &#125;, ]) tray.setToolTip('我的客户端') tray.setContextMenu(contextMenu) tray.on('click', () =&gt; &#123; if (mainWindow.isVisible()) &#123; mainWindow.hide(); mainWindow.setSkipTaskbar(false); &#125; else &#123; mainWindow.show(); mainWindow.setSkipTaskbar(true); &#125; &#125;) &#125; 以上这些操作为我们的程序又增加了好几层的防护措施，我们的程序就不会那么轻而易举的挂掉啦！","categories":[],"tags":[{"name":"electron","slug":"electron","permalink":"www.conardli.top/tags/electron/"}]},{"title":"使用electron静默打印","slug":"【electron】使用electron静默打印","date":"2018-11-01T10:30:14.000Z","updated":"2019-04-16T11:42:04.368Z","comments":true,"path":"2018/11/01/【electron】使用electron静默打印/","link":"","permalink":"www.conardli.top/2018/11/01/【electron】使用electron静默打印/","excerpt":"","text":"1.使用electron打印的理由很多情况下程序中使用的打印都是用户无感知的。并且想要灵活的控制打印内容，往往需要借助打印机给我们提供的api再进行开发，这种开发方式非常繁琐，并且开发难度较大。 electron提供的打印api可以非常灵活的控制打印设置的显示，并且可以通过html来书写打印内容。 2.apielectron提供了两种方式进行打印，一种是直接调用打印机打印，一种是打印到pdf。 并且有两种对象可以调用打印： 第一是通过window的webcontent对象，使用此种方式需要单独开出一个打印的窗口，可以将该窗口隐藏，但是通信调用相对复杂。 另一种是使用页面的webview元素调用打印，可以将webview隐藏在调用的页面中，通信方式比较简单。 两个对象调用打印方法的使用方式都一样。 2.1 print官网api如下 contents.print([options], [callback])选项 Object (可选)silent Boolean (可选) - 不询问用户打印信息，默认为 false。printBackground Boolean (optional) - Also prints the background color and image of the web page. Default is false.deviceName String (optional) - Set the printer device name to use. Default is ''.callback Function (可选)success Boolean - Indicates success of the print call. 打印配置(options)中只有简单的三个配置： silent：打印时是否不展示打印配置（是否静默打印） printBackground：是否打印背景 deviceName：打印机设备名称 首先要将我们使用的打印机名称配置好，并且要在调用打印前首先要判断打印机是否可用。 使用getPrinters方法可获取当前设备已经配置的打印机列表，注意配置过不是可用，只是在此设备上安装过驱动。 通过getprinter获取到的打印机对象：https://electronjs.org/docs/api/structures/printer-info 我们这里只管关心两个，name和status，status为0时表示打印机可用。 这里的status必须经历一次打印失败才能返回非0值，也就是说第一次获取打印机状态一定是0。但是这一次的打印虽然不能判断出错误，打印的任务已经预存在队列中了，当下一次打印机状态变为可用时，将会打印暂存的任务。 当打印机纸张用完时也是这种情况，剩余任务会暂存起来，下次打印机可用时即可以打印了。 print的第二个参数callback是用于判断打印任务是否发出的回调，而不是打印任务完成后的回调。所以一般打印任务发出，回调函数即会调用并返回参数true。这个回调并不能判断打印是否真的成功了。 2.2 printToPdfcontents.printToPDF(options, callback)选项 ObjectmarginsType Integer (optional) - Specifies the type of margins to use. Uses 0 for default margin, 1 for no margin, and 2 for minimum margin.pageSize String (optional) - Specify page size of the generated PDF. Can be A3, A4, A5, Legal, Letter, Tabloid or an Object containing height and width in microns.printBackground Boolean (optional) - Whether to print CSS backgrounds.printSelectionOnly Boolean (optional) - Whether to print selection only.landscape Boolean (optional) - true for landscape, false for portrait.callback Function - 回调函数error Errordata Buffer printToPdf的用法基本和print相同，但是由于print是native code提供的方法，配置项非常少，而printToPdf则扩展了很多属性。 包括可以对打印的margin，打印页眉页脚等进行配置。 配置项很多，翻了一下源码发现还有很多没有被贴进api的： const defaultPrintingSetting = &#123; pageRage: [], mediaSize: &#123;&#125;, landscape: false, color: 2, headerFooterEnabled: false, marginsType: 0, isFirstRequest: false, requestID: getNextId(), previewModifiable: true, printToPDF: true, printWithCloudPrint: false, printWithPrivet: false, printWithExtension: false, deviceName: 'Save as PDF', generateDraftData: true, fitToPageEnabled: false, scaleFactor: 1, dpiHorizontal: 72, dpiVertical: 72, rasterizePDF: false, duplex: 0, copies: 1, collate: true, shouldPrintBackgrounds: false, shouldPrintSelectionOnly: false&#125; 3.打印边距问题打印的时候打印机会给纸张留一个默认边距，如果是A4这样的纸张几乎可以忽略不计了，但是打印小规格纸张如50mm*50mm，这个边距就十分明显了，严重影响了整体布局。 printToPdf方法提供了非常多的配置项，其中包括了配置打印边距的参数，但是print方法却没有该配置项。 我们可以通过一项css配置来解决这个问题,即 @page { margin: 0px; } 通过此配置可灵活配置打印边距。还有一个css属性``` @media print &#123;&#125;``` 此配置是只有在打印时才生效的css，控制的是打印边距以内的css，并不能控制打印边距。# 4.打印方案使用webcontent打印，首先要有一个打印窗口，这个窗口不能随时打印随时创建，比较耗费性能。可以将它在程序运行时启动好，并做好事件监听。此过程需和调用打印的进行做好通信：大致过程如下：![image](http://on-img.com/chart_image/5badf135e4b0fe81b64ad7b9.png)可见通信非常繁琐使用webview进行打印可实现同样的效果但是通信方式会变得简单，因为渲染进程和webview通信不需要经过主进程，通过如下方式即可：```js// In embedder page. const webview = document.querySelector(&apos;webview&apos;) webview.addEventListener(&apos;ipc-message&apos;, (event) =&gt; &#123; console.log(event.channel) // Prints &quot;pong&quot; &#125;) webview.send(&apos;ping&apos;)Copy // 在访客页。 const &#123;ipcRenderer&#125; = require('electron') ipcRenderer.on('ping', () =&gt; &#123; ipcRenderer.sendToHost('pong') &#125;) 5.示例程序示例demo：https://github.com/ConardLi/electron-print-demo","categories":[],"tags":[{"name":"electron","slug":"electron","permalink":"www.conardli.top/tags/electron/"}]},{"title":"个人博客搭建及配置","slug":"【博客搭建】个人博客搭建及配置","date":"2018-01-01T12:13:20.000Z","updated":"2019-04-18T14:30:44.226Z","comments":true,"path":"2018/01/01/【博客搭建】个人博客搭建及配置/","link":"","permalink":"www.conardli.top/2018/01/01/【博客搭建】个人博客搭建及配置/","excerpt":"","text":"一、基础配置 1.1.本地安装hexo首先保证你电脑上有node环境，这个不懂的可以自定百度。 控制台输入node -v出现版本号说明安装成功。 有了node就可以安装hexo了，控制台输入如下命令 npm i -g hexo 同样控制台输入hexo -v出现版本号说明安装成功。 然后开始初始化项目，控制台输入： hexo init 得到如下项目目录： node_modules：是依赖包public：存放的是生成的页面scaffolds：命令生成文章等的模板source：用命令创建的各种文章themes：主题_config.yml：整个博客的配置db.json：source解析所得到的package.json：项目所需模块项目的配置信息 1.2.本地运行首先在本地跑起来你的代码 控制台安装hexo-server npm i hexo-server 然后运行 hexo-server 在浏览器中访问：http://localhost:4000就可以看到你本定运行的页面了 这时你可以在本地调试一下你的blog。 1.3.github配置首先要创建一个github账号 并配置好ssh 这些不懂的可以自行百度。 创建一个repo，名称为yourname.github.io, 其中yourname是你的github名称，按照这个规则创建github page才会生效。 修改_config.yml中的git配置 deploy: type: git repo: https://github.com/xxxx.git branch: master 1.4.部署上传在本地安装上传工具 npm install hexo-deployer-git --save 依次执行如下命令 hexo clean //删除上次打包hexo generate //打包hexo deploy /上传 这里我单独写了sh执行这三段脚本，这样每次只需要执行这个sh即可。 在浏览器中输入http://yourgithubname.github.io就可以看到你的个人博客了！ 1.5一些其他配置搜索功能使用搜索功能首先需要： npm install -S hexo-generator-json-content 然后： search: insight: true readme1.首先在source文件夹下建立一个README.md 2.修改_config.yml skip_render: README.md 二、绑定二人域名2.1购买一个域名这里我选择的是阿里云，挑选一个自己喜欢的域名购买。 2.2域名解析进入控制台添加域名解析。 按照如下规则添加两条记录。 这时去访问解析好的域名会出现如下页面。 这说明域名解析没有问题，接下来进入github进行配置 2.3 hexo配置在本地的博客目录中找到source文件夹。 新建一个没有后缀名的文件GNAME 在文件中添加你的域名，如： lisq.xyz 保存后重新生成，并提交你的博客。 2.4 github配置在github中找到你的博客仓库。 点击找到```Custom domain 输入你的域名点击save 然后你就可以在浏览器用你的域名愉快的访问啦！ 三、同时托管到github和coding上github page毕竟是国外站点，访问速度相对来说比较慢，但是同时你又想在gihub上保存一下代码，可以尝试同时托管两个仓库。 做解析的时候海外的ip 指向到github，国内的或者说百度的直接指向coding。 3.1.在coding上提交代码首先做的操作和github是一样的，就是创建一个ssh。 这里要注意的是，你的电脑上已经有了gihub的ssh，如果还像github一样一路回车会把gihub的ssh给覆盖掉。 所以这里在执行 $ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 时要注意，给生成的文件配置一个新路径： 然后配置生成的ssh 在coding中创建一个仓库，这里注意仓库的名字可以随意取，不像gihub一样可以随意给定。 将创建仓库的git地址添加到_config.yml中： deploy:js type: git repo: github: https://github.com/ConardLi/ConardLi.github.io.git coding: https://git.dev.tencent.com/ConardLi/lisqBlog.git branch: master 然后重新部署并上传博客，去仓库查看代码证明上传成功： 3.2.开启coding page点击coding的pages服务，直接点击一键开启即可。 开启后即可通过给定域名直接访问了： http://conardli.coding.me/ 3.3.域名解析将新生成的coding域名进行解析，这样国内就默认访问coding的页面，比github要快不少。 另外还可以将github的ip进行国外站点配置。 在coding page中将自己的域名进行绑定。 配置完成后发现速度快了不少，有木有… 四、站长统计 使用一个站长统计工具，可以为博客添加一个如上面似的详细的访问报表。 站长统计工具有很多，每个工具大同小异，这里我选择了CNZZ。 4.1.CNZZ配置1.注册一个账号。 2.添加网站。 按照如下要求添加网站 3.选择统计代码 添加完网站后就可以选择一段代码插入你的博客里了，CNZZ提供了几种样式，你可以选择展示真实的统计数量，一个cnzz图标或者什么都不显示。 4.2.代码配置将上面复制的代码插入到你主题代码的公共区域中。 每个主题的代码都不一样，但是大体结构是相同的，都会将通用的组件抽取出来。 这里我找到了每个页面都使用的footer组件，我使用的是hueman主题，代码在themes/hueman/common/footer.ejs 在此文件中找到合适的位置插入你的统计代码。 比如我的（script内的部分）： 五、阅读统计这里的统计是用来展示在页面上的，可以标示文章以及博客的热度。 使用不蒜子来展示文章访问统计和页面访问统计。 5.1.引入不蒜子将不蒜子js文件引入博客主题公共组件中。 &lt;script async src=\"//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt; 这里我同站长统计一样放在themes/hueman/common/footer.ejs 5.2.文章访问统计要显示每篇文章的访问量，复制以下代码添加到你需要显示的位置。 可以在标签上自定义一些样式。 算法：pv的方式，单个用户点击1篇文章，本篇文章记录1次阅读量。 &lt;span id=\"busuanzi_container_page_pv\"&gt; 本文总阅读量&lt;span id=\"busuanzi_value_page_pv\"&gt;&lt;/span&gt;次&lt;/span&gt; 5.3.整站访问统计算法a：pv的方式，单个用户连续点击n篇文章，记录n次访问量。 &lt;span id=\"busuanzi_container_site_pv\"&gt; 本站总访问量&lt;span id=\"busuanzi_value_site_pv\"&gt;&lt;/span&gt;次&lt;/span&gt; 算法b：uv的方式，单个用户连续点击n篇文章，只记录1次访客数。&lt;span id=\"busuanzi_container_site_uv\"&gt; 本站访客数&lt;span id=\"busuanzi_value_site_uv\"&gt;&lt;/span&gt;人次&lt;/span&gt; 六、评论系统博客使用valine作为评论工具，原因是他使用简介，体积轻量，灵活配置，速度很快！ 6.1 注册LeanCloudvaline接住了LeanCloud的力量，所以需要LeanCloud的APP ID 和 APP Key 首先注册和登录LeanCloud 创建一个应用： 应用创建好以后，进入刚刚创建的应用，选择左下角的设置&gt;应用Key，然后就能看到你的APP ID和APP Key了： 6.2 代码将如下代码插入你的文章模板中 &lt;head&gt; ... &lt;script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"&gt;&lt;/script&gt; &lt;script src='//unpkg.com/valine/dist/Valine.min.js'&gt;&lt;/script&gt; ...&lt;/head&gt;&lt;body&gt; ... &lt;div id=\"vcomments\"&gt;&lt;/div&gt; &lt;script&gt; new Valine(&#123; el: '#vcomments', appId: '&lt;API_ID&gt;', appKey: '&lt;API_Key&gt;' &#125;) &lt;/script&gt;&lt;/body&gt; 配置好这些，等待两分钟，就可以在文章里使用你的评论啦。 6.3 数据管理由于Valine 是无后端评论系统，所以也就没有开发评论数据管理功能。 可以在leanCloud中管理评论 登录&gt;选择你创建的应用&gt;存储&gt;选择Class Comment 6.4 安全域名为了数据安全，在leanCloud中配置你的安全域名 6.5 配置项Valine还有一些其他的配置项 new Valine(&#123; el: '#vcomments' , appId: '&lt;APP_ID&gt;', appKey: '&lt;APP_KEY&gt;', notify:false, verify:false, avatar:'mm', placeholder: 'just go go' &#125;); placeholder类型:String默认值:Just go go必要性:false评论框占位提示符。notify类型:Boolean默认值:false必要性:false评论回复邮件提醒，请参考配置。verify类型:Boolean默认值:false必要性:false验证码服务。path类型:String默认值:window.location.pathname必要性:false当前文章页路径，用于区分不同的文章页，以保证正确读取该文章页下的评论列表。可选值：window.location.pathname (默认值，推荐)window.location.href自定义I. 请保证每个文章页路径的唯一性，否则可能会出现不同文章页下加载相同评论列表的情况。II. 如果值为window.location.href，可能会出现随便加不同参数进入该页面，而被判断成新页面的情况。avatar类型:String默认值:mm必要性:falseGravatar 头像展示方式。可选值：''(空字符串)mpidenticonmonsteridwavatarretrorobohashhide更多信息，请查看头像配置。meta类型:Array默认值:['nick','mail','link']必要性:false评论者相关属性。pageSize类型:Number默认值:10必要性:false评论列表分页，每页条数。lang类型:String默认值:zh-cn必要性:false多语言支持。可选值：zh-cnen如需自定义语言，请参考i18n。visitor类型:Boolean默认值:false必要性:false文章访问量统计。highlight类型：Boolean默认值: true必要性: false代码高亮，默认开启，若不需要，请手动关闭avatarForce类型: Boolean默认值: false必要性: false 七、SEO优化SEO是由英文Search Engine Optimization缩写而来， 中文意译为“搜索引擎优化”。SEO是指通过站内优化比如网站结构调整、网站内容建设、网站代码优化等以及站外优化。 简而言之，就是让人们更容易搜索到你的站点。 首先要做的就是让搜索引擎收录我们的站点。 7.1.百度7.1.1 提交网址在搜索引擎中输入site:&lt;域名&gt;,如果如下图所示就是说明我们的网站并没有被百度收录。我们可以直接点击下面的“网址提交”来提交我们的网站 然后点击途中的提交网址 选择站点的相关属性： 接下来进行网站验证，推荐使用第三种GNAME验证，简单快捷，只需要给你的链接增加一条解析即可: 7.1.2 生成网站地图接下来要让你的网站生成网站地图，及生产sitemap，将sitemap提交到百度，先安装地图生成插件： npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 注意根目录的_config.yml将url配置成你的站点# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://lisq.xyz/root: / 重新部署博客后就会生成两个新文件sitemap.xml和baidusitemap.xml 7.1.3 将sitemap提交给百度点击链接提交 使用主动推送 主动推送安装插件npm install hexo-baidu-url-submit –save然后再根目录的配置文件中新增字段baidu_url_submit: count: 100 host: https://lisq.xyz/ token: 8OGYpxowYnhgVsUM path: baidu_urls.txt # 文本文档的地址 在加入新的deployedeploy: - type:baidu_url_submitter 百度收录的时间非常长，耐心等待吧。 7.2.谷歌点击这里添加你的网址 点击添加属性后即可添加你的博客地址。 进行验证： 谷歌收录的速度还是相当快的，而且操作比较简单。 八、文章目录hueman模版是不带文章目录的，所以需要手动给给文章增加导航功能。 hexo为我们提供了toc插件 toc：解析内容中的标题标签(h1~h6)并插入目录。 &lt;%- toc(str, [options]) %&gt; 参数 描述 默认值class Class 名称 toclist_number 显示编号 true 在layoit目录下新建文件toc.ejs 这里，我们可以为目录自定义一些样式： &lt;aside id=\"article-toc\" role=\"navigation\" class=\"fixed\"&gt; &lt;div id=\"article-toc-inner\"&gt; &lt;strong class=\"sidebar-title\"&gt; 目录&lt;/strong&gt; &lt;%- toc(post.content, &#123;list_number: false&#125;) %&gt; &lt;/div&gt;&lt;/aside&gt; 在common/article.ejs下将其插入： &lt;%- partial('toc') %&gt; 这里感觉整体的布局没地方放个目录了，所以就弄了个打开目录的按钮放在侧边栏。 九、部署到虚拟主机github page的速度实在欠佳，coding的page服务还不太稳定，所以我决定将博客迁移到虚拟主机上。 个人博客一般没什么太大的流量，作为新手入门来讲，去阿里云上选一个最便宜的即可。 由于hexo最终生成的文件完全是静态页面，我们不需要数据库，这时候我们要做的只是把文件通过ftp扔到虚拟主机上即可。 购买完虚拟主机后，会为我们提供FTP登录主机地址、FTP登录用户名、FTP登录密码，你可以手动下载一个ftp上传工具比如FileZilla手动完成文件上传，当然hexo为我们提供了更方便的方式，我们需要安装一个插件： npm install hexo-deployer-ftpsync --save deploy: type: ftpsync host: xxx //FTP登录主机地址 user: xxx //FTP登录用户名 pass: xxx //FTP登录密码 remote: /htdocs //指定文件放置的目录（一般虚拟主机默认就是这个） port: ignore: .DS_Store connections: verbose: true 配置完成后重新进行构建： hexo clean //删除上次打包hexo generate //打包hexo deploy /上传 最后，将虚拟主机的默认访问页指向我们博客的默认页面index.html，就可以愉快的访问了～ 注意，将我们的个人域名解析到虚拟主机上是需要进行备案的。","categories":[],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"www.conardli.top/tags/博客搭建/"}]}]}