{"meta":{"title":"李世奇的技术专栏","subtitle":null,"description":"Fe Coder","author":"ConardLi","url":"www.conardli.top"},"pages":[{"title":"about","date":"2018-10-28T15:07:13.000Z","updated":"2018-11-03T15:46:49.634Z","comments":true,"path":"about/index.html","permalink":"www.conardli.top/about/index.html","excerpt":"","text":"关于，以后再说…….."}],"posts":[{"title":"【多端开发】用JS开发跨平台桌面应用，从原理到实践","slug":"【多端开发】用JS开发跨平台桌面应用，从原理到实践","date":"2019-06-10T12:45:35.000Z","updated":"2019-06-10T12:47:13.673Z","comments":true,"path":"2019/06/10/【多端开发】用JS开发跨平台桌面应用，从原理到实践/","link":"","permalink":"www.conardli.top/2019/06/10/【多端开发】用JS开发跨平台桌面应用，从原理到实践/","excerpt":"","text":"导读使用Electron开发客户端程序已经有一段时间了，整体感觉还是非常不错的，其中也遇到了一些坑点，本文旨在从【运行原理】到【实际应用】对Electron进行一次系统性的总结。【多图，长文预警～】 本文所有实例代码均在我的github electron-react上，结合代码阅读文章效果更佳。另外electron-react还可作为使用Electron + React + Mobx + Webpack技术栈的脚手架工程。 一、桌面应用程序 桌面应用程序，又称为 GUI 程序（Graphical User Interface），但是和 GUI 程序也有一些区别。桌面应用程序 将 GUI 程序从GUI 具体为“桌面”，使冷冰冰的像块木头一样的电脑概念更具有 人性化，更生动和富有活力。 我们电脑上使用的各种客户端程序都属于桌面应用程序，近年来WEB和移动端的兴起让桌面程序渐渐暗淡，但是在某些日常功能或者行业应用中桌面应用程序仍然是必不可少的。 传统的桌面应用开发方式，一般是下面两种： 1.1 原生开发直接将语言编译成可执行文件，直接调用系统API，完成UI绘制等。这类开发技术，有着较高的运行效率，但一般来说，开发速度较慢，技术要求较高，例如： 使用C++ / MFC开发Windows应用 使用Objective-C开发MAC应用 1.2 托管平台一开始就有本地开发和UI开发。一次编译后，得到中间文件，通过平台或虚机完成二次加载编译或解释运行。运行效率低于原生编译，但平台优化后，其效率也是比较可观的。就开发速度方面，比原生编译技术要快一些。例如： 使用C# / .NET Framework(只能开发Windows应用) Java / Swing 不过，上面两种对前端开发人员太不友好了，基本是前端人员不会设计的领域，但是在这个【大前端😅】的时代，前端开发者正在想方设法涉足各个领域，使用WEB技术开发客户端的方式横空出世。 1.3 WEB开发使用WEB技术进行开发，利用浏览器引擎完成UI渲染，利用Node.js实现服务器端JS编程并可以调用系统API，可以把它想像成一个套了一个客户端外壳的WEB应用。 在界面上，WEB的强大生态为UI带来了无限可能，并且开发、维护成本相对较低，有WEB开发经验的前端开发者很容易上手进行开发。 本文就来着重介绍使用WEB技术开发客户端程序的技术之一【electron】 二、Electron Electron是由Github开发，用HTML，CSS和JavaScript来构建跨平台桌面应用程序的一个开源库。 Electron通过将Chromium和Node.js合并到同一个运行时环境中，并将其打包为Mac，Windows和Linux系统下的应用来实现这一目的。 https://electronjs.org/docs https://juejin.im/post/5c67619351882562276c3162#heading-5 2.1 使用Electron开发的理由： 1.使用具有强大生态的Web技术进行开发，开发成本低，可扩展性强，更炫酷的UI 2.跨平台，一套代码可打包为Windows、Linux、Mac三套软件，且编译快速 3.可直接在现有Web应用上进行扩展，提供浏览器不具备的能力 4.你是一个前端👨‍💻～ 当然，我们也要认清它的缺点：性能比原生桌面应用要低，最终打包后的安装包和其他文件都比较大。 2.2 开发体验兼容性 虽然你还在用WEB技术进行开发，但是你不用再考虑兼容性问题了，你只需要关心你当前使用Electron的版本对应Chrome的版本，一般情况下它已经足够新来让你使用最新的API和语法了，你还可以手动升级Chrome版本。同样的，你也不用考虑不同浏览器带了的样式和代码兼容问题。 Node环境 这可能是很多前端开发者曾经梦想过的功能，在WEB界面中使用Node.js提供的强大API，这意味着你在WEB页面直接可以操作文件，调用系统API，甚至操作数据库。当然，除了完整的Node API，你还可以使用额外的几十万个npm模块。 跨域 你可以直接使用Node提供的request模块进行网络请求，这意味着你无需再被跨域所困扰。 强大的扩展性 借助node-ffi，为应用程序提供强大的扩展性（后面的章节会详细介绍）。 2.3 谁在用Electron 现在市面上已经有非常多的应用在使用electron进行开发了，包括我们熟悉的VS Code客户端、GitHub客户端、Atom客户端等等。印象很深的，去年迅雷在发布迅雷X10.1时的文案： 从迅雷X 10.1版本开始，我们采用Electron软件框架完全重写了迅雷主界面。使用新框架的迅雷X可以完美支持2K、4K等高清显示屏，界面中的文字渲染也更加清晰锐利。从技术层面来说，新框架的界面绘制、事件处理等方面比老框架更加灵活高效，因此界面的流畅度也显著优于老框架的迅雷。至于具体提升有多大？您一试便知。 你可以打开VS Code，点击【帮助】【切换开发人员工具】来VS Code客户端的界面。 三、Electron运行原理 Electron 结合了 Chromium、Node.js 和用于调用操作系统本地功能的API。 3.1 ChromiumChromium是Google为发展Chrome浏览器而启动的开源项目，Chromium相当于Chrome的工程版或称实验版，新功能会率先在Chromium上实现，待验证后才会应用在Chrome上，故Chrome的功能会相对落后但较稳定。 Chromium为Electron提供强大的UI能力，可以在不考虑兼容性的情况下开发界面。 3.2 Node.jsNode.js是一个让JavaScript运行在服务端的开发平台，Node使用事件驱动，非阻塞I/O模型而得以轻量和高效。 单单靠Chromium是不能具备直接操作原生GUI能力的，Electron内集成了Nodejs，这让其在开发界面的同时也有了操作系统底层API的能力，Nodejs 中常用的 Path、fs、Crypto 等模块在 Electron 可以直接使用。 3.3 系统API为了提供原生系统的GUI支持，Electron内置了原生应用程序接口，对调用一些系统功能，如调用系统通知、打开系统文件夹提供支持。 在开发模式上，Electron在调用系统API和绘制界面上是分离开发的，下面我们来看看Electron关于进程如何划分。 3.4 主进程Electron区分了两种进程：主进程和渲染进程，两者各自负责自己的职能。 Electron 运行package.json的 main 脚本的进程被称为主进程。一个 Electron 应用总是有且只有一个主进程。 职责: 创建渲染进程（可多个） 控制了应用生命周期（启动、退出APP以及对APP做一些事件监听） 调用系统底层功能、调用原生资源 可调用的API: Node.js API Electron提供的主进程API（包括一些系统功能和Electron附加功能） 3.5 渲染进程由于 Electron 使用了 Chromium 来展示 web 页面，所以 Chromium 的多进程架构也被使用到。 每个Electron 中的 web页面运行在它自己的渲染进程中。 主进程使用 BrowserWindow 实例创建页面。 每个 BrowserWindow 实例都在自己的渲染进程里运行页面。 当一个 BrowserWindow 实例被销毁后，相应的渲染进程也会被终止。 你可以把渲染进程想像成一个浏览器窗口，它能存在多个并且相互独立，不过和浏览器不同的是，它能调用Node API。 职责: 用HTML和CSS渲染界面 用JavaScript做一些界面交互 可调用的API: DOM API Node.js API Electron提供的渲染进程API 四、Electron基础4.1 Electron API在上面的章节我们提到，渲染进和主进程分别可调用的Electron API。所有Electron的API都被指派给一种进程类型。 许多API只能被用于主进程中，有些API又只能被用于渲染进程，又有一些主进程和渲染进程中都可以使用。 你可以通过如下方式获取Electron API const &#123; BrowserWindow, ... &#125; = require('electron') 下面是一些常用的Electron API： 在后面的章节我们会选择其中常用的模块进行详细介绍。 4.2 使用 Node.js 的 API 你可以同时在Electron的主进程和渲染进程使用Node.js API，)所有在Node.js可以使用的API，在Electron中同样可以使用。 import &#123;shell&#125; from 'electron';import os from 'os';document.getElementById('btn').addEventListener('click', () =&gt; &#123; shell.showItemInFolder(os.homedir());&#125;) 有一个非常重要的提示: 原生Node.js模块 (即指，需要编译源码过后才能被使用的模块) 需要在编译后才能和Electron一起使用。 4.3 进程通信主进程和渲染进程虽然拥有不同的职责，然是他们也需要相互协作，互相通讯。 例如：在web页面管理原生GUI资源是很危险的，会很容易泄露资源。所以在web页面，不允许直接调用原生GUI相关的API。渲染进程如果想要进行原生的GUI操作，就必须和主进程通讯，请求主进程来完成这些操作。 4.4 渲染进程向主进程通信ipcRenderer 是一个 EventEmitter 的实例。 你可以使用它提供的一些方法从渲染进程发送同步或异步的消息到主进程。 也可以接收主进程回复的消息。 在渲染进程引入ipcRenderer： import &#123; ipcRenderer &#125; from 'electron'; 异步发送： 通过 channel 发送同步消息到主进程，可以携带任意参数。 在内部，参数会被序列化为 JSON，因此参数对象上的函数和原型链不会被发送。 ipcRenderer.send('sync-render', '我是来自渲染进程的异步消息'); 同步发送： const msg = ipcRenderer.sendSync('async-render', '我是来自渲染进程的同步消息'); 注意: 发送同步消息将会阻塞整个渲染进程，直到收到主进程的响应。 主进程监听消息： ipcMain模块是EventEmitter类的一个实例。 当在主进程中使用时，它处理从渲染器进程（网页）发送出来的异步和同步信息。 从渲染器进程发送的消息将被发送到该模块。 ipcMain.on：监听 channel，当接收到新的消息时 listener 会以 listener(event, args...) 的形式被调用。 ipcMain.on('sync-render', (event, data) =&gt; &#123; console.log(data);&#125;); 4.5 主进程向渲染进程通信https://imweb.io/topic/5b13a663d4c96b9b1b4c4e9c 在主进程中可以通过BrowserWindow的webContents向渲染进程发送消息，所以，在发送消息前你必须先找到对应渲染进程的BrowserWindow对象。： const mainWindow = BrowserWindow.fromId(global.mainId); mainWindow.webContents.send('main-msg', `ConardLi]`) 根据消息来源发送： 在ipcMain接受消息的回调函数中，通过第一个参数event的属性sender可以拿到消息来源渲染进程的webContents对象，我们可以直接用此对象回应消息。 ipcMain.on('sync-render', (event, data) =&gt; &#123; console.log(data); event.sender.send('main-msg', '主进程收到了渲染进程的【异步】消息！')&#125;); 渲染进程监听： ipcRenderer.on:监听 channel, 当新消息到达，将通过listener(event, args...)调用 listener。 ipcRenderer.on('main-msg', (event, msg) =&gt; &#123; console.log(msg);&#125;) 4.6 通信原理ipcMain 和 ipcRenderer 都是 EventEmitter 类的一个实例。EventEmitter 类是 NodeJS 事件的基础，它由 NodeJS 中的 events 模块导出。 EventEmitter 的核心就是事件触发与事件监听器功能的封装。它实现了事件模型需要的接口， 包括 addListener，removeListener, emit 及其它工具方法. 同原生 JavaScript 事件类似， 采用了发布/订阅(观察者)的方式， 使用内部 _events 列表来记录注册的事件处理器。 我们通过 ipcMain和ipcRenderer 的 on、send 进行监听和发送消息都是 EventEmitter 定义的相关接口。 4.7 remoteremote 模块为渲染进程（web页面）和主进程通信（IPC）提供了一种简单方法。 使用 remote 模块, 你可以调用 main 进程对象的方法, 而不必显式发送进程间消息, 类似于 Java 的 RMI 。 import &#123; remote &#125; from 'electron';remote.dialog.showErrorBox('主进程才有的dialog模块', '我是使用remote调用的') 但实际上，我们在调用远程对象的方法、函数或者通过远程构造函数创建一个新的对象，实际上都是在发送一个同步的进程间消息。 在上面通过 remote 模块调用 dialog 的例子里。我们在渲染进程中创建的 dialog 对象其实并不在我们的渲染进程中，它只是让主进程创建了一个 dialog 对象，并返回了这个相对应的远程对象给了渲染进程。 4.8 渲染进程间通信Electron并没有提供渲染进程之间相互通信的方式，我们可以在主进程中建立一个消息中转站。 渲染进程之间通信首先发送消息到主进程，主进程的中转站接受到消息后根据条件进行分发。 4.9 渲染进程数据共享在两个渲染进程间共享数据最简单的方法是使用浏览器中已经实现的HTML5 API。 其中比较好的方案是用Storage API， localStorage，sessionStorage 或者 IndexedDB。 就像在浏览器中使用一样，这种存储相当于在应用程序中永久存储了一部分数据。有时你并不需要这样的存储，只需要在当前应用程序的生命周期内进行一些数据的共享。这时你可以用 Electron 内的 IPC 机制实现。 将数据存在主进程的某个全局变量中，然后在多个渲染进程中使用 remote 模块来访问它。 在主进程中初始化全局变量： global.mainId = ...;global.device = &#123;...&#125;;global.__dirname = __dirname;global.myField = &#123; name: 'ConardLi' &#125;; 在渲染进程中读取： import &#123; ipcRenderer, remote &#125; from 'electron';const &#123; getGlobal &#125; = remote;const mainId = getGlobal('mainId')const dirname = getGlobal('__dirname')const deviecMac = getGlobal('device').mac; 在渲染进程中改变： getGlobal('myField').name = 'code秘密花园'; 多个渲染进程共享同一个主进程的全局变量，这样即可达到渲染进程数据共享和传递的效果。 五、窗口5.1 BrowserWindow主进程模块BrowserWindow用于创建和控制浏览器窗口。 mainWindow = new BrowserWindow(&#123; width: 1000, height: 800, // ...&#125;);mainWindow.loadURL('http://www.conardli.top/'); 你可以在这里查看它所有的构造参数。 5.2 无框窗口 无框窗口是没有镶边的窗口，窗口的部分（如工具栏）不属于网页的一部分。 在BrowserWindow的构造参数中，将frame设置为false可以指定窗口为无边框窗口，将工具栏隐藏后，就会产生两个问题： 1.窗口控制按钮（最小化、全屏、关闭按钮）会被隐藏 2.无法拖拽移动窗口 可以通过指定titleBarStyle选项来再将工具栏按钮显示出来，将其设置为hidden表示返回一个隐藏标题栏的全尺寸内容窗口，在左上角仍然有标准的窗口控制按钮。 new BrowserWindow(&#123; width: 200, height: 200, titleBarStyle: 'hidden', frame: false &#125;); 5.3 窗口拖拽默认情况下, 无边框窗口是不可拖拽的。我们可以在界面中通过CSS属性-webkit-app-region: drag手动制定拖拽区域。 在无框窗口中, 拖动行为可能与选择文本冲突，可以通过设定-webkit-user-select: none;禁用文本选择： .header &#123; -webkit-user-select: none; -webkit-app-region: drag;&#125; 相反的，在可拖拽区域内部设置 -webkit-app-region: no-drag则可以指定特定不可拖拽区域。 5.4 透明窗口通过将transparent选项设置为true, 还可以使无框窗口透明: new BrowserWindow(&#123; transparent: true, frame: false &#125;); 5.5 Webview使用 webview 标签在Electron 应用中嵌入 “外来” 内容。外来内容包含在 webview 容器中。 应用中的嵌入页面可以控制外来内容的布局和重绘。 与 iframe 不同, webview 在与应用程序不同的进程中运行。它与您的网页没有相同的权限, 应用程序和嵌入内容之间的所有交互都将是异步的。 六、对话框dialog 模块提供了api来展示原生的系统对话框，例如打开文件框，alert框，所以web应用可以给用户带来跟系统应用相同的体验。 注意：dialog是主进程模块，想要在渲染进程调用可以使用remote 6.1 错误提示dialog.showErrorBox用于显示一个显示错误消息的模态对话框。 remote.dialog.showErrorBox('错误', '这是一个错误弹框！') 6.2 对话框dialog.showErrorBox用于调用系统对话框，可以为指定几种不同的类型： “none“, “info“, “error“, “question“ 或者 “warning“。 在 Windows 上, “question” 与”info”显示相同的图标, 除非你使用了 “icon” 选项设置图标。 在 macOS 上, “warning” 和 “error” 显示相同的警告图标 remote.dialog.showMessageBox(&#123; type: 'info', title: '提示信息', message: '这是一个对话弹框！', buttons: ['确定', '取消']&#125;, (index) =&gt; &#123; this.setState(&#123; dialogMessage: `【你点击了$&#123;index ? '取消' : '确定'&#125;！！】` &#125;)&#125;) 6.3 文件框dialog.showOpenDialog用于打开或选择系统目录。 remote.dialog.showOpenDialog(&#123; properties: ['openDirectory', 'openFile']&#125;, (data) =&gt; &#123; this.setState(&#123; filePath: `【选择路径：$&#123;data[0]&#125;】 ` &#125;)&#125;) 6.4 信息框这里推荐直接使用HTML5 API，它只能在渲染器进程中使用。 let options = &#123; title: '信息框标题', body: '我是一条信息～～～',&#125;let myNotification = new window.Notification(options.title, options)myNotification.onclick = () =&gt; &#123; this.setState(&#123; message: '【你点击了信息框！！】' &#125;)&#125; 七、系统7.1 获取系统信息 通过remote获取到主进程的process对象，可以获取到当前应用的各个版本信息： process.versions.electron：electron版本信息 process.versions.chrome：chrome版本信息 process.versions.node：node版本信息 process.versions.v8：v8版本信息 获取当前应用根目录： remote.app.getAppPath() 使用node的os模块获取当前系统根目录： os.homedir(); 7.2 复制粘贴 Electron提供的clipboard在渲染进程和主进程都可使用，用于在系统剪贴板上执行复制和粘贴操作。 以纯文本的形式写入剪贴板： clipboard.writeText(text[, type]) 以纯文本的形式获取剪贴板的内容： clipboard.readText([type]) 7.3 截图desktopCapturer用于从桌面捕获音频和视频的媒体源的信息。它只能在渲染进程中被调用。 下面的代码是一个获取屏幕截图并保存的实例： getImg = () =&gt; &#123; this.setState(&#123; imgMsg: '正在截取屏幕...' &#125;) const thumbSize = this.determineScreenShotSize() let options = &#123; types: ['screen'], thumbnailSize: thumbSize &#125; desktopCapturer.getSources(options, (error, sources) =&gt; &#123; if (error) return console.log(error) sources.forEach((source) =&gt; &#123; if (source.name === 'Entire screen' || source.name === 'Screen 1') &#123; const screenshotPath = path.join(os.tmpdir(), 'screenshot.png') fs.writeFile(screenshotPath, source.thumbnail.toPNG(), (error) =&gt; &#123; if (error) return console.log(error) shell.openExternal(`file://$&#123;screenshotPath&#125;`) this.setState(&#123; imgMsg: `截图保存到: $&#123;screenshotPath&#125;` &#125;) &#125;) &#125; &#125;) &#125;)&#125;determineScreenShotSize = () =&gt; &#123; const screenSize = screen.getPrimaryDisplay().workAreaSize const maxDimension = Math.max(screenSize.width, screenSize.height) return &#123; width: maxDimension * window.devicePixelRatio, height: maxDimension * window.devicePixelRatio &#125;&#125; 八、菜单应用程序的菜单可以帮助我们快捷的到达某一功能，而不借助客户端的界面资源，一般菜单分为两种： 应用程序菜单：位于应用程序顶部，在全局范围内都能使用 上下文菜单：可自定义任意页面显示，自定义调用，如右键菜单 Electron为我们提供了Menu模块用于创建本机应用程序菜单和上下文菜单，它是一个主进程模块。 你可以通过Menu的静态方法buildFromTemplate(template)，使用自定义菜单模版来构造一个菜单对象。 template是一个MenuItem的数组，我们来看看MenuItem的几个重要参数： label：菜单显示的文字 click：点击菜单后的事件处理函数 role：系统预定义的菜单，例如copy(复制)、paste(粘贴)、minimize(最小化)… enabled：指示是否启用该项目，此属性可以动态更改 submenu：子菜单，也是一个MenuItem的数组 推荐：最好指定role与标准角色相匹配的任何菜单项，而不是尝试手动实现click函数中的行为。内置role行为将提供最佳的本地体验。 下面的实例是一个简单的额菜单template。 const template = [ &#123; label: '文件', submenu: [ &#123; label: '新建文件', click: function () &#123; dialog.showMessageBox(&#123; type: 'info', message: '嘿!', detail: '你点击了新建文件！', &#125;) &#125; &#125; ] &#125;, &#123; label: '编辑', submenu: [&#123; label: '剪切', role: 'cut' &#125;, &#123; label: '复制', role: 'copy' &#125;, &#123; label: '粘贴', role: 'paste' &#125;] &#125;, &#123; label: '最小化', role: 'minimize' &#125;] 8.1 应用程序菜单使用Menu的静态方法setApplicationMenu，可创建一个应用程序菜单，在 Windows 和 Linux 上，menu将被设置为每个窗口的顶层菜单。 注意：必须在模块ready事件后调用此 API app。 我们可以根据应用程序不同的的生命周期，不同的系统对菜单做不同的处理。 app.on('ready', function () &#123; const menu = Menu.buildFromTemplate(template) Menu.setApplicationMenu(menu)&#125;)app.on('browser-window-created', function () &#123; let reopenMenuItem = findReopenMenuItem() if (reopenMenuItem) reopenMenuItem.enabled = false&#125;)app.on('window-all-closed', function () &#123; let reopenMenuItem = findReopenMenuItem() if (reopenMenuItem) reopenMenuItem.enabled = true&#125;)if (process.platform === 'win32') &#123; const helpMenu = template[template.length - 1].submenu addUpdateMenuItems(helpMenu, 0)&#125; 8.2 上下文菜单使用Menu的实例方法menu.popup可自定义弹出上下文菜单。 let m = Menu.buildFromTemplate(template)document.getElementById('menuDemoContainer').addEventListener('contextmenu', (e) =&gt; &#123; e.preventDefault() m.popup(&#123; window: remote.getCurrentWindow() &#125;)&#125;) 8.3 快捷键在菜单选项中，我们可以指定一个accelerator属性来指定操作的快捷键： &#123; label: '最小化', accelerator: 'CmdOrCtrl+M', role: 'minimize'&#125; 另外，我们还可以使用globalShortcut来注册全局快捷键。 globalShortcut.register('CommandOrControl+N', () =&gt; &#123; dialog.showMessageBox(&#123; type: 'info', message: '嘿!', detail: '你触发了手动注册的快捷键.', &#125;)&#125;) CommandOrControl代表在macOS上为Command键，以及在Linux和Windows上为Control键。 九、打印很多情况下程序中使用的打印都是用户无感知的。并且想要灵活的控制打印内容，往往需要借助打印机给我们提供的api再进行开发，这种开发方式非常繁琐，并且开发难度较大。第一次在业务中用到Electron其实就是用到它的打印功能，这里就多介绍一些。 Electron提供的打印api可以非常灵活的控制打印设置的显示，并且可以通过html来书写打印内容。Electron提供了两种方式进行打印，一种是直接调用打印机打印，一种是打印到pdf。 并且有两种对象可以调用打印： 通过window的webcontent对象，使用此种方式需要单独开出一个打印的窗口，可以将该窗口隐藏，但是通信调用相对复杂。 使用页面的webview元素调用打印，可以将webview隐藏在调用的页面中，通信方式比较简单。 上面两种方式同时拥有print和printToPdf方法。 9.1 调用系统打印contents.print([options], [callback])； 打印配置(options)中只有简单的三个配置： silent：打印时是否不展示打印配置（是否静默打印） printBackground：是否打印背景 deviceName：打印机设备名称 首先要将我们使用的打印机名称配置好，并且要在调用打印前首先要判断打印机是否可用。 使用webContents的getPrinters方法可获取当前设备已经配置的打印机列表，注意配置过不是可用，只是在此设备上安装过驱动。 通过getPrinters获取到的打印机对象：https://electronjs.org/docs/api/structures/printer-info 我们这里只管关心两个，name和status，status为0时表示打印机可用。 print的第二个参数callback是用于判断打印任务是否发出的回调，而不是打印任务完成后的回调。所以一般打印任务发出，回调函数即会调用并返回参数true。这个回调并不能判断打印是否真的成功了。 if (this.state.curretnPrinter) &#123; mainWindow.webContents.print(&#123; silent: silent, printBackground: true, deviceName: this.state.curretnPrinter &#125;, () =&gt; &#123; &#125;)&#125; else &#123; remote.dialog.showErrorBox('错误', '请先选择一个打印机！')&#125; 9.2 打印到PDFprintToPdf的用法基本和print相同，但是print的配置项非常少，而printToPdf则扩展了很多属性。这里翻了一下源码发现还有很多没有被贴进api的，大概有三十几个包括可以对打印的margin，打印页眉页脚等进行配置。 contents.printToPDF(options, callback) callback函数在打印失败或打印成功后调用，可获取打印失败信息或包含PDF数据的缓冲区。 const pdfPath = path.join(os.tmpdir(), 'webviewPrint.pdf');const webview = document.getElementById('printWebview');const renderHtml = '我是被临时插入webview的内容...';webview.executeJavaScript('document.documentElement.innerHTML =`' + renderHtml + '`;');webview.printToPDF(&#123;&#125;, (err, data) =&gt; &#123; console.log(err, data); fs.writeFile(pdfPath, data, (error) =&gt; &#123; if (error) throw error shell.openExternal(`file://$&#123;pdfPath&#125;`) this.setState(&#123; webviewPdfPath: pdfPath &#125;) &#125;);&#125;); 这个例子中的打印是使用webview完成的，通过调用executeJavaScript方法可动态向webview插入打印内容。 9.3 两种打印方案的选择上面提到，使用webview和webcontent都可以调用打印功能，使用webcontent打印，首先要有一个打印窗口，这个窗口不能随时打印随时创建，比较耗费性能。可以将它在程序运行时启动好，并做好事件监听。 此过程需和调用打印的进行做好通信，大致过程如下： 可见通信非常繁琐，使用webview进行打印可实现同样的效果但是通信方式会变得简单，因为渲染进程和webview通信不需要经过主进程，通过如下方式即可： const webview = document.querySelector('webview')webview.addEventListener('ipc-message', (event) =&gt; &#123; console.log(event.channel)&#125;)webview.send('ping')；const &#123;ipcRenderer&#125; = require('electron')ipcRenderer.on('ping', () =&gt; &#123; ipcRenderer.sendToHost('pong')&#125;) 之前专门为ELectron打印写过一个DEMO：electron-print-demo有兴趣可以clone下来看一下。 9.4 打印功能封装下面是几个针对常用打印功能的工具函数封装。 /** * 获取系统打印机列表 */export function getPrinters() &#123; let printers = []; try &#123; const contents = remote.getCurrentWindow().webContents; printers = contents.getPrinters(); &#125; catch (e) &#123; console.error('getPrintersError', e); &#125; return printers;&#125;/** * 获取系统默认打印机 */export function getDefaultPrinter() &#123; return getPrinters().find(element =&gt; element.isDefault);&#125;/** * 检测是否安装了某个打印驱动 */export function checkDriver(driverMame) &#123; return getPrinters().find(element =&gt; (element.options[\"printer-make-and-model\"] || '').includes(driverMame));&#125;/** * 根据打印机名称获取打印机对象 */export function getPrinterByName(name) &#123; return getPrinters().find(element =&gt; element.name === name);&#125; 十、程序保护https://segmentfault.com/a/1190000007503495 10.1 崩溃崩溃监控是每个客户端程序必备的保护功能，当程序崩溃时我们一般期望做到两件事： 1.上传崩溃日志，及时报警 2.监控程序崩溃，提示用户重启程序 electron为我们提供给了crashReporter来帮助我们记录崩溃日志，我们可以通过crashReporter.start来创建一个崩溃报告器： const &#123; crashReporter &#125; = require('electron')crashReporter.start(&#123; productName: 'YourName', companyName: 'YourCompany', submitURL: 'https://your-domain.com/url-to-submit', uploadToServer: true&#125;) 当程序发生崩溃时，崩溃报日志将被储存在临时文件夹中名为YourName Crashes的文件文件夹中。submitURL用于指定你的崩溃日志上传服务器。 在启动崩溃报告器之前，您可以通过调用app.setPath(&#39;temp&#39;, &#39;my/custom/temp&#39;)API来自定义这些临时文件的保存路径。你还可以通过crashReporter.getLastCrashReport()来获取上次崩溃报告的日期和ID。 我们可以通过webContents的crashed来监听渲染进程的崩溃，另外经测试有些主进程的崩溃也会触发该事件。所以我们可以根据主window是否被销毁来判断进行不同的重启逻辑，下面使整个崩溃监控的逻辑： import &#123; BrowserWindow, crashReporter, dialog &#125; from 'electron';// 开启进程崩溃记录crashReporter.start(&#123; productName: 'electron-react', companyName: 'ConardLi', submitURL: 'http://xxx.com', // 上传崩溃日志的接口 uploadToServer: false&#125;);function reloadWindow(mainWin) &#123; if (mainWin.isDestroyed()) &#123; app.relaunch(); app.exit(0); &#125; else &#123; // 销毁其他窗口 BrowserWindow.getAllWindows().forEach((w) =&gt; &#123; if (w.id !== mainWin.id) w.destroy(); &#125;); const options = &#123; type: 'info', title: '渲染器进程崩溃', message: '这个进程已经崩溃.', buttons: ['重载', '关闭'] &#125; dialog.showMessageBox(options, (index) =&gt; &#123; if (index === 0) mainWin.reload(); else mainWin.close(); &#125;) &#125;&#125;export default function () &#123; const mainWindow = BrowserWindow.fromId(global.mainId); mainWindow.webContents.on('crashed', () =&gt; &#123; const errorMessage = crashReporter.getLastCrashReport(); console.error('程序崩溃了！', errorMessage); // 可单独上传日志 reloadWindow(mainWindow); &#125;);&#125; 10.2 最小化到托盘有的时候我们并不想让用户通过点关闭按钮的时候就关闭程序，而是把程序最小化到托盘，在托盘上做真正的退出操作。 首先要监听窗口的关闭事件，阻止用户关闭操作的默认行为，将窗口隐藏。 function checkQuit(mainWindow, event) &#123; const options = &#123; type: 'info', title: '关闭确认', message: '确认要最小化程序到托盘吗？', buttons: ['确认', '关闭程序'] &#125;; dialog.showMessageBox(options, index =&gt; &#123; if (index === 0) &#123; event.preventDefault(); mainWindow.hide(); &#125; else &#123; mainWindow = null; app.exit(0); &#125; &#125;);&#125;function handleQuit() &#123; const mainWindow = BrowserWindow.fromId(global.mainId); mainWindow.on('close', event =&gt; &#123; event.preventDefault(); checkQuit(mainWindow, event); &#125;);&#125; 这时程序就再也找不到了，任务托盘中也没有我们的程序，所以我们要先创建好任务托盘，并做好事件监听。 windows平台使用ico文件可以达到更好的效果 export default function createTray() &#123; const mainWindow = BrowserWindow.fromId(global.mainId); const iconName = process.platform === 'win32' ? 'icon.ico' : 'icon.png' tray = new Tray(path.join(global.__dirname, iconName)); const contextMenu = Menu.buildFromTemplate([ &#123; label: '显示主界面', click: () =&gt; &#123; mainWindow.show(); mainWindow.setSkipTaskbar(false); &#125; &#125;, &#123; label: '退出', click: () =&gt; &#123; mainWindow.destroy(); app.quit(); &#125; &#125;, ]) tray.setToolTip('electron-react'); tray.setContextMenu(contextMenu);&#125; 十一、扩展能力 在很多情况下，你的应用程序要和外部设备进行交互，一般情况下厂商会为你提供硬件设备的开发包，这些开发包基本上都是通过C++ 编写，在使用electron开发的情况下，我们并不具备直接调用C++代码的能力，我们可以利用node-ffi来实现这一功能。 node-ffi提供了一组强大的工具，用于在Node.js环境中使用纯JavaScript调用动态链接库接口。它可以用来为库构建接口绑定，而不需要使用任何C++代码。 注意node-ffi并不能直接调用C++代码，你需要将C++代码编译为动态链接库：在 Windows下是 Dll ，在 Mac OS下是 dylib ，Linux 是 so 。 node-ffi 加载 Library是有限制的，只能处理 C风格的 Library。 下面是一个简单的实例： const ffi = require('ffi');const ref = require('ref');const SHORT_CODE = ref.refType('short');const DLL = new ffi.Library('test.dll', &#123; Test_CPP_Method: ['int', ['string',SHORT_CODE]], &#125;)testCppMethod(str: String, num: number): void &#123; try &#123; const result: any = DLL.Test_CPP_Method(str, num); return result; &#125; catch (error) &#123; console.log('调用失败～',error); &#125;&#125;this.testCppMethod('ConardLi',123); 上面的代码中，我们用ffi包装C++接口生成的动态链接库test.dll，并使用ref进行一些类型映射。 使用JavaScript调用这些映射方法时，推荐使用TypeScript来约定参数类型，因为弱类型的JavaScript在调用强类型语言的接口时可能会带来意想不到的风险。 借助这一能力，前端开发工程师也可以在IOT领域一展身手了😎～ 十二、环境选择一般情况下，我们的应用程序可能运行在多套环境下（production、beta、uat、moke、development…），不同的开发环境可能对应不同的后端接口或者其他配置，我们可以在客户端程序中内置一个简单的环境选择功能来帮助我们更高效的开发。 具体策略如下： 在开发环境中，我们直接进入环境选择页面，读取到选择的环境后进行响应的重定向操作 在菜单保留环境选择入口，以便在开发过程中切换 const envList = [\"moke\", \"beta\", \"development\", \"production\"];exports.envList = envList;const urlBeta = 'https://wwww.xxx-beta.com';const urlDev = 'https://wwww.xxx-dev.com';const urlProp = 'https://wwww.xxx-prop.com';const urlMoke = 'https://wwww.xxx-moke.com';const path = require('path');const pkg = require(path.resolve(global.__dirname, 'package.json'));const build = pkg['build-config'];exports.handleEnv = &#123; build, currentEnv: 'moke', setEnv: function (env) &#123; this.currentEnv = env &#125;, getUrl: function () &#123; console.log('env:', build.env); if (build.env === 'production' || this.currentEnv === 'production') &#123; return urlProp; &#125; else if (this.currentEnv === 'moke') &#123; return urlMoke; &#125; else if (this.currentEnv === 'development') &#123; return urlDev; &#125; else if (this.currentEnv === \"beta\") &#123; return urlBeta; &#125; &#125;, isDebugger: function () &#123; return build.env === 'development' &#125;&#125; 十三、打包最后也是最重要的一步，将写好的代码打包成可运行的.app或.exe可执行文件。 这里我把打包氛围两部分来做，渲染进程打包和主进程打包。 13.1 渲染进程打包和升级一般情况下，我们的大部分业务逻辑代码是在渲染进程完成的，在大部分情况下我们仅仅需要对渲染进程进行更新和升级而不需要改动主进程代码，我们渲染进程的打包实际上和一般的web项目打包没有太大差别，使用webpack打包即可。 这里我说说渲染进程单独打包的好处： 打包完成的html和js文件，我们一般要上传到我们的前端静态资源服务器下，然后告知服务端我们的渲染进程有代码更新，这里可以说成渲染进程单独的升级。 注意，和壳的升级不同，渲染进程的升级仅仅是静态资源服务器上html和js文件的更新，而不需要重新下载更新客户端，这样我们每次启动程序的时候检测到离线包有更新，即可直接刷新读取最新版本的静态资源文件，即使在程序运行过程中要强制更新，我们的程序只需要强制刷新页面读取最新的静态资源即可，这样的升级对用户是非常友好的。 这里注意，一旦我们这样配置，就意味着渲染进程和主进程打包升级的完全分离，我们在启动主窗口时读取的文件就不应该再是本地文件，而是打包完成后放在静态资源服务器的文件。 为了方便开发，这里我们可以区分本地和线上加载不同的文件： function getVersion (mac,current)&#123; // 根据设备mac和当前版本获取最新版本&#125;export default function () &#123; if (build.env === 'production') &#123; const version = getVersion (mac,current); return 'https://www.xxxserver.html/electron-react/index_'+version+'.html'; &#125; return url.format(&#123; protocol: 'file:', pathname: path.join(__dirname, 'env/environment.html'), slashes: true, query: &#123; debugger: build.env === \"development\" &#125; &#125;);&#125; 具体的webpack配置这里就不再贴出，可以到我的github electron-react的/scripts目录下查看。 这里需要注意，在开发环境下我们可以结合webpack的devServer和electron命令来启动app： devServer: &#123; contentBase: './assets/', historyApiFallback: true, hot: true, port: PORT, noInfo: false, stats: &#123; colors: true, &#125;, setup() &#123; spawn( 'electron', ['.'], &#123; shell: true, stdio: 'inherit', &#125; ) .on('close', () =&gt; process.exit(0)) .on('error', e =&gt; console.error(e)); &#125;,&#125;,//... 13.2 主进程打包 主进程，即将整个程序打包成可运行的客户端程序，常用的打包方案一般有两种，electron-packager和electron-builder。 electron-packager在打包配置上我觉得有些繁琐，而且它只能将应用直接打包为可执行程序。 这里我推荐使用electron-builder，它不仅拥有方便的配置 protocol 的功能、内置的 Auto Update、简单的配置 package.json 便能完成整个打包工作，用户体验非常不错。而且electron-builder不仅能直接将应用打包成exe app等可执行程序，还能打包成msi dmg等安装包格式。 你可以在package.json方便的进行各种配置： \"build\": &#123; \"productName\": \"electron-react\", // app中文名称 \"appId\": \"electron-react\",// app标识 \"directories\": &#123; // 打包后输出的文件夹 \"buildResources\": \"resources\", \"output\": \"dist/\" &#125; \"files\": [ // 打包后依然保留的源文件 \"main_process/\", \"render_process/\", ], \"mac\": &#123; // mac打包配置 \"target\": \"dmg\", \"icon\": \"icon.ico\" &#125;, \"win\": &#123; // windows打包配置 \"target\": \"nsis\", \"icon\": \"icon.ico\" &#125;, \"dmg\": &#123; // dmg文件打包配置 \"artifactName\": \"electron_react.dmg\", \"contents\": [ &#123; \"type\": \"link\", \"path\": \"/Applications\", \"x\": 410, \"y\": 150 &#125;, &#123; \"type\": \"file\", \"x\": 130, \"y\": 150 &#125; ] &#125;, \"nsis\": &#123; // nsis文件打包配置 \"oneClick\": false, \"allowToChangeInstallationDirectory\": true, \"shortcutName\": \"electron-react\" &#125;,&#125; 执行electron-builder打包命令时，可指定参数进行打包。 --mac, -m, -o, --macos macOS打包--linux, -l Linux打包--win, -w, --windows Windows打包--mwl 同时为macOS，Windows和Linux打包--x64 x64 (64位安装包)--ia32 ia32(32位安装包) 关于主进程的更新你可以使用electron-builder自带的Auto Update模块，在electron-react也实现了手动更新的模块，由于篇幅原因这里就不再赘述，如果有兴趣可以到我的github查看main下的update模块。 13.3 打包优化electron-builder打包出来的App要比相同功能的原生客户端应用体积大很多，即使是空的应用，体积也要在100mb以上。原因有很多： 第一点；为了达到跨平台的效果，每个Electron应用都包含了整个V8引擎和Chromium内核。 第二点：打包时会将整个node_modules打包进去，大家都知道一个应用的node_module体积是非常庞大的，这也是使得Electron应用打包后的体积较大的原因。 第一点我们无法改变，我们可以从第二点对应用体积进行优化：Electron在打包时只会将denpendencies的依赖打包进去，而不会将 devDependencies 中的依赖进行打包。所以我们应尽可能的减少denpendencies中的依赖。在上面的进程中，我们使用webpack对渲染进程进行打包，所以渲染进程的依赖全部都可以移入devDependencies。 另外，我们还可以使用双packajson.json的方式来进行优化，把只在开发环境中使用到的依赖放在整个项目的根目录的package.json下，将与平台相关的或者运行时需要的依赖装在app目录下。具体详见two-package-structure。 参考 https://electronjs.org/docs http://jlord.us/essential-electron/ https://imweb.io/topic/5b9f500cc2ec8e6772f34d79 https://www.jianshu.com/p/1ece6fd7a80c https://zhuanlan.zhihu.com/p/52991793 本项目源码地址：https://github.com/ConardLi/electron-react 小结希望你阅读本篇文章后可以达到以下几点： 了解Electron的基本运行原理 掌握Electron开发的核心基础知识 了解Electron关于弹框、打印、保护、打包等功能的基本使用 文中如有错误，欢迎在评论区指正，如果这篇文章帮助到了你，欢迎点赞和关注。","categories":[],"tags":[{"name":"electron","slug":"electron","permalink":"www.conardli.top/tags/electron/"},{"name":"多端开发","slug":"多端开发","permalink":"www.conardli.top/tags/多端开发/"}]},{"title":"【JS进阶】你真的掌握变量和类型了吗","slug":"【JS进阶】你真的掌握变量和类型了吗","date":"2019-05-28T03:06:11.000Z","updated":"2019-06-01T10:23:39.856Z","comments":true,"path":"2019/05/28/【JS进阶】你真的掌握变量和类型了吗/","link":"","permalink":"www.conardli.top/2019/05/28/【JS进阶】你真的掌握变量和类型了吗/","excerpt":"","text":"导读变量和类型是学习JavaScript最先接触到的东西，但是往往看起来最简单的东西往往还隐藏着很多你不了解、或者容易犯错的知识，比如下面几个问题： JavaScript中的变量在内存中的具体存储形式是什么？ 0.1+0.2为什么不等于0.3?发生小数计算错误的具体原因是什么？ Symbol的特点，以及实际应用场景是什么？ [] == ![]、[undefined] == false为什么等于true?代码中何时会发生隐式类型转换？转换的规则是什么？ 如何精确的判断变量的类型？ 如果你还不能很好的解答上面的问题，那说明你还没有完全掌握这部分的知识，那么请好好阅读下面的文章吧。 本文从底层原理到实际应用详细介绍了JavaScript中的变量和类型相关知识。 一、JavaScript数据类型ECMAScript标准规定了7种数据类型，其把这7种数据类型又分为两种：原始类型和对象类型。 原始类型 Null：只包含一个值：null Undefined：只包含一个值：undefined Boolean：包含两个值：true和false Number：整数或浮点数，还有一些特殊值（-Infinity、+Infinity、NaN） String：一串表示文本值的字符序列 Symbol：一种实例是唯一且不可改变的数据类型 (在es10中加入了第七种原始类型BigInt，现已被最新Chrome支持) 对象类型 Object：自己分一类丝毫不过分，除了常用的Object，Array、Function等都属于特殊的对象 二、为什么区分原始类型和对象类型2.1 不可变性上面所提到的原始类型，在ECMAScript标准中，它们被定义为primitive values，即原始值，代表值本身是不可被改变的。 以字符串为例，我们在调用操作字符串的方法时，没有任何方法是可以直接改变字符串的： var str = 'ConardLi';str.slice(1);str.substr(1);str.trim(1);str.toLowerCase(1);str[0] = 1;console.log(str); // ConardLi 在上面的代码中我们对str调用了几个方法，无一例外，这些方法都在原字符串的基础上产生了一个新字符串，而非直接去改变str，这就印证了字符串的不可变性。 那么，当我们继续调用下面的代码： str += '6'console.log(str); // ConardLi6 你会发现，str的值被改变了，这不就打脸了字符串的不可变性么？其实不然，我们从内存上来理解： 在JavaScript中，每一个变量在内存中都需要一个空间来存储。 内存空间又被分为两种，栈内存与堆内存。 栈内存： 存储的值大小固定 空间较小 可以直接操作其保存的变量，运行效率高 由系统自动分配存储空间 JavaScript中的原始类型的值被直接存储在栈中，在变量定义时，栈就为其分配好了内存空间。 由于栈中的内存空间的大小是固定的，那么注定了存储在栈中的变量就是不可变的。 在上面的代码中，我们执行了str += &#39;6&#39;的操作，实际上是在栈中又开辟了一块内存空间用于存储&#39;ConardLi6&#39;，然后将变量str指向这块空间，所以这并不违背不可变性的特点。 2.2 引用类型堆内存： 存储的值大小不定，可动态调整 空间较大，运行效率低 无法直接操作其内部存储，使用引用地址读取 通过代码进行分配空间 相对于上面具有不可变性的原始类型，我习惯把对象称为引用类型，引用类型的值实际存储在堆内存中，它在栈中只存储了一个固定长度的地址，这个地址指向堆内存中的值。 var obj1 = &#123;name:\"ConardLi\"&#125;var obj2 = &#123;age:18&#125;var obj3 = function()&#123;...&#125;var obj4 = [1,2,3,4,5,6,7,8,9] 由于内存是有限的，这些变量不可能一直在内存中占用资源，这里推荐下这篇文章JavaScript中的垃圾回收和内存泄漏，这里告诉你JavaScript是如何进行垃圾回收以及可能会发生内存泄漏的一些场景。 当然，引用类型就不再具有不可变性了，我们可以轻易的改变它们： obj1.name = \"ConardLi6\";obj2.age = 19;obj4.length = 0;console.log(obj1); //&#123;name:\"ConardLi6\"&#125;console.log(obj2); // &#123;age:19&#125;console.log(obj4); // [] 以数组为例，它的很多方法都可以改变它自身。 pop() 删除数组最后一个元素，如果数组为空，则不改变数组，返回undefined，改变原数组，返回被删除的元素 push()向数组末尾添加一个或多个元素，改变原数组，返回新数组的长度 shift()把数组的第一个元素删除，若空数组，不进行任何操作，返回undefined,改变原数组，返回第一个元素的值 unshift()向数组的开头添加一个或多个元素，改变原数组，返回新数组的长度 reverse()颠倒数组中元素的顺序，改变原数组，返回该数组 sort()对数组元素进行排序，改变原数组，返回该数组 splice()从数组中添加/删除项目，改变原数组，返回被删除的元素 下面我们通过几个操作来对比一下原始类型和引用类型的区别： 2.3 复制当我们把一个变量的值复制到另一个变量上时，原始类型和引用类型的表现是不一样的，先来看看原始类型： var name = 'ConardLi';var name2 = name;name2 = 'code秘密花园';console.log(name); // ConardLi; 内存中有一个变量name，值为ConardLi。我们从变量name复制出一个变量name2，此时在内存中创建了一个块新的空间用于存储ConardLi，虽然两者值是相同的，但是两者指向的内存空间完全不同，这两个变量参与任何操作都互不影响。 复制一个引用类型： var obj = &#123;name:'ConardLi'&#125;;var obj2 = obj;obj2.name = 'code秘密花园';console.log(obj.name); // code秘密花园 当我们复制引用类型的变量时，实际上复制的是栈中存储的地址，所以复制出来的obj2实际上和obj指向的堆中同一个对象。因此，我们改变其中任何一个变量的值，另一个变量都会受到影响，这就是为什么会有深拷贝和浅拷贝的原因。 2.4 比较当我们在对两个变量进行比较时，不同类型的变量的表现是不同的： var name = 'ConardLi';var name2 = 'ConardLi';console.log(name === name2); // truevar obj = &#123;name:'ConardLi'&#125;;var obj2 = &#123;name:'ConardLi'&#125;;console.log(obj === obj2); // false 对于原始类型，比较时会直接比较它们的值，如果值相等，即返回true。 对于引用类型，比较时会比较它们的引用地址，虽然两个变量在堆中存储的对象具有的属性值都是相等的，但是它们被存储在了不同的存储空间，因此比较值为false。 2.5 值传递和引用传递借助下面的例子，我们先来看一看什么是值传递，什么是引用传递： let name = 'ConardLi';function changeValue(name)&#123; name = 'code秘密花园';&#125;changeValue(name);console.log(name); 执行上面的代码，如果最终打印出来的name是&#39;ConardLi&#39;，没有改变，说明函数参数传递的是变量的值，即值传递。如果最终打印的是&#39;code秘密花园&#39;，函数内部的操作可以改变传入的变量，那么说明函数参数传递的是引用，即引用传递。 很明显，上面的执行结果是&#39;ConardLi&#39;，即函数参数仅仅是被传入变量复制给了的一个局部变量，改变这个局部变量不会对外部变量产生影响。 let obj = &#123;name:'ConardLi'&#125;;function changeValue(obj)&#123; obj.name = 'code秘密花园';&#125;changeValue(obj);console.log(obj.name); // code秘密花园 上面的代码可能让你产生疑惑，是不是参数是引用类型就是引用传递呢？ 首先明确一点，ECMAScript中所有的函数的参数都是按值传递的。 同样的，当函数参数是引用类型时，我们同样将参数复制了一个副本到局部变量，只不过复制的这个副本是指向堆内存中的地址而已，我们在函数内部对对象的属性进行操作，实际上和外部变量指向堆内存中的值相同，但是这并不代表着引用传递，下面我们再按一个例子： let obj = &#123;&#125;;function changeValue(obj)&#123; obj.name = 'ConardLi'; obj = &#123;name:'code秘密花园'&#125;;&#125;changeValue(obj);console.log(obj.name); // ConardLi 可见，函数参数传递的并不是变量的引用，而是变量拷贝的副本，当变量是原始类型时，这个副本就是值本身，当变量是引用类型时，这个副本是指向堆内存的地址。所以，再次记住： ECMAScript中所有的函数的参数都是按值传递的。 三、分不清的null和undefined 在原始类型中，有两个类型Null和Undefined，他们都有且仅有一个值，null和undefined，并且他们都代表无和空，我一般这样区分它们： null 表示被赋值过的对象，刻意把一个对象赋值为null，故意表示其为空，不应有值。 所以对象的某个属性值为null是正常的，null转换为数值时值为0。 undefined 表示“缺少值”，即此处应有一个值，但还没有定义， 如果一个对象的某个属性值为undefined，这是不正常的，如obj.name=undefined，我们不应该这样写，应该直接delete obj.name。 undefined转为数值时为NaN(非数字值的特殊值) JavaScript是一门动态类型语言，成员除了表示存在的空值外，还有可能根本就不存在（因为存不存在只在运行期才知道），这就是undefined的意义所在。对于JAVA这种强类型语言，如果有&quot;undefined&quot;这种情况，就会直接编译失败，所以在它不需要一个这样的类型。 四、不太熟的Symbol类型Symbol类型是ES6中新加入的一种原始类型。 每个从Symbol()返回的symbol值都是唯一的。一个symbol值能作为对象属性的标识符；这是该数据类型仅有的目的。 下面来看看Symbol类型具有哪些特性。 4.1 Symbol的特性1.独一无二 直接使用Symbol()创建新的symbol变量，可选用一个字符串用于描述。当参数为对象时，将调用对象的toString()方法。 var sym1 = Symbol(); // Symbol() var sym2 = Symbol('ConardLi'); // Symbol(ConardLi)var sym3 = Symbol('ConardLi'); // Symbol(ConardLi)var sym4 = Symbol(&#123;name:'ConardLi'&#125;); // Symbol([object Object])console.log(sym2 === sym3); // false 我们用两个相同的字符串创建两个Symbol变量，它们是不相等的，可见每个Symbol变量都是独一无二的。 如果我们想创造两个相等的Symbol变量，可以使用Symbol.for(key)。 使用给定的key搜索现有的symbol，如果找到则返回该symbol。否则将使用给定的key在全局symbol注册表中创建一个新的symbol。 var sym1 = Symbol.for('ConardLi');var sym2 = Symbol.for('ConardLi');console.log(sym1 === sym2); // true 2.原始类型 注意是使用Symbol()函数创建symbol变量，并非使用构造函数，使用new操作符会直接报错。 new Symbol(); // Uncaught TypeError: Symbol is not a constructor 我们可以使用typeof运算符判断一个Symbol类型： typeof Symbol() === 'symbol'typeof Symbol('ConardLi') === 'symbol' 3.不可枚举 当使用Symbol作为对象属性时，可以保证对象不会出现重名属性，调用for...in不能将其枚举出来，另外调用Object.getOwnPropertyNames、Object.keys()也不能获取Symbol属性。 可以调用Object.getOwnPropertySymbols()用于专门获取Symbol属性。 var obj = &#123; name:'ConardLi', [Symbol('name2')]:'code秘密花园'&#125;Object.getOwnPropertyNames(obj); // [\"name\"]Object.keys(obj); // [\"name\"]for (var i in obj) &#123; console.log(i); // name&#125;Object.getOwnPropertySymbols(obj) // [Symbol(name)] 4.2 Symbol的应用场景下面是几个Symbol在程序中的应用场景。 应用一：防止XSS 在React的ReactElement对象中，有一个$$typeof属性，它是一个Symbol类型的变量： var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &amp;&amp; Symbol.for &amp;&amp; Symbol.for('react.element')) || 0xeac7; ReactElement.isValidElement函数用来判断一个React组件是否是有效的，下面是它的具体实现。ReactElement.isValidElement = function (object) &#123; return typeof object === 'object' &amp;&amp; object !== null &amp;&amp; object.$$typeof === REACT_ELEMENT_TYPE;&#125;; 可见React渲染时会把没有$$typeof标识，以及规则校验不通过的组件过滤掉。 如果你的服务器有一个漏洞，允许用户存储任意JSON对象， 而客户端代码需要一个字符串，这可能会成为一个问题： // JSONlet expectedTextButGotJSON = &#123; type: 'div', props: &#123; dangerouslySetInnerHTML: &#123; __html: '/* put your exploit here */' &#125;, &#125;,&#125;;let message = &#123; text: expectedTextButGotJSON &#125;;&lt;p&gt; &#123;message.text&#125;&lt;/p&gt; 而JSON中不能存储Symbol类型的变量，这就是防止XSS的一种手段。 应用二：私有属性 借助Symbol类型的不可枚举，我们可以在类中模拟私有属性，控制变量读写： const privateField = Symbol();class myClass &#123; constructor()&#123; this[privateField] = 'ConardLi'; &#125; getField()&#123; return this[privateField]; &#125; setField(val)&#123; this[privateField] = val; &#125;&#125; 应用三：防止属性污染 在某些情况下，我们可能要为对象添加一个属性，此时就有可能造成属性覆盖，用Symbol作为对象属性可以保证永远不会出现同名属性。 例如下面的场景，我们模拟实现一个call方法： Function.prototype.myCall = function (context) &#123; if (typeof this !== 'function') &#123; return undefined; // 用于防止 Function.prototype.myCall() 直接调用 &#125; context = context || window; const fn = Symbol(); context[fn] = this; const args = [...arguments].slice(1); const result = context[fn](...args); delete context[fn]; return result;&#125; 我们需要在某个对象上临时调用一个方法，又不能造成属性污染，Symbol是一个很好的选择。 五、不老实的Number类型为什么说Number类型不老实呢，相信大家都多多少少的在开发中遇到过小数计算不精确的问题，比如0.1+0.2!==0.3，下面我们来追本溯源，看看为什么会出现这种现象，以及该如何避免。 下面是我实现的一个简单的函数，用于判断两个小数进行加法运算是否精确： function judgeFloat(n, m) &#123; const binaryN = n.toString(2); const binaryM = m.toString(2); console.log(`$&#123;n&#125;的二进制是 $&#123;binaryN&#125;`); console.log(`$&#123;m&#125;的二进制是 $&#123;binaryM&#125;`); const MN = m + n; const accuracyMN = (m * 100 + n * 100) / 100; const binaryMN = MN.toString(2); const accuracyBinaryMN = accuracyMN.toString(2); console.log(`$&#123;n&#125;+$&#123;m&#125;的二进制是$&#123;binaryMN&#125;`); console.log(`$&#123;accuracyMN&#125;的二进制是 $&#123;accuracyBinaryMN&#125;`); console.log(`$&#123;n&#125;+$&#123;m&#125;的二进制再转成十进制是$&#123;to10(binaryMN)&#125;`); console.log(`$&#123;accuracyMN&#125;的二进制是再转成十进制是$&#123;to10(accuracyBinaryMN)&#125;`); console.log(`$&#123;n&#125;+$&#123;m&#125;在js中计算是$&#123;(to10(binaryMN) === to10(accuracyBinaryMN)) ? '' : '不'&#125;准确的`);&#125;function to10(n) &#123; const pre = (n.split('.')[0] - 0).toString(2); const arr = n.split('.')[1].split(''); let i = 0; let result = 0; while (i &lt; arr.length) &#123; result += arr[i] * Math.pow(2, -(i + 1)); i++; &#125; return result;&#125;judgeFloat(0.1, 0.2);judgeFloat(0.6, 0.7); 5.1 精度丢失计算机中所有的数据都是以二进制存储的，所以在计算时计算机要把数据先转换成二进制进行计算，然后在把计算结果转换成十进制。 由上面的代码不难看出，在计算0.1+0.2时，二进制计算发生了精度丢失，导致再转换成十进制后和预计的结果不符。 5.2 对结果的分析—更多的问题0.1和0.2的二进制都是以1100无限循环的小数，下面逐个来看JS帮我们计算所得的结果： 0.1的二进制： 0.0001100110011001100110011001100110011001100110011001101 0.2的二进制：0.001100110011001100110011001100110011001100110011001101 理论上讲，由上面的结果相加应该：： 0.0100110011001100110011001100110011001100110011001100111 实际JS计算得到的0.1+0.2的二进制 0.0100110011001100110011001100110011001100110011001101 看到这里你可能会产生更多的问题： 为什么 js计算出的 0.1的二进制 是这么多位而不是更多位？？？ 为什么 js计算的（0.1+0.2）的二进制和我们自己计算的（0.1+0.2）的二进制结果不一样呢？？？ 为什么 0.1的二进制 + 0.2的二进制 != 0.3的二进制？？？ 5.3 js对二进制小数的存储方式小数的二进制大多数都是无限循环的，JavaScript是怎么来存储他们的呢？ 在ECMAScript®语言规范中可以看到，ECMAScript中的Number类型遵循IEEE 754标准。使用64位固定长度来表示。 事实上有很多语言的数字类型都遵循这个标准，例如JAVA,所以很多语言同样有着上面同样的问题。 所以下次遇到这种问题不要上来就喷JavaScript… 有兴趣可以看看下这个网站http://0.30000000000000004.com/，是的，你没看错，就是http://0.30000000000000004.com/！！！ 5.4 IEEE 754IEEE754标准包含一组实数的二进制表示法。它有三部分组成： 符号位 指数位 尾数位 三种精度的浮点数各个部分位数如下： JavaScript使用的是64位双精度浮点数编码，所以它的符号位占1位，指数位占11位，尾数位占52位。 下面我们在理解下什么是符号位、指数位、尾数位，以0.1为例： 它的二进制为：0.0001100110011001100... 为了节省存储空间，在计算机中它是以科学计数法表示的，也就是 1.100110011001100... X 2-4 如果这里不好理解可以想一下十进制的数： 1100的科学计数法为11 X 102 所以： 符号位就是标识正负的，1表示负，0表示正； 指数位存储科学计数法的指数； 尾数位存储科学计数法后的有效数字； 所以我们通常看到的二进制，其实是计算机实际存储的尾数位。 5.5 js中的toString(2)由于尾数位只能存储52个数字，这就能解释toString(2)的执行结果了： 如果计算机没有存储空间的限制，那么0.1的二进制应该是：0.00011001100110011001100110011001100110011001100110011001... 科学计数法尾数位 1.1001100110011001100110011001100110011001100110011001... 但是由于限制，有效数字第53位及以后的数字是不能存储的，它遵循，如果是1就向前一位进1，如果是0就舍弃的原则。 0.1的二进制科学计数法第53位是1，所以就有了下面的结果： 0.0001100110011001100110011001100110011001100110011001101 0.2有着同样的问题，其实正是由于这样的存储，在这里有了精度丢失，导致了0.1+0.2!=0.3。 事实上有着同样精度问题的计算还有很多，我们无法把他们都记下来，所以当程序中有数字计算时，我们最好用工具库来帮助我们解决，下面是两个推荐使用的开源库： number-precision mathjs/ 5.6 JavaScript能表示的最大数字由与IEEE 754双精度64位规范的限制： 指数位能表示的最大数字：1023(十进制) 尾数位能表达的最大数字即尾数位都位1的情况 所以JavaScript能表示的最大数字即位 1.111...X 21023 这个结果转换成十进制是1.7976931348623157e+308,这个结果即为Number.MAX_VALUE。 5.7 最大安全数字JavaScript中Number.MAX_SAFE_INTEGER表示最大安全数字,计算结果是9007199254740991，即在这个数范围内不会出现精度丢失（小数除外）,这个数实际上是1.111...X 252。 我们同样可以用一些开源库来处理大整数： node-bignum node-bigint 其实官方也考虑到了这个问题，bigInt类型在es10中被提出，现在Chrome中已经可以使用，使用bigInt可以操作超过最大安全数字的数字。 六、还有哪些引用类型 在ECMAScript中，引用类型是一种数据结构，用于将数据和功能组织在一起。 我们通常所说的对象，就是某个特定引用类型的实例。 在ECMAScript关于类型的定义中，只给出了Object类型，实际上，我们平时使用的很多引用类型的变量，并不是由Object构造的，但是它们原型链的终点都是Object，这些类型都属于引用类型。 Array 数组 Date 日期 RegExp 正则 Function 函数 6.1 包装类型为了便于操作基本类型值，ECMAScript还提供了几个特殊的引用类型，他们是基本类型的包装类型： Boolean Number String 注意包装类型和原始类型的区别： true === new Boolean(true); // false123 === new Number(123); // false'ConardLi' === new String('ConardLi'); // falseconsole.log(typeof new String('ConardLi')); // objectconsole.log(typeof 'ConardLi'); // string 引用类型和包装类型的主要区别就是对象的生存期，使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中，而自基本类型则只存在于一行代码的执行瞬间，然后立即被销毁，这意味着我们不能在运行时为基本类型添加属性和方法。 var name = 'ConardLi'name.color = 'red';console.log(name.color); // undefined 6.2 装箱和拆箱 装箱转换：把基本类型转换为对应的包装类型 拆箱操作：把引用类型转换为基本类型 既然原始类型不能扩展属性和方法，那么我们是如何使用原始类型调用方法的呢？ 每当我们操作一个基础类型时，后台就会自动创建一个包装类型的对象，从而让我们能够调用一些方法和属性，例如下面的代码： var name = \"ConardLi\";var name2 = name.substring(2); 实际上发生了以下几个过程： 创建一个String的包装类型实例 在实例上调用substring方法 销毁实例 也就是说，我们使用基本类型调用方法，就会自动进行装箱和拆箱操作，相同的，我们使用Number和Boolean类型时，也会发生这个过程。 从引用类型到基本类型的转换，也就是拆箱的过程中，会遵循ECMAScript规范规定的toPrimitive原则，一般会调用引用类型的valueOf和toString方法，你也可以直接重写toPeimitive方法。一般转换成不同类型的值遵循的原则不同，例如： 引用类型转换为Number类型，先调用valueOf，再调用toString 引用类型转换为String类型，先调用toString，再调用valueOf 若valueOf和toString都不存在，或者没有返回基本类型，则抛出TypeError异常。 const obj = &#123; valueOf: () =&gt; &#123; console.log('valueOf'); return 123; &#125;, toString: () =&gt; &#123; console.log('toString'); return 'ConardLi'; &#125;,&#125;;console.log(obj - 1); // valueOf 122console.log(`$&#123;obj&#125;ConardLi`); // toString ConardLiConardLiconst obj2 = &#123; [Symbol.toPrimitive]: () =&gt; &#123; console.log('toPrimitive'); return 123; &#125;,&#125;;console.log(obj2 - 1); // valueOf 122const obj3 = &#123; valueOf: () =&gt; &#123; console.log('valueOf'); return &#123;&#125;; &#125;, toString: () =&gt; &#123; console.log('toString'); return &#123;&#125;; &#125;,&#125;;console.log(obj3 - 1); // valueOf // toString// TypeError 除了程序中的自动拆箱和自动装箱，我们还可以手动进行拆箱和装箱操作。我们可以直接调用包装类型的valueOf或toString，实现拆箱操作： var num =new Number(\"123\"); console.log( typeof num.valueOf() ); //numberconsole.log( typeof num.toString() ); //string 七、类型转换因为JavaScript是弱类型的语言，所以类型转换发生非常频繁，上面我们说的装箱和拆箱其实就是一种类型转换。 类型转换分为两种，隐式转换即程序自动进行的类型转换，强制转换即我们手动进行的类型转换。 强制转换这里就不再多提及了，下面我们来看看让人头疼的可能发生隐式类型转换的几个场景，以及如何转换： 7.1 类型转换规则如果发生了隐式转换，那么各种类型互转符合下面的规则： 7.2 if语句和逻辑语句在if语句和逻辑语句中，如果只有单个变量，会先将变量转换为Boolean值，只有下面几种情况会转换成false，其余被转换成true： nullundefined''NaN0false 7.3 各种运数学算符我们在对各种非Number类型运用数学运算符(- * /)时，会先将非Number类型转换为Number类型; 1 - true // 01 - null // 11 * undefined // NaN2 * ['5'] // 10 注意+是个例外，执行+操作符时： 1.当一侧为String类型，被识别为字符串拼接，并会优先将另一侧转换为字符串类型。 2.当一侧为Number类型，另一侧为原始类型，则将原始类型转换为Number类型。 3.当一侧为Number类型，另一侧为引用类型，将引用类型和Number类型转换成字符串后拼接。 123 + '123' // 123123 （规则1）123 + null // 123 （规则2）123 + true // 124 （规则2）123 + &#123;&#125; // 123[object Object] （规则3） 7.4 ==使用==时，若两侧类型相同，则比较结果和===相同，否则会发生隐式转换，使用==时发生的转换可以分为几种不同的情况（只考虑两侧类型不同）： 1.NaN NaN和其他任何类型比较永远返回false(包括和他自己)。 NaN == NaN // false 2.Boolean Boolean和其他任何类型比较，Boolean首先被转换为Number类型。 true == 1 // true true == '2' // falsetrue == ['1'] // truetrue == ['2'] // false 这里注意一个可能会弄混的点：undefined、null和Boolean比较，虽然undefined、null和false都很容易被想象成假值，但是他们比较结果是false，原因是false首先被转换成0： undefined == false // falsenull == false // false 3.String和Number String和Number比较，先将String转换为Number类型。 123 == '123' // true'' == 0 // true 4.null和undefined null == undefined比较结果是true，除此之外，null、undefined和其他任何结果的比较值都为false。 null == undefined // truenull == '' // falsenull == 0 // falsenull == false // falseundefined == '' // falseundefined == 0 // falseundefined == false // false 5.原始类型和引用类型 当原始类型和引用类型做比较时，对象类型会依照ToPrimitive规则转换为原始类型: '[object Object]' == &#123;&#125; // true'1,2,3' == [1, 2, 3] // true 来看看下面这个比较： [] == ![] // true !的优先级高于==，![]首先会被转换为false，然后根据上面第三点，false转换成Number类型0，左侧[]转换为0，两侧比较相等。 [null] == false // true[undefined] == false // true 根据数组的ToPrimitive规则，数组元素为null或undefined时，该元素被当做空字符串处理，所以[null]、[undefined]都会被转换为0。 所以，说了这么多，推荐使用===来判断两个值是否相等… 7.5 一道有意思的面试题一道经典的面试题，如何让：a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3。 根据上面的拆箱转换，以及==的隐式转换，我们可以轻松写出答案： const a = &#123; value:[3,2,1], valueOf: function () &#123;return this.value.pop(); &#125;,&#125; 八、判断JavaScript数据类型的方式8.1 typeof适用场景 typeof操作符可以准确判断一个变量是否为下面几个原始类型： typeof 'ConardLi' // stringtypeof 123 // numbertypeof true // booleantypeof Symbol() // symboltypeof undefined // undefined 你还可以用它来判断函数类型： typeof function()&#123;&#125; // function 不适用场景 当你用typeof来判断引用类型时似乎显得有些乏力了： typeof [] // objecttypeof &#123;&#125; // objecttypeof new Date() // objecttypeof /^\\d*$/; // object 除函数外所有的引用类型都会被判定为object。 另外typeof null === &#39;object&#39;也会让人感到头痛，这是在JavaScript初版就流传下来的bug，后面由于修改会造成大量的兼容问题就一直没有被修复… 8.2 instanceofinstanceof操作符可以帮助我们判断引用类型具体是什么类型的对象： [] instanceof Array // truenew Date() instanceof Date // truenew RegExp() instanceof RegExp // true 我们先来回顾下原型链的几条规则： 1.所有引用类型都具有对象特性，即可以自由扩展属性 2.所有引用类型都具有一个__proto__（隐式原型）属性，是一个普通对象 3.所有的函数都具有prototype（显式原型）属性，也是一个普通对象 4.所有引用类型__proto__值指向它构造函数的prototype 5.当试图得到一个对象的属性时，如果变量本身没有这个属性，则会去他的__proto__中去找 [] instanceof Array实际上是判断Array.prototype是否在[]的原型链上。 所以，使用instanceof来检测数据类型，不会很准确，这不是它设计的初衷： [] instanceof Object // truefunction()&#123;&#125; instanceof Object // true 另外，使用instanceof也不能检测基本数据类型，所以instanceof并不是一个很好的选择。 8.3 toString上面我们在拆箱操作中提到了toString函数，我们可以调用它实现从引用类型的转换。 每一个引用类型都有toString方法，默认情况下，toString()方法被每个Object对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 &quot;[object type]&quot;，其中type是对象的类型。 const obj = &#123;&#125;;obj.toString() // [object Object] 注意，上面提到了如果此方法在自定义对象中未被覆盖，toString才会达到预想的效果，事实上，大部分引用类型比如Array、Date、RegExp等都重写了toString方法。 我们可以直接调用Object原型上未被覆盖的toString()方法，使用call来改变this指向来达到我们想要的效果。 8.4 jquery我们来看看jquery源码中如何进行类型判断： var class2type = &#123;&#125;;jQuery.each( \"Boolean Number String Function Array Date RegExp Object Error Symbol\".split( \" \" ),function( i, name ) &#123; class2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();&#125; );type: function( obj ) &#123; if ( obj == null ) &#123; return obj + \"\"; &#125; return typeof obj === \"object\" || typeof obj === \"function\" ? class2type[Object.prototype.toString.call(obj) ] || \"object\" : typeof obj;&#125;isFunction: function( obj ) &#123; return jQuery.type(obj) === \"function\";&#125; 原始类型直接使用typeof，引用类型使用Object.prototype.toString.call取得类型，借助一个class2type对象将字符串多余的代码过滤掉，例如[object function]将得到array，然后在后面的类型判断，如isFunction直接可以使用jQuery.type(obj) === &quot;function&quot;这样的判断。 参考 http://www.ecma-international.org/ecma-262/9.0/index.html https://while.dev/articles/explaining-truthy-falsy-null-0-and-undefined-in-typescript/ https://github.com/mqyqingfeng/Blog/issues/28 https://juejin.im/post/5bc5c752f265da0a9a399a62 https://juejin.im/post/5bbda2b36fb9a05cfd27f55e 《JS高级程序设计》 小结希望你阅读本篇文章后可以达到以下几点： 了解JavaScript中的变量在内存中的具体存储形式，可对应实际场景 搞懂小数计算不精确的底层原因 了解可能发生隐式类型转换的场景以及转换原则 掌握判断JavaScript数据类型的方式和底层原理 文中如有错误，欢迎在评论区指正，如果这篇文章帮助到了你，欢迎点赞和关注。","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"www.conardli.top/tags/JavaScript/"}]},{"title":"【多端开发】移动端适配总结","slug":"【多端开发】移动端适配总结","date":"2019-05-17T02:39:42.000Z","updated":"2019-05-17T02:41:01.119Z","comments":true,"path":"2019/05/17/【多端开发】移动端适配总结/","link":"","permalink":"www.conardli.top/2019/05/17/【多端开发】移动端适配总结/","excerpt":"","text":"导读移动端适配，是我们在开发中经常会遇到的，这里面可能会遇到非常多的问题： 1px问题 UI图完美适配方案 iPhoneX适配方案 横屏适配 高清屏图片模糊问题 … 上面这些问题可能我们在开发中已经知道如何解决，但是问题产生的原理，以及解决方案的原理可能会模糊不清。在解决这些问题的过程中，我们往往会遇到非常多的概念：像素、分辨率、PPI、DPI、DP、DIP、DPR、视口等等，你真的能分清这些概念的意义吗？ 本文将从移动端适配的基础概念出发，探究移动端适配各种问题的解决方案和实现原理。 一、英寸一般用英寸描述屏幕的物理大小，如电脑显示器的17、22，手机显示器的4.8、5.7等使用的单位都是英寸。 需要注意，上面的尺寸都是屏幕对角线的长度： 英寸(inch,缩写为in)在荷兰语中的本意是大拇指，一英寸就是指甲底部普通人拇指的宽度。 英寸和厘米的换算：1英寸 = 2.54 厘米 二、分辨率2.1 像素像素即一个小方块，它具有特定的位置和颜色。 图片、电子屏幕（手机、电脑）就是由无数个具有特定颜色和特定位置的小方块拼接而成。 像素可以作为图片或电子屏幕的最小组成单位。 下面我们使用sketch打开一张图片： 将这些图片放大即可看到这些像素点： 通常我们所说的分辨率有两种，屏幕分辨率和图像分辨率。 2.2 屏幕分辨率屏幕分辨率指一个屏幕具体由多少个像素点组成。 下面是apple的官网上对手机分辨率的描述： iPhone XS Max 和 iPhone SE的分辨率分别为2688 x 1242和1136 x 640。这表示手机分别在垂直和水平上所具有的像素点数。 当然分辨率高不代表屏幕就清晰，屏幕的清晰程度还与尺寸有关。 2.3 图像分辨率我们通常说的图片分辨率其实是指图片含有的像素数，比如一张图片的分辨率为800 x 400。这表示图片分别在垂直和水平上所具有的像素点数为800和400。 同一尺寸的图片，分辨率越高，图片越清晰。 2.4 PPIPPI(Pixel Per Inch)：每英寸包括的像素数。 PPI可以用于描述屏幕的清晰度以及一张图片的质量。 使用PPI描述图片时，PPI越高，图片质量越高，使用PPI描述屏幕时，PPI越高，屏幕越清晰。 在上面描述手机分辨率的图片中，我们可以看到：iPhone XS Max 和 iPhone SE的PPI分别为458和326，这足以证明前者的屏幕更清晰。 由于手机尺寸为手机对角线的长度，我们通常使用如下的方法计算PPI: $$ \\frac{\\sqrt{水平像素点数^2+垂直像素点数^2}}{尺寸}$$ iPhone 6的PPI为 $ \\frac{\\sqrt{1334^2+750^2}}{4.7}=325.6$，那它每英寸约含有326个物理像素点。 2.5 DPIDPI(Dot Per Inch)：即每英寸包括的点数。 这里的点是一个抽象的单位，它可以是屏幕像素点、图片像素点也可以是打印机的墨点。 平时你可能会看到使用DPI来描述图片和屏幕，这时的DPI应该和PPI是等价的，DPI最常用的是用于描述打印机，表示打印机每英寸可以打印的点数。 一张图片在屏幕上显示时，它的像素点数是规则排列的，每个像素点都有特定的位置和颜色。 当使用打印机进行打印时，打印机可能不会规则的将这些点打印出来，而是使用一个个打印点来呈现这张图像，这些打印点之间会有一定的空隙，这就是DPI所描述的：打印点的密度。 在上面的图像中我们可以清晰的看到，打印机是如何使用墨点来打印一张图像。 所以，打印机的DPI越高，打印图像的精细程度就越高，同时这也会消耗更多的墨点和时间。 三、设备独立像素实际上，上面我们描述的像素都是物理像素，即设备上真实的物理单元。 下面我们来看看设备独立像素究竟是如何产生的： 智能手机发展非常之快，在几年之前，我们还用着分辨率非常低的手机，比如下面左侧的白色手机，它的分辨率是320x480，我们可以在上面浏览正常的文字、图片等等。 但是，随着科技的发展，低分辨率的手机已经不能满足我们的需求了。很快，更高分辨率的屏幕诞生了，比如下面的黑色手机，它的分辨率是640x940，正好是白色手机的两倍。 理论上来讲，在白色手机上相同大小的图片和文字，在黑色手机上会被缩放一倍，因为它的分辨率提高了一倍。这样，岂不是后面出现更高分辨率的手机，页面元素会变得越来越小吗？ 然而，事实并不是这样的，我们现在使用的智能手机，不管分辨率多高，他们所展示的界面比例都是基本类似的。乔布斯在iPhone4的发布会上首次提出了Retina Display(视网膜屏幕)的概念，它正是解决了上面的问题，这也使它成为一款跨时代的手机。 在iPhone4使用的视网膜屏幕中，把2x2个像素当1个像素使用，这样让屏幕看起来更精致，但是元素的大小却不会改变。 如果黑色手机使用了视网膜屏幕的技术，那么显示结果应该是下面的情况，比如列表的宽度为300个像素，那么在一条水平线上，白色手机会用300个物理像素去渲染它，而黑色手机实际上会用600个物理像素去渲染它。 我们必须用一种单位来同时告诉不同分辨率的手机，它们在界面上显示元素的大小是多少，这个单位就是设备独立像素(Device Independent Pixels)简称DIP或DP。上面我们说，列表的宽度为300个像素，实际上我们可以说：列表的宽度为300个设备独立像素。 打开chrome的开发者工具，我们可以模拟各个手机型号的显示情况，每种型号上面会显示一个尺寸，比如iPhone X显示的尺寸是375x812，实际iPhone X的分辨率会比这高很多，这里显示的就是设备独立像素。 3.1 设备像素比设备像素比device pixel ratio简称dpr，即物理像素和设备独立像素的比值。 在web中，浏览器为我们提供了window.devicePixelRatio来帮助我们获取dpr。 在css中，可以使用媒体查询min-device-pixel-ratio，区分dpr： @media (-webkit-min-device-pixel-ratio: 2),(min-device-pixel-ratio: 2)&#123; &#125; 在React Native中，我们也可以使用PixelRatio.get()来获取DPR。 当然，上面的规则也有例外，iPhone 6、7、8 Plus的实际物理像素是1080 x 1920，在开发者工具中我们可以看到：它的设备独立像素是414 x 736，设备像素比为3，设备独立像素和设备像素比的乘积并不等于1080 x 1920，而是等于1242 x 2208。 实际上，手机会自动把1242 x 2208个像素点塞进1080 * 1920个物理像素点来渲染，我们不用关心这个过程，而1242 x 2208被称为屏幕的设计像素。我们开发过程中也是以这个设计像素为准。 实际上，从苹果提出视网膜屏幕开始，才出现设备像素比这个概念，因为在这之前，移动设备都是直接使用物理像素来进行展示。 紧接着，Android同样使用了其他的技术方案来实现DPR大于1的屏幕，不过原理是类似的。由于Android屏幕尺寸非常多、分辨率高低跨度非常大，不像苹果只有它自己的几款固定设备、尺寸。所以，为了保证各种设备的显示效果，Android按照设备的像素密度将设备分成了几个区间： 当然，所有的Android设备不一定严格按照上面的分辨率，每个类型可能对应几种不同分辨率，所以，每个Android手机都能根据给定的区间范围，确定自己的DPR，从而拥有类似的显示。当然，仅仅是类似，由于各个设备的尺寸、分辨率上的差异，设备独立像素也不会完全相等，所以各种Android设备仍然不能做到在展示上完全相等。 3.2 移动端开发在iOS、Android和React Native开发中样式单位其实都使用的是设备独立像素。 iOS的尺寸单位为pt，Android的尺寸单位为dp，React Native中没有指定明确的单位，它们其实都是设备独立像素dp。 在使用React Native开发App时，UI给我们的原型图一般是基于iphone6的像素给定的。 为了适配所有机型，我们在写样式时需要把物理像素转换为设备独立像素：例如：如果给定一个元素的高度为200px(这里的px指物理像素，非CSS像素)，iphone6的设备像素比为2，我们给定的height应为200px/2=100dp。 当然，最好的是，你可以和设计沟通好，所有的UI图都按照设备独立像素来出。 我们还可以在代码(React Native)中进行px和dp的转换： import &#123;PixelRatio &#125; from 'react-native';const dpr = PixelRatio.get();/** * px转换为dp */export function pxConvertTodp(px) &#123; return px / dpr;&#125;/** * dp转换为px */export function dpConvertTopx(dp) &#123; return PixelRatio.getPixelSizeForLayoutSize(dp);&#125; 3.3 WEB端开发在写CSS时，我们用到最多的单位是px，即CSS像素，当页面缩放比例为100%时，一个CSS像素等于一个设备独立像素。 但是CSS像素是很容易被改变的，当用户对浏览器进行了放大，CSS像素会被放大，这时一个CSS像素会跨越更多的物理像素。 页面的缩放系数 = CSS像素 / 设备独立像素。 3.4 关于屏幕这里多说两句Retina屏幕，因为我在很多文章中看到对Retina屏幕的误解。 Retina屏幕只是苹果提出的一个营销术语： 在普通的使用距离下，人的肉眼无法分辨单个的像素点。 为什么强调普通的使用距离下呢？我们来看一下它的计算公式： $$ a=2arctan(h/2d) $$ a代表人眼视角，h代表像素间距，d代表肉眼与屏幕的距离，符合以上条件的屏幕可以使肉眼看不见单个物理像素点。 它不能单纯的表达分辨率和PPI，只能一种表达视觉效果。 让多个物理像素渲染一个独立像素只是Retina屏幕为了达到效果而使用的一种技术。而不是所有DPR &gt; 1的屏幕就是Retina屏幕。 比如：给你一块超大尺寸的屏幕，即使它的PPI很高，DPR也很高，在近距离你也能看清它的像素点，这就不算Retina屏幕。 我们经常见到用K和P这个单位来形容屏幕： P代表的就是屏幕纵向的像素个数，1080P即纵向有1080个像素，分辨率为1920X1080的屏幕就属于1080P屏幕。 我们平时所说的高清屏其实就是屏幕的物理分辨率达到或超过1920X1080的屏幕。 K代表屏幕横向有几个1024个像素，一般来讲横向像素超过2048就属于2K屏，横向像素超过4096就属于4K屏。 四、视口视口(viewport)代表当前可见的计算机图形区域。在Web浏览器术语中，通常与浏览器窗口相同，但不包括浏览器的UI， 菜单栏等——即指你正在浏览的文档的那一部分。 一般我们所说的视口共包括三种：布局视口、视觉视口和理想视口，它们在屏幕适配中起着非常重要的作用。 4.1 布局视口 布局视口(layout viewport)：当我们以百分比来指定一个元素的大小时，它的计算值是由这个元素的包含块计算而来的。当这个元素是最顶级的元素时，它就是基于布局视口来计算的。 所以，布局视口是网页布局的基准窗口，在PC浏览器上，布局视口就等于当前浏览器的窗口大小（不包括borders 、margins、滚动条）。 在移动端，布局视口被赋予一个默认值，大部分为980px，这保证PC的网页可以在手机浏览器上呈现，但是非常小，用户可以手动对网页进行放大。 我们可以通过调用document.documentElement.clientWidth / clientHeight来获取布局视口大小。 4.2 视觉视口 视觉视口(visual viewport)：用户通过屏幕真实看到的区域。 视觉视口默认等于当前浏览器的窗口大小（包括滚动条宽度）。 当用户对浏览器进行缩放时，不会改变布局视口的大小，所以页面布局是不变的，但是缩放会改变视觉视口的大小。 例如：用户将浏览器窗口放大了200%，这时浏览器窗口中的CSS像素会随着视觉视口的放大而放大，这时一个CSS像素会跨越更多的物理像素。 所以，布局视口会限制你的CSS布局而视觉视口决定用户具体能看到什么。 我们可以通过调用window.innerWidth / innerHeight来获取视觉视口大小。 4.3 理想视口 布局视口在移动端展示的效果并不是一个理想的效果，所以理想视口(ideal viewport)就诞生了：网站页面在移动端展示的理想大小。 如上图，我们在描述设备独立像素时曾使用过这张图，在浏览器调试移动端时页面上给定的像素大小就是理想视口大小，它的单位正是设备独立像素。 上面在介绍CSS像素时曾经提到页面的缩放系数 = CSS像素 / 设备独立像素，实际上说页面的缩放系数 = 理想视口宽度 / 视觉视口宽度更为准确。 所以，当页面缩放比例为100%时，CSS像素 = 设备独立像素，理想视口 = 视觉视口。 我们可以通过调用screen.width / height来获取理想视口大小。 4.4 Meta viewport&lt;meta&gt; 元素表示那些不能由其它HTML元相关元素之一表示的任何元数据信息，它可以告诉浏览器如何解析页面。 我们可以借助&lt;meta&gt;元素的viewport来帮助我们设置视口、缩放等，从而让移动端得到更好的展示效果。 &lt;meta name=\"viewport\" content=\"width=device-width; initial-scale=1; maximum-scale=1; minimum-scale=1; user-scalable=no;\"&gt; 上面是viewport的一个配置，我们来看看它们的具体含义： Value 可能值 描述 width 正整数或device-width 以pixels（像素）为单位， 定义布局视口的宽度。 height 正整数或device-height 以pixels（像素）为单位， 定义布局视口的高度。 initial-scale 0.0 - 10.0 定义页面初始缩放比率。 minimum-scale 0.0 - 10.0 定义缩放的最小值；必须小于或等于maximum-scale的值。 maximum-scale 0.0 - 10.0 定义缩放的最大值；必须大于或等于minimum-scale的值。 user-scalable 一个布尔值（yes或者no） 如果设置为 no，用户将不能放大或缩小网页。默认值为 yes。 4.5 移动端适配为了在移动端让页面获得更好的显示效果，我们必须让布局视口、视觉视口都尽可能等于理想视口。 device-width就等于理想视口的宽度，所以设置width=device-width就相当于让布局视口等于理想视口。 由于initial-scale = 理想视口宽度 / 视觉视口宽度，所以我们设置initial-scale=1;就相当于让视觉视口等于理想视口。 这时，1个CSS像素就等于1个设备独立像素，而且我们也是基于理想视口来进行布局的，所以呈现出来的页面布局在各种设备上都能大致相似。 4.6 缩放上面提到width可以决定布局视口的宽度，实际上它并不是布局视口的唯一决定性因素，设置initial-scale也有肯能影响到布局视口，因为布局视口宽度取的是width和视觉视口宽度的最大值。 例如：若手机的理想视口宽度为400px，设置width=device-width，initial-scale=2，此时视觉视口宽度 = 理想视口宽度 / initial-scale即200px，布局视口取两者最大值即device-width 400px。 若设置width=device-width，initial-scale=0.5，此时视觉视口宽度 = 理想视口宽度 / initial-scale即800px，布局视口取两者最大值即800px。 4.7 获取浏览器大小浏览器为我们提供的获取窗口大小的API有很多，下面我们再来对比一下： window.innerHeight：获取浏览器视觉视口高度（包括垂直滚动条）。 window.outerHeight：获取浏览器窗口外部的高度。表示整个浏览器窗口的高度，包括侧边栏、窗口镶边和调正窗口大小的边框。 window.screen.Height：获取获屏幕取理想视口高度，这个数值是固定的，设备的分辨率/设备像素比 window.screen.availHeight：浏览器窗口可用的高度。 document.documentElement.clientHeight：获取浏览器布局视口高度，包括内边距，但不包括垂直滚动条、边框和外边距。 document.documentElement.offsetHeight：包括内边距、滚动条、边框和外边距。 document.documentElement.scrollHeight：在不使用滚动条的情况下适合视口中的所有内容所需的最小宽度。测量方式与clientHeight相同：它包含元素的内边距，但不包括边框，外边距或垂直滚动条。 五、1px问题为了适配各种屏幕，我们写代码时一般使用设备独立像素来对页面进行布局。 而在设备像素比大于1的屏幕上，我们写的1px实际上是被多个物理像素渲染，这就会出现1px在有些屏幕上看起来很粗的现象。 5.1 border-image基于media查询判断不同的设备像素比给定不同的border-image： .border_1px&#123; border-bottom: 1px solid #000; &#125; @media only screen and (-webkit-min-device-pixel-ratio:2)&#123; .border_1px&#123; border-bottom: none; border-width: 0 0 1px 0; border-image: url(../img/1pxline.png) 0 0 2 0 stretch; &#125; &#125; 5.2 background-image和border-image类似，准备一张符合条件的边框背景图，模拟在背景上。 .border_1px&#123; border-bottom: 1px solid #000; &#125; @media only screen and (-webkit-min-device-pixel-ratio:2)&#123; .border_1px&#123; background: url(../img/1pxline.png) repeat-x left bottom; background-size: 100% 1px; &#125; &#125; 上面两种都需要单独准备图片，而且圆角不是很好处理，但是可以应对大部分场景。 5.3 伪类 + transform基于media查询判断不同的设备像素比对线条进行缩放： .border_1px:before&#123; content: ''; position: absolute; top: 0; height: 1px; width: 100%; background-color: #000; transform-origin: 50% 0%; &#125; @media only screen and (-webkit-min-device-pixel-ratio:2)&#123; .border_1px:before&#123; transform: scaleY(0.5); &#125; &#125; @media only screen and (-webkit-min-device-pixel-ratio:3)&#123; .border_1px:before&#123; transform: scaleY(0.33); &#125; &#125; 这种方式可以满足各种场景，如果需要满足圆角，只需要给伪类也加上border-radius即可。 5.4 svg上面我们border-image和background-image都可以模拟1px边框，但是使用的都是位图，还需要外部引入。 借助PostCSS的postcss-write-svg我们能直接使用border-image和background-image创建svg的1px边框： @svg border_1px &#123; height: 2px; @rect &#123; fill: var(--color, black); width: 100%; height: 50%; &#125; &#125; .example &#123; border: 1px solid transparent; border-image: svg(border_1px param(--color #00b1ff)) 2 2 stretch; &#125; 编译后： .example &#123; border: 1px solid transparent; border-image: url(\"data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' height='2px'%3E%3Crect fill='%2300b1ff' width='100%25' height='50%25'/%3E%3C/svg%3E\") 2 2 stretch; &#125; 上面的方案是大漠在他的文章中推荐使用的，基本可以满足所有场景，而且不需要外部引入，这是我个人比较喜欢的一种方案。 5.5 设置viewport通过设置缩放，让CSS像素等于真正的物理像素。 例如：当设备像素比为3时，我们将页面缩放1/3倍，这时1px等于一个真正的屏幕像素。 const scale = 1 / window.devicePixelRatio;const viewport = document.querySelector('meta[name=\"viewport\"]');if (!viewport) &#123; viewport = document.createElement('meta'); viewport.setAttribute('name', 'viewport'); window.document.head.appendChild(viewport);&#125;viewport.setAttribute('content', 'width=device-width,user-scalable=no,initial-scale=' + scale + ',maximum-scale=' + scale + ',minimum-scale=' + scale); 实际上，上面这种方案是早先flexible采用的方案。 当然，这样做是要付出代价的，这意味着你页面上所有的布局都要按照物理像素来写。这显然是不现实的，这时，我们可以借助flexible或vw、vh来帮助我们进行适配。 六、移动端适配方案尽管我们可以使用设备独立像素来保证各个设备在不同手机上显示的效果类似，但这并不能保证它们显示完全一致，我们需要一种方案来让设计稿得到更完美的适配。 6.1 flexible方案flexible方案是阿里早期开源的一个移动端适配解决方案，引用flexible后，我们在页面上统一使用rem来布局。 它的核心代码非常简单： // set 1rem = viewWidth / 10function setRemUnit () &#123; var rem = docEl.clientWidth / 10 docEl.style.fontSize = rem + 'px'&#125;setRemUnit(); rem 是相对于html节点的font-size来做计算的。 我们通过设置document.documentElement.style.fontSize就可以统一整个页面的布局标准。 上面的代码中，将html节点的font-size设置为页面clientWidth(布局视口)的1/10，即1rem就等于页面布局视口的1/10，这就意味着我们后面使用的rem都是按照页面比例来计算的。 这时，我们只需要将UI出的图转换为rem即可。 以iPhone6为例：布局视口为375px，则1rem = 37.5px，这时UI给定一个元素的宽为75px（设备独立像素），我们只需要将它设置为75 / 37.5 = 2rem。 当然，每个布局都要计算非常繁琐，我们可以借助PostCSS的px2rem插件来帮助我们完成这个过程。 下面的代码可以保证在页面大小变化时，布局可以自适应，当触发了window的resize和pageShow事件之后自动调整html的fontSize大小。 // reset rem unit on page resizewindow.addEventListener('resize', setRemUnit)window.addEventListener('pageshow', function (e) &#123; if (e.persisted) &#123; setRemUnit() &#125;&#125;) 由于viewport单位得到众多浏览器的兼容，上面这种方案现在已经被官方弃用： lib-flexible这个过渡方案已经可以放弃使用，不管是现在的版本还是以前的版本，都存有一定的问题。建议大家开始使用viewport来替代此方案。 下面我们来看看现在最流行的vh、vw方案。 6.2 vh、vw方案vh、vw方案即将视觉视口宽度 window.innerWidth和视觉视口高度 window.innerHeight 等分为 100 份。 上面的flexible方案就是模仿这种方案，因为早些时候vw还没有得到很好的兼容。 vw(Viewport&#39;s width)：1vw等于视觉视口的1% vh(Viewport&#39;s height) :1vh 为视觉视口高度的1% vmin : vw 和 vh 中的较小值 vmax : 选取 vw 和 vh 中的较大值 如果视觉视口为375px，那么1vw = 3.75px，这时UI给定一个元素的宽为75px（设备独立像素），我们只需要将它设置为75 / 3.75 = 20vw。 这里的比例关系我们也不用自己换算，我们可以使用PostCSS的 postcss-px-to-viewport 插件帮我们完成这个过程。写代码时，我们只需要根据UI给的设计图写px单位即可。 当然，没有一种方案是十全十美的，vw同样有一定的缺陷： px转换成vw不一定能完全整除，因此有一定的像素差。 比如当容器使用vw，margin采用px时，很容易造成整体宽度超过100vw，从而影响布局效果。当然我们也是可以避免的，例如使用padding代替margin，结合calc()函数使用等等… 七、适配iPhoneXiPhoneX的出现将手机的颜值带上了一个新的高度，它取消了物理按键，改成了底部的小黑条，但是这样的改动给开发者适配移动端又增加了难度。 7.1 安全区域在iPhoneX发布后，许多厂商相继推出了具有边缘屏幕的手机。 这些手机和普通手机在外观上无外乎做了三个改动：圆角（corners）、刘海（sensor housing）和小黑条（Home Indicator）。为了适配这些手机，安全区域这个概念变诞生了：安全区域就是一个不受上面三个效果的可视窗口范围。 为了保证页面的显示效果，我们必须把页面限制在安全范围内，但是不影响整体效果。 7.2 viewport-fitviewport-fit是专门为了适配iPhoneX而诞生的一个属性，它用于限制网页如何在安全区域内进行展示。 contain: 可视窗口完全包含网页内容 cover：网页内容完全覆盖可视窗口 默认情况下或者设置为auto和contain效果相同。 7.3 env、constant 我们需要将顶部和底部合理的摆放在安全区域内，iOS11新增了两个CSS函数env、constant，用于设定安全区域与边界的距离。 函数内部可以是四个常量： safe-area-inset-left：安全区域距离左边边界距离 safe-area-inset-right：安全区域距离右边边界距离 safe-area-inset-top：安全区域距离顶部边界距离 safe-area-inset-bottom：安全区域距离底部边界距离 注意：我们必须指定viweport-fit后才能使用这两个函数： &lt;meta name=\"viewport\" content=\"viewport-fit=cover\"&gt; constant在iOS &lt; 11.2的版本中生效，env在iOS &gt;= 11.2的版本中生效，这意味着我们往往要同时设置他们，将页面限制在安全区域内： body &#123; padding-bottom: constant(safe-area-inset-bottom); padding-bottom: env(safe-area-inset-bottom);&#125; 当使用底部固定导航栏时，我们要为他们设置padding值： &#123; padding-bottom: constant(safe-area-inset-bottom); padding-bottom: env(safe-area-inset-bottom);&#125; 八、横屏适配 很多视口我们要对横屏和竖屏显示不同的布局，所以我们需要检测在不同的场景下给定不同的样式： 8.1 JavaScript检测横屏window.orientation:获取屏幕旋转方向 window.addEventListener(\"resize\", ()=&gt;&#123; if (window.orientation === 180 || window.orientation === 0) &#123; // 正常方向或屏幕旋转180度 console.log('竖屏'); &#125;; if (window.orientation === 90 || window.orientation === -90 )&#123; // 屏幕顺时钟旋转90度或屏幕逆时针旋转90度 console.log('横屏'); &#125; &#125;); 8.2 CSS检测横屏@media screen and (orientation: portrait) &#123; /*竖屏...*/&#125; @media screen and (orientation: landscape) &#123; /*横屏...*/&#125; 九、图片模糊问题9.1 产生原因我们平时使用的图片大多数都属于位图（png、jpg...），位图由一个个像素点构成的，每个像素都具有特定的位置和颜色值： 理论上，位图的每个像素对应在屏幕上使用一个物理像素来渲染，才能达到最佳的显示效果。 而在dpr &gt; 1的屏幕上，位图的一个像素可能由多个物理像素来渲染，然而这些物理像素点并不能被准确的分配上对应位图像素的颜色，只能取近似值，所以相同的图片在dpr &gt; 1的屏幕上就会模糊: 9.2 解决方案为了保证图片质量，我们应该尽可能让一个屏幕像素来渲染一个图片像素，所以，针对不同DPR的屏幕，我们需要展示不同分辨率的图片。 如：在dpr=2的屏幕上展示两倍图(@2x)，在dpr=3的屏幕上展示三倍图(@3x)。 9.3 media查询使用media查询判断不同的设备像素比来显示不同精度的图片： .avatar&#123; background-image: url(conardLi_1x.png); &#125; @media only screen and (-webkit-min-device-pixel-ratio:2)&#123; .avatar&#123; background-image: url(conardLi_2x.png); &#125; &#125; @media only screen and (-webkit-min-device-pixel-ratio:3)&#123; .avatar&#123; background-image: url(conardLi_3x.png); &#125; &#125; 只适用于背景图 9.4 image-set使用image-set： .avatar &#123; background-image: -webkit-image-set( \"conardLi_1x.png\" 1x, \"conardLi_2x.png\" 2x );&#125; 只适用于背景图 9.5 srcset使用img标签的srcset属性，浏览器会自动根据像素密度匹配最佳显示图片： &lt;img src=\"conardLi_1x.png\" srcset=\" conardLi_2x.png 2x, conardLi_3x.png 3x\"&gt; 9.6 JavaScript拼接图片url使用window.devicePixelRatio获取设备像素比，遍历所有图片，替换图片地址： const dpr = window.devicePixelRatio;const images = document.querySelectorAll('img');images.forEach((img)=&gt;&#123; img.src.replace(\".\", `@$&#123;dpr&#125;x.`);&#125;) 9.7 使用svgSVG的全称是可缩放矢量图（Scalable Vector Graphics）。不同于位图的基于像素，SVG 则是属于对图像的形状描述，所以它本质上是文本文件，体积较小，且不管放大多少倍都不会失真。 除了我们手动在代码中绘制svg，我们还可以像使用位图一样使用svg图片： &lt;img src=\"conardLi.svg\"&gt;&lt;img src=\"data:image/svg+xml;base64,[data]\"&gt;.avatar &#123; background: url(conardLi.svg);&#125; 参考 https://99designs.com/blog/tips/ppi-vs-dpi-whats-the-difference/ https://www.w3cplus.com/css/vw-for-layout.html https://aotu.io/notes/2017/11/27/iphonex/index.html 小结希望你阅读本篇文章后可以达到以下几点： 理清移动端适配常用概念 理解移动端适配问题产生的原理，至少掌握一种解决方案 文中如有错误，欢迎在评论区指正，如果这篇文章帮助到了你，欢迎点赞和关注。","categories":[],"tags":[{"name":"多端开发","slug":"多端开发","permalink":"www.conardli.top/tags/多端开发/"}]},{"title":"【特效】看完这篇，你也可以实现一个360度全景插件","slug":"【特效】看完这篇，你也可以实现一个360度全景插件","date":"2019-05-05T01:17:16.000Z","updated":"2019-06-01T10:53:33.997Z","comments":true,"path":"2019/05/05/【特效】看完这篇，你也可以实现一个360度全景插件/","link":"","permalink":"www.conardli.top/2019/05/05/【特效】看完这篇，你也可以实现一个360度全景插件/","excerpt":"","text":"导读本文从绘图基础开始讲起，详细介绍了如何使用Three.js开发一个功能齐全的全景插件。 我们先来看一下插件的效果： 如果你对Three.js已经很熟悉了，或者你想跳过基础理论，那么你可以直接从全景预览开始看起。 本项目的github地址：https://github.com/ConardLi/tpanorama 一、理清关系1.1 OpenGL OpenGL是用于渲染2D、3D量图形的跨语言、跨平台的应用程序编程接口（API）。 这个接口由近350个不同的函数调用组成，用来从简单的图形比特绘制复杂的三维景象。 OpenGL ES 是OpenGL三维图形API的子集，针对手机、PDA和游戏主机等嵌入式设备而设计。 基于OpenGL，一般使用C或Cpp开发，对前端开发者来说不是很友好。 1.2 WebGLWebGL把JavaScript和OpenGL ES 2.0结合在一起，从而为前端开发者提供了使用JavaScript编写3D效果的能力。 WebGL为HTML5 Canvas提供硬件3D加速渲染，这样Web开发人员就可以借助系统显卡来在浏览器里更流畅地展示3D场景和模型了，还能创建复杂的导航和数据视觉化。 1.3 CanvasCanvas是一个可以自由制定大小的矩形区域，可以通过JavaScript可以对矩形区域进行操作，可以自由的绘制图形，文字等。 一般使用Canvas都是使用它的2d的context功能，进行2d绘图，这是其本身的能力。 和这个相对的，WebGL是三维，可以描画3D图形，WebGL，想要在浏览器上进行呈现，它必须需要一个载体，这个载体就是Canvas，区别于之前的2dcontext，还可以从Canvas中获取webglcontext。 1.4 Three.js 我们先来从字面意思理解下：Three代表3D，js代表JavaScript，即使用JavaScript来开发3D效果。 Three.js是使用JavaScript对 WebGL接口进行封装与简化而形成的一个易用的3D库。 直接使用WebGL进行开发对于开发者来说成本相对来说是比较高的，它需要你掌握较多的计算机图形学知识。 Three.js在一定程度上简化了一些规范和难以理解的概念，对很多API进行了简化，这大大降低了学习和开发三维效果成本。 下面我们来具体看一下使用Three.js必须要知道的知识。 二、Three.js基础知识使用Three.js绘制一个三维效果，至少需要以下几个步骤： 创建一个容纳三维空间的场景 — Sence 将需要绘制的元素加入到场景中，对元素的形状、材料、阴影等进行设置 给定一个观察场景的位置，以及观察角度，我们用相机对象（Camera）来控制 将绘制好的元素使用渲染器（Renderer）进行渲染，最终呈现在浏览器上 拿电影来类比的话，场景对应于整个布景空间，相机是拍摄镜头，渲染器用来把拍摄好的场景转换成胶卷。 2.1 场景场景允许你设置哪些对象被three.js渲染以及渲染在哪里。 我们在场景中放置对象、灯光和相机。 很简单，直接创建一个Scene的实例即可。 _scene = new Scene(); 2.2 元素有了场景，我们接下来就需要场景里应该展示哪些东西。 一个复杂的三维场景往往就是由非常多的元素搭建起来的，这些元素可能是一些自定义的几何体（Geometry），或者外部导入的复杂模型。 Three.js 为我们提供了非常多的Geometry，例如SphereGeometry（球体）、 TetrahedronGeometry（四面体）、TorusGeometry（圆环体）等等。 在Three.js中，材质（Material）决定了几何图形具体是以什么形式展现的。它包括了一个几何体如何形状以外的其他属性，例如色彩、纹理、透明度等等，Material和Geometry是相辅相成的，必须结合使用。 下面的代码我们创建了一个长方体体，赋予它基础网孔材料（MeshBasicMaterial） var geometry = new THREE.BoxGeometry(200, 100, 100);var material = new THREE.MeshBasicMaterial(&#123; color: 0x645d50 &#125;);var mesh = new THREE.Mesh(geometry, material); _scene.add(mesh); 能以这个角度看到几何体实际上是相机的功劳，这个我们下面的章节再介绍，这让我们看到一个几何体的轮廓，但是感觉怪怪的，这并不像一个几何体，实际上我们还需要为它添加光照和阴影，这会让几何体看起来更真实。 基础网孔材料（MeshBasicMaterial）不受光照影响的，它不会产生阴影，下面我们为几何体换一种受光照影响的材料：网格标准材质(Standard Material)，并为它添加一些光照： var geometry = new THREE.BoxGeometry(200, 100, 100);var material = new THREE.MeshStandardMaterial(&#123; color: 0x645d50 &#125;);var mesh = new THREE.Mesh(geometry, material);_scene.add(mesh);// 创建平行光-照亮几何体var directionalLight = new THREE.DirectionalLight(0xffffff, 1); directionalLight.position.set(-4, 8, 12);_scene.add(directionalLight);// 创建环境光var ambientLight = new THREE.AmbientLight(0xffffff);_scene.add(ambientLight); 有了光线的渲染，让几何体看起来更具有3D效果，Three.js中光源有很多种，我们上面使用了环境光(AmbientLight)和平行光(DirectionalLight)。 环境光会对场景中的所有物品进行颜色渲染。 平行光你可以认为像太阳光一样，从极远处射向场景中的光。它具有方向性，也可以启动物体对光的反射效果。 除了这两种光，Three.js还提供了其他几种光源，它们适用于不同情况下对不同材质的渲染，可以根据实际情况选择。 2.3 坐标系在说相机之前，我们还是先来了解一下坐标系的概念： 在三维世界中，坐标定义了一个元素所处于三维空间的位置，坐标系的原点即坐标的基准点。 最常用的，我们使用距离原点的三个长度（距离x轴、距离y轴、距离z轴）来定义一个位置，这就是直角坐标系。 在判定坐标系时，我们通常使用大拇指、食指和中指，并互为90度。大拇指代表X轴，食指代表Y轴，中指代表Z轴。 这就产生了两种坐标系：左手坐标系和右手坐标系。 Three.js中使用的坐标系即右手坐标系。 我们可以在我们的场景中添加一个坐标系，这样我们可以清楚的看到元素处于什么位置： var axisHelper = new THREE.AxisHelper(600);_scene.add(axisHelper); 其中红色代表X轴，绿色代表Y轴，蓝色代表Z轴。 2.4 相机上面看到的几何体的效果，如果不创建一个相机(Camera)，是什么也看不到的，因为默认的观察点在坐标轴原点，它处于几何体的内部。 相机(Camera)指定了我们在什么位置观察这个三维场景，以及以什么样的角度进行观察。 2.4.1 两种相机的区别目前Three.js提供了几种不同的相机，最常用的，也是下面插件中使用的两种相机是：PerspectiveCamera（透视相机）、 OrthographicCamera（正交投影相机）。 上面的图很清楚的解释了两种相机的区别： 右侧是 OrthographicCamera（正交投影相机）他不具有透视效果，即物体的大小不受远近距离的影响，对应的是投影中的正交投影。我们数学课本上所画的几何体大多数都采用这种投影。 左侧是PerspectiveCamera（透视相机），这符合我们正常人的视野，近大远小，对应的是投影中的透视投影。 如果你想让场景看起来更真实，更具有立体感，那么采用透视相机最合适，如果场景中有一些元素你不想让他随着远近放大缩小，那么采用正交投影相机最合适。 2.4.2 构造参数我们再分别来看看两个创建两个相机需要什么参数： _camera = new OrthographicCamera(left, right, top, bottom, near, far); OrthographicCamera接收六个参数，left, right, top, bottom分别对应上、下、左、右、远、近的一个距离，超过这些距离的元素将不会出现在视野范围内，也不会被浏览器绘制。实际上，这六个距离就构成了一个立方体，所以OrthographicCamera的可视范围永远在这个立方体内。 _camera = new PerspectiveCamera(fov, aspect, near, far); PerspectiveCamera接收四个参数，near、far和上面的相同，分别对应相机可观测的最远和最近距离；fov代表水平范围可观测的角度，fov越大，水平范围能观测到的范围越广；aspect代表水平方向和竖直方向可观测距离的比值，所以fov和aspect就可以确定垂直范围内能观测到的范围。 2.4.3 position、lookAt关于相机还有两个必须要知道的点，一个是position属性，一个是lookAt函数： position属性指定了相机所处的位置。 lookAt函数指定相机观察的方向。 实际上position的值和lookAt接收的参数都是一个类型为Vector3的对象，这个对象用来表示三维空间中的坐标，它有三个属性：x、y、z分别代表距离x轴、距离y轴、距离z轴的距离。 下面，我们让相机观察的方向指向原点，另外分别让x、y、z为0，另外两个参数不为0，看一下视野会发生什么变化： _camera = new OrthographicCamera(-window.innerWidth / 2, window.innerWidth / 2, window.innerHeight / 2, -window.innerHeight / 2, 0.1, 1000); _camera.lookAt(new THREE.Vector3(0, 0, 0)) _camera.position.set(0, 300, 600); // 1 - x为0 _camera.position.set(500, 0, 600); // 2 - y为0 _camera.position.set(500, 300, 0); // 3 - z为0 很清楚的看到position决定了我们视野的出发点，但是镜头指向的方向是不变的。 下面我们将position固定，改变相机观察的方向： _camera = new OrthographicCamera(-window.innerWidth / 2, window.innerWidth / 2, window.innerHeight / 2, -window.innerHeight / 2, 0.1, 1000);_camera.position.set(500, 300, 600); _camera.lookAt(new THREE.Vector3(0, 0, 0)) // 1 - 视野指向原点_camera.lookAt(new THREE.Vector3(200, 0, 0)) // 2 - 视野偏向x轴 可见：我们视野的出发点是相同的，但是视野看向的方向发生了改变。 2.4.4 两种相机对比好，有了上面的基础，我们再来写两个例子看一看两个相机的视角对比，为了方便观看，我们创建两个位置不同的几何体： var geometry = new THREE.BoxGeometry(200, 100, 100);var material = new THREE.MeshStandardMaterial(&#123; color: 0x645d50 &#125;);var mesh = new THREE.Mesh(geometry, material);_scene.add(mesh);var geometry = new THREE.SphereGeometry(50, 100, 100);var ball = new THREE.Mesh(geometry, material);ball.position.set(200, 0, -200);_scene.add(ball); 正交投影相机视野： _camera = new OrthographicCamera(-window.innerWidth / 2, window.innerWidth / 2, window.innerHeight / 2, -window.innerHeight / 2, 0.1, 1000);_camera.position.set(0, 300, 600);_camera.lookAt(new THREE.Vector3(0, 0, 0)) 透视相机视野： _camera = new PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1100);_camera.position.set(0, 300, 600);_camera.lookAt(new THREE.Vector3(0, 0, 0)) 可见，这印证了我们上面关于两种相机的理论 2.5 渲染器上面我们创建了场景、元素和相机，下面我们要告诉浏览器将这些东西渲染到浏览器上。 Three.js也为我们提供了几种不同的渲染器，这里我们主要看WebGL渲染器(WebGLRenderer)。顾名思义：WebGL渲染器使用WebGL来绘制场景，其够利用GPU硬件加速从而提高渲染性能。 _renderer = new THREE.WebGLRenderer(); 你需要将你使用Three.js绘制的元素添加到浏览器上，这个过程需要一个载体，上面我们介绍，这个载体就是Canvas，你可以通过_renderer.domElement获取到这个Canvas，并将它给定到真实DOM中。 _container = document.getElementById('conianer');_container.appendChild(_renderer.domElement); 使用setSize函数设定你要渲染的范围，实际上它改变的就是上面Canvas的范围： _renderer.setSize(window.innerWidth, window.innerHeight); 现在，你已经指定了一个渲染的载体和载体的范围，你可以通过render函数渲染上面指定的场景和相机： _renderer.render(_scene, _camera); 实际上，你如果依次执行上面的代码，可能屏幕上还是黑漆漆的一片，并没有任何元素渲染出来。 这是因为上面你要渲染的元素可能并未被加载完，你就执行了渲染，并且只执行了一次，这时我们需要一种方法，让场景和相机进行实时渲染，我们需要用到下面的方法： 2.6 requestAnimationFramewindow.requestAnimationFrame()告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。 该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。 window.requestAnimationFrame(callback); 若你想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调用window.requestAnimationFrame()。 使用者韩函数就意味着，你可以在requestAnimationFrame不停的执行绘制操作，浏览器就实时的知道它需要渲染的内容。 当然，某些时候你已经不需要实时绘制了，你也可以使用cancelAnimationFrame立即停止这个绘制： window.cancelAnimationFrame(myReq); 来看一个简单的例子： var i = 0;var animateName;animate();function animate() &#123; animateName = requestAnimationFrame(animate); console.log(i++); if (i &gt; 100) &#123; cancelAnimationFrame(animateName); &#125;&#125; 来看一下执行效果： 我们使用requestAnimationFrame和Three.js的渲染器结合使用，这样就能实时绘制三维动画了： function animate() &#123; requestAnimationFrame(animate); _renderer.render(_scene, _camera);&#125; 借助上面的代码，我们可以简单实现一些动画效果： var y = 100;var option = 'down';function animateIn() &#123; animateName = requestAnimationFrame(animateIn); mesh.rotateX(Math.PI / 40); if (option == 'up') &#123; ball.position.set(200, y += 8, 0); &#125; else &#123; ball.position.set(200, y -= 8, 0); &#125; if (y &lt; 1) &#123; option = 'up'; &#125; if (y &gt; 100) &#123; option = 'down' &#125;&#125; 2.7 总结上面的知识是Three.js中最基础的知识，也是最重要的和最主干的。 这些知识能够让你在看到一个复杂的三维效果时有一定的思路，当然，要实现还需要非常多的细节。这些细节你可以去官方文档中查阅。 下面的章节即告诉你如何使用Three.js进行实战 — 实现一个360度全景插件。 这个插件包括两部分，第一部分是对全景图进行预览。 第二部分是对全景图的标记进行配置，并关联预览的坐标。 我们首先来看看全景预览部分： 三、全景预览 3.1 基本逻辑 将一张全景图包裹在球体的内壁 设定一个观察点，在球的圆心 使用鼠标可以拖动球体，从而改变我们看到全景的视野 鼠标滚轮可以缩放，和放大，改变观察全景的远近 根据坐标在全景图上挂载一些标记，如文字、图标等，并且可以增加事件，如点击事件 3.2 初始化我们先把必要的基础设施搭建起来： 场景、相机（选择远景相机，这样可以让全景看起来更真实）、渲染器： _scene = new THREE.Scene();initCamera();initRenderer();animate();// 初始化相机function initCamera() &#123; _camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1100); _camera.position.set(0, 0, 2000); _camera.lookAt(new THREE.Vector3(0, 0, 0));&#125;// 初始化渲染器function initRenderer() &#123; _renderer = new THREE.WebGLRenderer(); _renderer.setSize(window.innerWidth, window.innerHeight); _container = document.getElementById('panoramaConianer'); _container.appendChild(_renderer.domElement);&#125;// 实时渲染function animate() &#123; requestAnimationFrame(animate); _renderer.render(_scene, _camera);&#125; 下面我们在场景内添加一个球体，并把全景图作为材料包裹在球体上面： var mesh = new THREE.Mesh(new THREE.SphereGeometry(1000, 100, 100),new THREE.MeshBasicMaterial( &#123; map: ImageUtils.loadTexture('img/p3.png') &#125; ));_scene.add(mesh); 然后我们看到的场景应该是这样的： 这不是我们想要的效果，我们想要的是从球的内部观察全景，并且全景图是附着外球的内壁的，而不是铺在外面： 我们只要需将Material的scale的一个属性设置为负值，材料即可附着在几何体的内部： mesh.scale.x = -1; 然后我们将相机的中心点移动到球的中心： _camera.position.set(0, 0, 0); 现在我们已经在全景球的内部啦： 3.3 事件处理全景图已经可以浏览了，但是你只能看到你眼前的这一块，并不能拖动它看到其他部分，为了精确的控制拖动的速度和缩放、放大等场景，我们手动为它增加一些事件： 监听鼠标的mousedown事件，在此时将开始拖动标记_isUserInteracting设置为true，并且记录起始的屏幕坐标，以及起始的相机lookAt的坐标。 _container.addEventListener('mousedown', (event)=&gt;&#123; event.preventDefault(); _isUserInteracting = true; _onPointerDownPointerX = event.clientX; _onPointerDownPointerY = event.clientY; _onPointerDownLon = _lon; _onPointerDownLat = _lat;&#125;); 监听鼠标的mousemove事件，当_isUserInteracting为true时，实时计算当前相机lookAt的真实坐标。 _container.addEventListener('mousemove', (event)=&gt;&#123; if (_isUserInteracting) &#123; _lon = (_onPointerDownPointerX - event.clientX) * 0.1 + _onPointerDownLon; _lat = (event.clientY - _onPointerDownPointerY) * 0.1 + _onPointerDownLat; &#125;&#125;); 监听鼠标的mouseup事件，将_isUserInteracting设置为false。 _container.addEventListener('mouseup', (event)=&gt;&#123; _isUserInteracting = false;&#125;); 当然，上面我们只是改变了坐标，并没有告诉相机它改变了，我们在animate函数中来做这件事： function animate() &#123; requestAnimationFrame(animate); calPosition(); _renderer.render(_scene, _camera); _renderer.render(_sceneOrtho, _cameraOrtho);&#125;function calPosition() &#123; _lat = Math.max(-85, Math.min(85, _lat)); var phi = tMath.degToRad(90 - _lat); var theta = tMath.degToRad(_lon); _camera.target.x = _pRadius * Math.sin(phi) * Math.cos(theta); _camera.target.y = _pRadius * Math.cos(phi); _camera.target.z = _pRadius * Math.sin(phi) * Math.sin(theta); _camera.lookAt(_camera.target);&#125; 监听mousewheel事件，对全景图进行放大和缩小，注意这里指定了最大缩放范围maxFocalLength和最小缩放范围minFocalLength。 _container.addEventListener('mousewheel', (event)=&gt;&#123; var ev = ev || window.event; var down = true; var m = _camera.getFocalLength(); down = ev.wheelDelta ? ev.wheelDelta &lt; 0 : ev.detail &gt; 0; if (down) &#123; if (m &gt; minFocalLength) &#123; m -= m * 0.05 _camera.setFocalLength(m); &#125; &#125; else &#123; if (m &lt; maxFocalLength) &#123; m += m * 0.05 _camera.setFocalLength(m); &#125; &#125;&#125;); 来看一下效果吧： 3.4 增加标记在浏览全景图的时候，我们往往需要对某些特殊的位置进行一些标记，并且这些标记可能附带一些事件，比如你需要点击一个标记才能到达下一张全景图。 下面我们来看看如何在全景中增加标记，以及如何为这些标记添加事件。 我们可能不需要让这些标记随着视野的变化而放大和缩小，基于此，我们使用正交投影相机来展现标记，只需给它一个固定的观察高度： _cameraOrtho = new THREE.OrthographicCamera(-window.innerWidth / 2, window.innerWidth / 2, window.innerHeight / 2, -window.innerHeight / 2, 1, 10);_cameraOrtho.position.z = 10;_sceneOrtho = new Scene(); 利用精灵材料(SpriteMaterial)来实现文字标记，或者图片标记： // 创建文字标记function createLableSprite(name) &#123; const canvas = document.createElement('canvas'); const context = canvas.getContext('2d'); const metrics = context.measureText(name); const width = metrics.width * 1.5; context.font = \"10px 宋体\"; context.fillStyle = \"rgba(0,0,0,0.95)\"; context.fillRect(2, 2, width + 4, 20 + 4); context.fillText(name, 4, 20); const texture = new Texture(canvas); const spriteMaterial = new SpriteMaterial(&#123; map: texture &#125;); const sprite = new Sprite(spriteMaterial); sprite.name = name; const lable = &#123; name: name, canvas: canvas, context: context, texture: texture, sprite: sprite &#125;; _sceneOrtho.add(lable.sprite); return lable;&#125;// 创建图片标记function createSprite(position, url, name) &#123; const textureLoader = new TextureLoader(); const ballMaterial = new SpriteMaterial(&#123; map: textureLoader.load(url) &#125;); const sp = &#123; pos: position, name: name, sprite: new Sprite(ballMaterial) &#125;; sp.sprite.scale.set(32, 32, 1.0); sp.sprite.name = name; _sceneOrtho.add(sp.sprite); return sp;&#125; 创建好这些标记，我们把它渲染到场景中。 我们必须告诉场景这些标记的位置，为了直观的理解，我们需要给这些标记赋予一种坐标，这种坐标很类似于经纬度，我们叫它lon和lat，具体是如何给定的我们在下面的章节：全景标记中会详细介绍。 在这个过程中，一共经历了两次坐标转换： 第一次转换：将“经纬度”转换为三维空间坐标，即我们上面讲的那种x、y、z形式的坐标。 使用geoPosition2World函数进行转换，得到一个Vector3对象，我们可以将当前相机_camera作为参数传入这个对象的project方法，这会得到一个标准化后的坐标，基于这个坐标可以帮我们判断标记是否在视野范围内，如下面的代码，若标准化坐标在-1和1的范围内，则它会出现在我们的视野中，我们将它进行准确渲染。 第二次转换：将三维空间坐标转换为屏幕坐标。 如果我们直接讲上面的三维空间坐标坐标应用到标记中，我们会发现无论视野如何移动，标记的位置是不会有任何变化的，因为这样算出来的坐标永远是一个常量。 所以我们需要借助上面的标准化坐标，将标记的三维空间坐标转换为真实的屏幕坐标，这个过程是worldPostion2Screen函数来实现的。 关于geoPosition2World和worldPostion2Screen两个函数的实现，大家有兴趣可以去我的github源码中查看，这里就不多做解释了，因为这又要牵扯到一大堆专业知识啦。😅 var wp = geoPosition2World(_sprites.lon, _sprites.lat);var sp = worldPostion2Screen(wp, _camera);var test = wp.clone();test.project(_camera);if (test.x &gt; -1 &amp;&amp; test.x &lt; 1 &amp;&amp; test.y &gt; -1 &amp;&amp; test.y &lt; 1 &amp;&amp; test.z &gt; -1 &amp;&amp; test.z &lt; 1) &#123; _sprites[i].sprite.scale.set(32, 32, 32); _sprites[i].sprite.position.set(sp.x, sp.y, 1);&#125;else &#123; _sprites[i].sprite.scale.set(1.0, 1.0, 1.0); _sprites[i].sprite.position.set(0, 0, 0);&#125; 现在，标记已经添加到全景上面了，我们来为它添加一个点击事件： Three.js并没有单独提供为Sprite添加事件的方法，我们可以借助光线投射器（Raycaster）来实现。 Raycaster提供了鼠标拾取的能力： 通过setFromCamera函数来建立当前点击的坐标（经过归一化处理）和相机的绑定关系。 通过intersectObjects来判定一组对象中有哪些被命中（点击），得到被命中的对象数组。 这样，我们就可以获取到点击的对象，并基于它做一些处理： _container.addEventListener('click', (event)=&gt;&#123; _mouse.x = (event.clientX / window.innerWidth) * 2 - 1; _mouse.y = -(event.clientY / window.innerHeight) * 2 + 1; _raycaster.setFromCamera(_mouse, _cameraOrtho); var intersects = _raycaster.intersectObjects(_clickableObjects); intersects.forEach(function (element) &#123; alert(\"点击到了: \" + element.object.name); &#125;);&#125;); 点击到一个标记，进入到下一张全景图： 四、全景标记为了让全景图知道，我要把标记标注在什么地方，我需要一个工具来把原图和全景图上的位置关联起来： 由于这部分代码和Three.js关系不大，这里我只说一下基本的实现逻辑，有兴趣可以去我的github仓库查看。 4.1 要求 建立坐标和全景的映射关系，为全景赋予一套虚拟坐标 在一张平铺的全景图上，可以在任意位置增加标记，并获取标记的坐标 使用坐标在预览全景增加标记，看到的标记位置和平铺全景中的位置相同 4.2 坐标在2D平面上，我们能监听屏幕的鼠标事件，我们可以获取的也只是当前的鼠标坐标，我们要做的是将鼠标坐标转换成三维空间坐标。 看起来好像是不可能的，二维坐标怎么能转换成三维坐标呢？ 但是，我们可以借助一种中间坐标来转换，可以把它称之为“经纬度”。 在这之前，我们先来看看我们常说的经纬度到底是什么。 4.3 经纬度使用经纬度，可以精确的定位到地球上任意一个点，它的计算规则是这样的： 通常把连接南极到北极的线叫做子午线也叫经线，其所对应的面叫做子午面，规定英国伦敦格林尼治天文台原址的那条经线称为0°经线，也叫本初子午线其对应的面即本初子午面。 经度：球面上某店对应的子午面与本初子午面间的夹角。东正西负。 纬度 ：球面上某点的法线（以该店作为切点与球面相切的面的法线）与赤道平面的夹角。北正南负。 由此，地球上每一个点都能被对应到一个经度和纬度，想对应的，也能对应到某条经线和纬线上。 这样，即使把球面展开称平面，我们仍然能用经纬度表示某店\b点的位置： 4.4 坐标转换基于上面的分析，我们完全可以给平面的全景图赋予一个虚拟的“经纬度”。我们使用Canvas为它绘制一张”经纬网”： 将鼠标坐标转换为”经纬度”： function calLonLat(e) &#123; var h = _setContainer.style.height.split(\"px\")[0]; var w = _setContainer.style.width.split(\"px\")[0]; var ix = _setContainer.offsetLeft; var iy = _setContainer.offsetTop; iy = iy + h; var x = e.clientX; var y = e.clientY; var lonS = (x - ix) / w; var lon = 0; if (lonS &gt; 0.5) &#123; lon = -(1 - lonS) * 360; &#125; else &#123; lon = 1 * 360 * lonS; &#125; var latS = (iy - y) / h; var lat = 0; if (latS &gt; 0.5) &#123; lat = (latS - 0.5) * 180; &#125; else &#123; lat = (0.5 - latS) * 180 * -1 &#125; lon = lon.toFixed(2); lat = lat.toFixed(2); return &#123; lon: lon, lat: lat &#125;;&#125; 这样平面地图上的某点就可以和三维坐标关联起来了，当然，这还需要一定的转换，有兴趣可以去源码研究下geoPosition2World和worldPostion2Screen两个函数。 五、插件封装上面的代码中，我们实现了全景预览和全景标记的功能，下面，我们要把这些功能封装成插件。 所谓插件，即可以直接引用你写的代码，并添加少量的配置就可以实现想要的功能。 5.1 全景预览封装我们来看看，究竟哪些配置是可以抽取出来的： var options = &#123; container: 'panoramaConianer', url: 'resources/img/panorama/pano-7.jpg', lables: [], widthSegments: 60, heightSegments: 40, pRadius: 1000, minFocalLength: 1, maxFocalLength: 100, sprite: 'label', onClick: () =&gt; &#123; &#125;&#125; container:dom容器的id url:图片路径 lables:全景中的标记数组，格式为{position:{lon:114,lat:38},logoUrl:&#39;lableLogo.png&#39;,text:&#39;name&#39;} widthSegments:水平切段数 heightSegments:垂直切段数（值小粗糙速度快，值大精细速度慢） pRadius:全景球的半径，推荐使用默认值 minFocalLength:镜头最小拉近距离 maxFocalLength:镜头最大拉近距离 sprite:展示的标记类型label,icon onClick:标记的点击事件 上面的配置是可以用户配置的，那么用户该如何传入插件呢？ 我们可以在插件中声明一些默认配置options，用户使用构造函数传入参数，然后使用Object.assign将传入配置覆盖到默认配置。 接下来，你就可以使用this.def来访问这些变量了，然后只需要把写死的代码改成这些配置即可。 options = &#123; // 默认配置...&#125;function tpanorama(opt) &#123; this.render(opt);&#125;tpanorama.prototype = &#123; constructor: this, def: &#123;&#125;, render: function (opt) &#123; this.def = Object.assign(options, opt); // 初始化操作... &#125;&#125; 5.2 全景标记封装基本逻辑和上面的类似，下面是提取出来的一些参数。 var setOpt = &#123; container: 'myDiv',//setting容器 imgUrl: 'resources/img/panorama/3.jpg', width: '',//指定宽度，高度自适应 showGrid: true,//是否显示格网 showPosition: true,//是否显示经纬度提示 lableColor: '#9400D3',//标记颜色 gridColor: '#48D1CC',//格网颜色 lables: [],//标记 &#123;lon:114,lat:38,text:'标记一'&#125; addLable: true,//开启后双击添加标记 (必须开启经纬度提示) getLable: true,//开启后右键查询标记 (必须开启经纬度提示) deleteLbale: true,//开启默认中键删除 （必须开启经纬度提示）&#125; 六、发布接下来，我们就好考虑如何将写好的插件让用户使用了。 我们主要考虑两种场景，直接引用和npm install 6.1 直接引用JS为了不污染全局变量，我们使用一个自执行函数(function(){}())将代码包起来，然后将我们写好的插件暴露给全局变量window。 我把它放在originSrc目录下。 (function (global, undefined) &#123; function tpanorama(opt) &#123; // ... &#125; tpanorama.prototype = &#123; // ... &#125; function tpanoramaSetting(opt) &#123; // ... &#125; tpanoramaSetting.prototype = &#123; // ... &#125; global.tpanorama = tpanorama; global.tpanoramaSetting = panoramaSetting;&#125;(window)) 6.2 使用npm install直接将写好的插件导出： module.exports = tpanorama;module.exports = panoramaSetting; 我把它放在src目录下。 同时，我们要把package.json中的main属性指向我们要导出的文件：&quot;main&quot;: &quot;lib/index.js&quot;，然后将name、description、version等信息补充完整。 下面，我们就可以开始发布了，首先你要有一个npm账号，并且登陆，如果你没有账号，使用下面的命令创建一个账号。 npm adduser --registry http://registry.npmjs.org 如果你已经有账号了，那么可以直接使用下面的命令进行登陆。 npm login --registry http://registry.npmjs.org 登陆成功之后，就可以发布了： npm publish --registry http://registry.npmjs.org 注意，上面每个命令我都手动指定了registry，这是因为当前你使用的npm源可能已经被更换了，可能使用的是淘宝源或者公司源，这时不手动指定会导致发布失败。 发布成功后直接在npm官网上看到你的包了。 然后，你可以直接使用npm install tpanorama进行安装，然后进行使用： var &#123; tpanorama,tpanoramaSetting &#125; = require('tpanorama'); 6.3 babel编译最后不要忘了，无论使用以上哪种方式，我们都要使用babel编译后才能暴露给用户。 在scripts中创建一个build命令，将源文件进行编译，最终暴露给用户使用的将是lib和origin。 \"build\": \"babel src --out-dir lib &amp;&amp; babel originSrc --out-dir origin\", 你还可以指定一些其他的命令来供用户测试，如我将写好的例子全部放在examples中，然后在scripts定义了expamle命令： \"example\": \"npm run webpack &amp;&amp; node ./server/www\" 这样，用户将代码克隆后直接在本地运行npm run example就可以进行调试了。 七、小结本项目的github地址：https://github.com/ConardLi/tpanorama 文中如有错误，欢迎在评论区指正，如果这篇文章帮助到了你，欢迎点赞和关注。","categories":[],"tags":[{"name":"特效","slug":"特效","permalink":"www.conardli.top/tags/特效/"}]},{"title":"【自检】前端知识清单","slug":"【自检】前端知识清单","date":"2019-04-26T01:11:22.000Z","updated":"2019-05-18T04:35:20.200Z","comments":true,"path":"2019/04/26/【自检】前端知识清单/","link":"","permalink":"www.conardli.top/2019/04/26/【自检】前端知识清单/","excerpt":"","text":"开篇前端开发是一个非常特殊的行业，它的历史实际上不是很长，但是知识之繁杂，技术迭代速度之快是其他技术所不能比拟的。 winter在他的《重学前端》课程中提到： 到现在为止，前端工程师已经成为研发体系中的重要岗位之一。可是，与此相对的是，我发现极少或者几乎没有大学的计算机专业愿意开设前端课程，更没有系统性的教学方案出现。大部分前端工程师的知识，其实都是来自于实践和工作中零散的学习。 这样是一个非常真实的现状，实际上很多前端开发者都是自学甚至转行过来的，前端入门简单，学习了几个API以后上手做项目也很简单，但是这往往成为了限制自身发展的瓶颈。 只是停留在会用阶段是远远不够的，我们还需要不断探索和深入。现在市面上并不缺少学习教程，技术文章，如果盲目的学习你会发现看过以后的知识留存率会很低，而且发现没有了解到的知识越来越多，这会让人产生焦虑。 实际上，除了坚持学习的强大的自驱力，你还需要一个很简单的学习方法。那就是：建立自己的知识体系。它能帮助你更系统性的学习，同时你也时刻能知道自己哪些地方是不足的。 我会把我工作和学习中接触到的知识全部归纳到我的知识体系中，其中不仅仅包括我已经学过的，还有很多我没有来得及学习的。 这不仅仅是我的知识体系，更是我时刻提醒自己的自检清单。 下面我会把我的自检清单分享给大家，你可以按照清单上的知识检测自己还有哪些不足和提升，我也建议大家建自己的知识体系，这样工作或者学习甚至面试时，你能快速定位到知识清单中的点，如果你有哪些我没归纳到的点，欢迎在评论区告诉我。 一、JavaScript基础 前端工程师吃饭的家伙，深度、广度一样都不能差。 变量和类型 1.JavaScript规定了几种语言类型 2.JavaScript对象的底层数据结构是什么 3.Symbol类型在实际开发中的应用、可手动实现一个简单的Symbol 4.JavaScript中的变量在内存中的具体存储形式 5.基本类型对应的内置对象，以及他们之间的装箱拆箱操作 6.理解值类型和引用类型 7.null和undefined的区别 8.至少可以说出三种判断JavaScript数据类型的方式，以及他们的优缺点，如何准确的判断数组类型 9.可能发生隐式类型转换的场景以及转换原则，应如何避免或巧妙应用 10.出现小数精度丢失的原因，JavaScript可以存储的最大数字、最大安全数字，JavaScript处理大数字的方法、避免精度丢失的方法 原型和原型链 1.理解原型设计模式以及JavaScript中的原型规则 2.instanceof的底层实现原理，手动实现一个instanceof 4.实现继承的几种方式以及他们的优缺点 5.至少说出一种开源项目(如Node)中应用原型继承的案例 6.可以描述new一个对象的详细过程，手动实现一个new操作符 7.理解es6 class构造以及继承的底层实现原理 作用域和闭包 1.理解词法作用域和动态作用域 2.理解JavaScript的作用域和作用域链 3.理解JavaScript的执行上下文栈，可以应用堆栈信息快速定位问题 4.this的原理以及几种不同使用场景的取值 5.闭包的实现原理和作用，可以列举几个开发中闭包的实际应用 6.理解堆栈溢出和内存泄漏的原理，如何防止 7.如何处理循环的异步操作 8.理解模块化解决的实际问题，可列举几个模块化方案并理解其中原理 执行机制 1.为何try里面放return，finally还会执行，理解其内部机制 2.JavaScript如何实现异步编程，可以详细描述EventLoop机制 3.宏任务和微任务分别有哪些 4.可以快速分析一个复杂的异步嵌套逻辑，并掌握分析方法 5.使用Promise实现串行 6.Node与浏览器EventLoop的差异 7.如何在保证页面运行流畅的情况下处理海量数据 语法和API 1.理解ECMAScript和JavaScript的关系 2.熟练运用es5、es6提供的语法规范， 3.熟练掌握JavaScript提供的全局对象（例如Date、Math）、全局函数（例如decodeURI、isNaN）、全局属性（例如Infinity、undefined） 4.熟练应用map、reduce、filter 等高阶函数解决问题 5.setInterval需要注意的点，使用settimeout实现setInterval 6.JavaScript提供的正则表达式API、可以使用正则表达式（邮箱校验、URL解析、去重等）解决常见问题 7.JavaScript异常处理的方式，统一的异常处理方案 二、HTML和CSSHTML 1.从规范的角度理解HTML，从分类和语义的角度使用标签 2.常用页面标签的默认样式、自带属性、不同浏览器的差异、处理浏览器兼容问题的方式 3.元信息类标签(head、title、meta)的使用目的和配置方法 4.HTML5离线缓存原理 5.可以使用Canvas API、SVG等绘制高性能的动画 CSS 1.CSS盒模型，在不同浏览器的差异 2.CSS所有选择器及其优先级、使用场景，哪些可以继承，如何运用at规则 3.CSS伪类和伪元素有哪些，它们的区别和实际应用 4.HTML文档流的排版规则，CSS几种定位的规则、定位参照物、对文档流的影响，如何选择最好的定位方式，雪碧图实现原理 5.水平垂直居中的方案、可以实现6种以上并对比它们的优缺点 6.BFC实现原理，可以解决的问题，如何创建BFC 7.可使用CSS函数复用代码，实现特殊效果 8.PostCSS、Sass、Less的异同，以及使用配置，至少掌握一种 9.CSS模块化方案、如何配置按需加载、如何防止CSS阻塞渲染 10.熟练使用CSS实现常见动画，如渐变、移动、旋转、缩放等等 11.CSS浏览器兼容性写法，了解不同API在不同浏览器下的兼容性情况 12.掌握一套完整的响应式布局方案 手写 1.手写图片瀑布流效果 2.使用CSS绘制几何图形（圆形、三角形、扇形、菱形等） 3.使用纯CSS实现曲线运动（贝塞尔曲线） 4.实现常用布局（三栏、圣杯、双飞翼、吸顶），可是说出多种方式并理解其优缺点 三、计算机基础 关于编译原理，不需要理解非常深入，但是最基本的原理和概念一定要懂，这对于学习一门编程语言非常重要 编译原理 1.理解代码到底是什么，计算机如何将代码转换为可以运行的目标程序 2.正则表达式的匹配原理和性能优化 3.如何将JavaScript代码解析成抽象语法树(AST) 4.base64的编码原理 5.几种进制的相互转换计算方法，在JavaScript中如何表示和转换 网络协议 1.理解什么是协议，了解TCP/IP网络协议族的构成，每层协议在应用程序中发挥的作用 2.三次握手和四次挥手详细原理，为什么要使用这种机制 3.有哪些协议是可靠，TCP有哪些手段保证可靠交付 4.DNS的作用、DNS解析的详细过程，DNS优化原理 5.CDN的作用和原理 6.HTTP请求报文和响应报文的具体组成，能理解常见请求头的含义，有几种请求方式，区别是什么 7.HTTP所有状态码的具体含义，看到异常状态码能快速定位问题 8.HTTP1.1、HTTP2.0带来的改变 9.HTTPS的加密原理，如何开启HTTPS，如何劫持HTTPS请求 10.理解WebSocket协议的底层原理、与HTTP的区别 设计模式 1.熟练使用前端常用的设计模式编写代码，如单例模式、装饰器模式、代理模式等 2.发布订阅模式和观察者模式的异同以及实际应用 3.可以说出几种设计模式在开发中的实际应用，理解框架源码中对设计模式的应用 四、数据结构和算法 据我了解的大部分前端对这部分知识有些欠缺，甚至抵触，但是，如果突破更高的天花板，这部分知识是必不可少的，而且我亲身经历——非常有用！ JavaScript编码能力 1.多种方式实现数组去重、扁平化、对比优缺点 2.多种方式实现深拷贝、对比优缺点 3.手写函数柯里化工具函数、并理解其应用场景和优势 4.手写防抖和节流工具函数、并理解其内部原理和应用场景 5.实现一个sleep函数 手动实现前端轮子 1.手动实现call、apply、bind 2.手动实现符合Promise/A+规范的Promise、手动实现async await 3.手写一个EventEmitter实现事件发布、订阅 4.可以说出两种实现双向绑定的方案、可以手动实现 5.手写JSON.stringify、JSON.parse 6.手写一个模版引擎，并能解释其中原理 7.手写懒加载、下拉刷新、上拉加载、预加载等效果 数据结构 1.理解常见数据结构的特点，以及他们在不同场景下使用的优缺点 2.理解数组、字符串的存储原理，并熟练应用他们解决问题 3.理解二叉树、栈、队列、哈希表的基本结构和特点，并可以应用它解决问题 4.了解图、堆的基本结构和使用场景 算法 1.可计算一个算法的时间复杂度和空间复杂度，可估计业务逻辑代码的耗时和内存消耗 2.至少理解五种排序算法的实现原理、应用场景、优缺点，可快速说出时间、空间复杂度 3.了解递归和循环的优缺点、应用场景、并可在开发中熟练应用 4.可应用回溯算法、贪心算法、分治算法、动态规划等解决复杂问题 5.前端处理海量数据的算法方案 五、运行环境我们需要理清语言和环境的关系： ECMAScript描述了JavaScript语言的语法和基本对象规范 浏览器作为JavaScript的一种运行环境，为它提供了：文档对象模型（DOM），描述处理网页内容的方法和接口、浏览器对象模型（BOM），描述与浏览器进行交互的方法和接口 Node也是JavaScript的一种运行环境，为它提供了操作I/O、网络等API 浏览器API 1.浏览器提供的符合W3C标准的DOM操作API、浏览器差异、兼容性 2.浏览器提供的浏览器对象模型 (BOM)提供的所有全局API、浏览器差异、兼容性 3.大量DOM操作、海量数据的性能优化(合并操作、Diff、requestAnimationFrame等) 4.浏览器海量数据存储、操作性能优化 5.DOM事件流的具体实现机制、不同浏览器的差异、事件代理 6.前端发起网络请求的几种方式及其底层实现、可以手写原生ajax、fetch、可以熟练使用第三方库 7.浏览器的同源策略，如何避免同源策略，几种方式的异同点以及如何选型 8.浏览器提供的几种存储机制、优缺点、开发中正确的选择 9.浏览器跨标签通信 浏览器原理 1.各浏览器使用的JavaScript引擎以及它们的异同点、如何在代码中进行区分 2.请求数据到请求结束与服务器进行了几次交互 3.可详细描述浏览器从输入URL到页面展现的详细过程 4.浏览器解析HTML代码的原理，以及构建DOM树的流程 5.浏览器如何解析CSS规则，并将其应用到DOM树上 6.浏览器如何将解析好的带有样式的DOM树进行绘制 7.浏览器的运行机制，如何配置资源异步同步加载 8.浏览器回流与重绘的底层原理，引发原因，如何有效避免 9.浏览器的垃圾回收机制，如何避免内存泄漏 10.浏览器采用的缓存方案，如何选择和控制合适的缓存方案 Node 1.理解Node在应用程序中的作用，可以使用Node搭建前端运行环境、使用Node操作文件、操作数据库等等 2.掌握一种Node开发框架，如Express，Express和Koa的区别 3.熟练使用Node提供的API如Path、Http、Child Process等并理解其实现原理 4.Node的底层运行原理、和浏览器的异同 5.Node事件驱动、非阻塞机制的实现原理 六、框架和类库 轮子层出不穷，从原理上理解才是正道 TypeScript 1.理解泛型、接口等面向对象的相关概念，TypeScript对面向对象理念的实现 2.理解使用TypeScript的好处，掌握TypeScript基础语法 3.TypeScript的规则检测原理 4.可以在React、Vue等框架中使用TypeScript进行开发 React 1.React和vue选型和优缺点、核心架构的区别 2.React中setState的执行机制，如何有效的管理状态 3.React的事件底层实现机制 4.React的虚拟DOM和Diff算法的内部实现 5.React的Fiber工作原理，解决了什么问题 6.React Router和Vue Router的底层实现原理、动态加载实现原理 7.可熟练应用React API、生命周期等，可应用HOC、render props、Hooks等高阶用法解决问题 8.基于React的特性和原理，可以手动实现一个简单的React Vue 1.熟练使用Vue的API、生命周期、钩子函数 2.MVVM框架设计理念 3.Vue双向绑定实现原理、Diff算法的内部实现 4.Vue的事件机制 5.从template转换成真实DOM的实现机制 多端开发 1.单页面应用（SPA）的原理和优缺点，掌握一种快速开发SPA的方案 2.理解Viewport、em、rem的原理和用法，分辨率、px、ppi、dpi、dp的区别和实际应用 3.移动端页面适配解决方案、不同机型适配方案 4.掌握一种JavaScript移动客户端开发技术，如React Native：可以搭建React Native开发环境，熟练进行开发，可理解React Native的运作原理，不同端适配 5.掌握一种JavaScript PC客户端开发技术，如Electron：可搭建Electron开发环境，熟练进行开发，可理解Electron的运作原理 6.掌握一种小程序开发框架或原生小程序开发 7.理解多端框架的内部实现原理，至少了解一个多端框架的使用 数据流管理 1.掌握React和Vue传统的跨组件通信方案，对比采用数据流管理框架的异同 2.熟练使用Redux管理数据流，并理解其实现原理，中间件实现原理 3.熟练使用Mobx管理数据流，并理解其实现原理，相比Redux有什么优势 4.熟练使用Vuex管理数据流，并理解其实现原理 5.以上数据流方案的异同和优缺点，不情况下的技术选型 实用库 1.至少掌握一种UI组件框架，如antd design，理解其设计理念、底层实现 2.掌握一种图表绘制框架，如Echart，理解其设计理念、底层实现，可以自己实现图表 3.掌握一种GIS开发框架，如百度地图API 4.掌握一种可视化开发框架，如Three.js、D3 5.工具函数库，如lodash、underscore、moment等，理解使用的工具类或工具函数的具体实现原理 开发和调试 1.熟练使用各浏览器提供的调试工具 2.熟练使用一种代理工具实现请求代理、抓包，如charls 3.可以使用Android、IOS模拟器进行调试，并掌握一种真机调试方案 4.了解Vue、React等框架调试工具的使用 七、前端工程 前端工程化：以工程化方法和工具提高开发生产效率、降低维护难度 项目构建 1.理解npm、yarn依赖包管理的原理，两者的区别 2.可以使用npm运行自定义脚本 3.理解Babel、ESLint、webpack等工具在项目中承担的作用 4.ESLint规则检测原理，常用的ESLint配置 5.Babel的核心原理，可以自己编写一个Babel插件 6.可以配置一种前端代码兼容方案，如Polyfill 7.Webpack的编译原理、构建流程、热更新原理，chunk、bundle和module的区别和应用 8.可熟练配置已有的loaders和plugins解决问题，可以自己编写loaders和plugins nginx 1.正向代理与反向代理的特点和实例 2.可手动搭建一个简单的nginx服务器、 3.熟练应用常用的nginx内置变量，掌握常用的匹配规则写法 4.可以用nginx实现请求过滤、配置gzip、负载均衡等，并能解释其内部原理 开发提速 1.熟练掌握一种接口管理、接口mock工具的使用，如yapi 2.掌握一种高效的日志埋点方案，可快速使用日志查询工具定位线上问题 3.理解TDD与BDD模式，至少会使用一种前端单元测试框架 版本控制 1.理解Git的核心原理、工作流程、和SVN的区别 2.熟练使用常规的Git命令、git rebase、git stash等进阶命令 3.可以快速解决线上分支回滚、线上分支错误合并等复杂问题 持续集成 1.理解CI/CD技术的意义，至少熟练掌握一种CI/CD工具的使用，如Jenkins 2.可以独自完成架构设计、技术选型、环境搭建、全流程开发、部署上线等一套完整的开发流程（包括Web应用、移动客户端应用、PC客户端应用、小程序、H5等等） 八、项目和业务后端技能 1.了解后端的开发方式，在应用程序中的作用，至少会使用一种后端语言 2.掌握数据最终在数据库中是如何落地存储的，能看懂表结构设计、表之间的关联，至少会使用一种数据库 性能优化 1.了解前端性能衡量指标、性能监控要点，掌握一种前端性能监控方案 2.了解常见的Web、App性能优化方案 3.SEO排名规则、SEO优化方案、前后端分离的SEO 4.SSR实现方案、优缺点、及其性能优化 5.Webpack的性能优化方案 6.Canvas性能优化方案 7.React、Vue等框架使用性能优化方案 前端安全 1.XSS攻击的原理、分类、具体案例，前端如何防御 2.CSRF攻击的原理、具体案例，前端如何防御 3.HTTP劫持、页面劫持的原理、防御措施 业务相关 1.能理解所开发项目的整体业务形态、业务目标、业务架构，可以快速定位线上业务问题 2.能理解所开发项目整体的技术架构、能快读的根据新需求进行开发规划、能快速根据业务报警、线上日志等定位并解决线上技术问题 3.可以将自己的想法或新技术在业务中落地实践，尽量在团队中拥有一定的不可替代性 九、学习提升vczh大神在知乎问题【如何能以后达到温赵轮三位大神的水平？】下的回答： 这十几年我一共做了三件事： 1、不以赚钱为目的选择学习的内容； 2、以自己是否能造出轮子来衡量学习的效果； 3、坚持每天写自己的代码，前10年每天至少6个小时，不包含学习和工作的时间。 上面几点可能有点难，第一点我就做不到，但是做到下面绩点还是比较容易的。 关于写博客说明下，能给别人讲明白的知识会比自己学习掌握的要深刻许多 1.拥有自己的技术博客，或者在一些博客平台上拥有自己的专栏 2.定期的将知识进行总结，不断完善自己的知识体系 3.尽量将自己的知识转换成真实的产出，不要仅仅停留在书面理解层面，更重要的是实际应用 4.坚持输出自己的代码，不要盲目的扎进公司业 十、技术之外 这部分可能比上面九条加起来重要！ 1.了解互联网人员术语：CEO、CTO、COO、CFO、PM、QA、UI、FE、DEV、DBA、OPS等 2.了解互联网行业术语：B2B、B2C、C2C、O2O等 3.掌握互联网行业沟通、问答、学习的 4.有一定的&quot;PPT&quot;能力 5.有一定的理财意识，至少了解储蓄、货币基金、保险、指数基金、股票等基本的理财知识 6.掌握在繁重的工作和长期的电脑辐射的情况下保持健康的方法，建立正确的养生知识体系 十一、资源推荐有了知识体系，在阅读一篇技术文章的时候就很容易把它归类，我一直以来就是这样做的。 事实证明，在阅读文章或书籍时，有目的和归类的阅读比”随便看看”后的只是留存率要高很多。 每阅读到一篇好的文章或者书籍，我都会收藏并归类到我的知识体系中。 下面是一些我觉得还不错的文章、博客或者书籍教程等等，分享给大家，资源不多，但都是精品。 学习一门知识，最好先阅读官方文档，把所有的API大概浏览一遍，再继续看大佬们总结的进阶知识，什么东西是搬运过来的，什么是干货，一目了然。 语言基础 [📚]JavaScript高级程序设计（必看）：https://book.douban.com/subject/10546125/ [📚]高性能JavaScript：https://book.douban.com/subject/5362856/ 现代JavaScript教程：https://zh.javascript.info/ 阮一峰的ECMAScript 6教程：http://es6.ruanyifeng.com/ ECMAScript 6标准：https://www.ecma-international.org/ecma-262/6.0/ HTML meta标签总结与属性使用介绍：https://segmentfault.com/a/1190000004279791 CSS编码指导：https://github.com/chadluo/CSS-Guidelines/blob/master/README.md 计算机基础 大前端开发者需要了解的基础编译原理和语言知识：http://fullstack.blog/2017/06/24/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%80%85%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E5%92%8C%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86 图解HTTP：https://book.douban.com/subject/25863515/ [📚]JavaScript设计模式与开发实践：https://book.douban.com/subject/26382780/ 正则表达式30分钟入门教程：https://link.juejin.im/?target=https%3A%2F%2Fdeerchao.net%2Ftutorials%2Fregex%2Fregex.htm 数据结构和算法 数据结构与算法之美：https://time.geekbang.org/column/intro/126 用动画的形式呈现解LeetCode题目的思路：https://github.com/MisterBooo/LeetCodeAnimation JavaScript数据结构和算法：https://github.com/ConardLi/awesome-coding-js 30-seconds-of-code（里面有很多js代码非常巧妙，我正在将它翻译成中文）：https://github.com/ConardLi/30-seconds-of-code-Zh-CN 运行环境 《重学前端》中的浏览器原理章节：https://time.geekbang.org/column/article/80240 图解浏览器的基本工作原理：https://zhuanlan.zhihu.com/p/47407398 七天学会NodeJS：https://github.com/nqdeng/7-days-nodejs Node.js模块加载与运行原理：https://efe.baidu.com/blog/nodejs-module-analyze/ 框架和类库 TypeScript Handbook：https://zhongsp.gitbooks.io/typescript-handbook/content/ React.js小书：http://huziketang.mangojuice.top/books/react/ React深入系列：https://juejin.im/post/5cad39b3f265da03502b1c0a Webpack React小书：https://fakefish.github.io/react-webpack-cookbook/index.html Vue.js技术揭秘：https://github.com/ustbhuangyi/vue-analysis Vuex-在Vue中管理状态：https://sabe.io/tutorials/getting-started-with-vuex 你需要Mobx还是Redux？：https://juejin.im/post/5a7fd72c5188257a766324ae Underscore源码分析：https://yoyoyohamapi.gitbooks.io/undersercore-analysis/content/ 微信小程序开发资源汇总：https://github.com/justjavac/awesome-wechat-weapp 腾讯移动Web前端知识库：https://github.com/AlloyTeam/Mars 前端工程 一口（很长的）气了解babel：https://zhuanlan.zhihu.com/p/43249121 Webpack傻瓜式指南：https://zhuanlan.zhihu.com/p/20367175 Webpack原理：https://segmentfault.com/a/1190000015088834?utm_source=tag-newest 廖雪峰的git教程：https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000 图解Git：https://marklodato.github.io/visual-git-guide/index-zh-cn.html 前端开发者必备的Nginx知识：https://juejin.im/post/5c85a64d6fb9a04a0e2e038c 使用Jenkins进行持续集成：https://www.liaoxuefeng.com/article/001463233913442cdb2d1bd1b1b42e3b0b29eb1ba736c5e000 项目和业务 常见六大Web安全攻防解析：https://github.com/ljianshu/Blog/issues/56 深入理解前端性能监控：https://juejin.im/post/5caaacc0e51d452b45296487#heading-5 [📚]高性能网站建设指南：https://book.douban.com/subject/3132277/ 新人如何快速融入技术实力强的前端团队：https://juejin.im/post/5cb860a86fb9a06890705f14 学习提升 印记中文（各种中文开发文档）：https://www.docschina.org/ 前端学习方法：https://github.com/helloqingfeng/Awsome-Front-End-learning-resource/tree/master/01-FE-learning-master 如何在工作内外获得持续的技术成长：https://juejin.im/post/5cbd7477f265da039d32834e 优秀的前端博客汇总：https://github.com/foru17/front-end-collect 另外推荐我一直在关注的几位大佬的个人博客： 冴羽的博客：https://github.com/mqyqingfeng/Blog 张鑫旭的博客：https://www.zhangxinxu.com/wordpress/ 左耳朵耗子：https://coolshell.cn/ 技术之外 互联网术语大全：https://www.jianshu.com/p/9a7ca206c1ab 互联网沟通、问答、学习的艺术：https://zhuanlan.zhihu.com/p/41431775 经常加班至深夜，怎样才能保持身体健康：https://www.zhihu.com/question/21790919 其实在这个信息发达的时代最不缺的就是资源，如何从众多的资源中获取到真正精华的部分，是非常重要的，资源在于精不在于多，强烈建议在保证深度的情况下再保证广度。 小结希望你阅读本篇文章后可以达到以下几点： 从知识清单中找到自己的知识盲点与欠缺 具有知识体系化的思想，开始建立自己的知识体系 阅读文章时将知识归类到知识体系中，并不断完善自己的知识体系 从文章中获取到了有用的资源 文中如有错误，欢迎在评论区指正，如果这篇文章帮助到了你，欢迎点赞和关注。 如果你有什么好的知识、资源推荐，欢迎在评论区留言。","categories":[],"tags":[{"name":"学习提升","slug":"学习提升","permalink":"www.conardli.top/tags/学习提升/"}]},{"title":"【React深入】深入分析虚拟DOM的渲染原理和特性","slug":"【React深入】深入分析虚拟DOM的渲染原理和特性","date":"2019-04-17T03:15:27.000Z","updated":"2019-04-17T03:17:23.518Z","comments":true,"path":"2019/04/17/【React深入】深入分析虚拟DOM的渲染原理和特性/","link":"","permalink":"www.conardli.top/2019/04/17/【React深入】深入分析虚拟DOM的渲染原理和特性/","excerpt":"","text":"导读React的虚拟DOM和Diff算法是React的非常重要的核心特性，这部分源码也非常复杂，理解这部分知识的原理对更深入的掌握React是非常必要的。 本来想将虚拟DOM和Diff算法放到一篇文章，写完虚拟DOM发现文章已经很长了，所以本篇只分析虚拟DOM。 本篇文章从源码出发，分析虚拟DOM的核心渲染原理（首次渲染），以及React对它做的性能优化点。 说实话React源码真的很难读😅，如果本篇文章帮助到了你，那么请给个赞👍支持一下吧。 开发中的常见问题 为何必须引用React 自定义的React组件为何必须大写 React如何防止XSS React的Diff算法和其他的Diff算法有何区别 key在React中的作用 如何写出高性能的React组件 如果你对上面几个问题还存在疑问，说明你对React的虚拟DOM以及Diff算法实现原理还有所欠缺，那么请好好阅读本篇文章吧。 首先我们来看看到底什么是虚拟DOM: 虚拟DOM 在原生的JavaScript程序中，我们直接对DOM进行创建和更改，而DOM元素通过我们监听的事件和我们的应用程序进行通讯。 而React会先将你的代码转换成一个JavaScript对象，然后这个JavaScript对象再转换成真实DOM。这个JavaScript对象就是所谓的虚拟DOM。 比如下面一段html代码： &lt;div class=\"title\"&gt; &lt;span&gt;Hello ConardLi&lt;/span&gt; &lt;ul&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;橘子&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 在React可能存储为这样的JS代码： const VitrualDom = &#123; type: 'div', props: &#123; class: 'title' &#125;, children: [ &#123; type: 'span', children: 'Hello ConardLi' &#125;, &#123; type: 'ul', children: [ &#123; type: 'ul', children: '苹果' &#125;, &#123; type: 'ul', children: '橘子' &#125; ] &#125; ]&#125; 当我们需要创建或更新元素时，React首先会让这个VitrualDom对象进行创建和更改，然后再将VitrualDom对象渲染成真实DOM； 当我们需要对DOM进行事件监听时，首先对VitrualDom进行事件监听，VitrualDom会代理原生的DOM事件从而做出响应。 为何使用虚拟DOMReact为何采用VitrualDom这种方案呢？ 提高开发效率使用JavaScript，我们在编写应用程序时的关注点在于如何更新DOM。 使用React，你只需要告诉React你想让视图处于什么状态，React则通过VitrualDom确保DOM与该状态相匹配。你不必自己去完成属性操作、事件处理、DOM更新，React会替你完成这一切。 这让我们更关注我们的业务逻辑而非DOM操作，这一点即可大大提升我们的开发效率。 关于提升性能很多文章说VitrualDom可以提升性能，这一说法实际上是很片面的。 直接操作DOM是非常耗费性能的，这一点毋庸置疑。但是React使用VitrualDom也是无法避免操作DOM的。 如果是首次渲染，VitrualDom不具有任何优势，甚至它要进行更多的计算，消耗更多的内存。 VitrualDom的优势在于React的Diff算法和批处理策略，React在页面更新之前，提前计算好了如何进行更新和渲染DOM。实际上，这个计算过程我们在直接操作DOM时，也是可以自己判断和实现的，但是一定会耗费非常多的精力和时间，而且往往我们自己做的是不如React好的。所以，在这个过程中React帮助我们”提升了性能”。 所以，我更倾向于说，VitrualDom帮助我们提高了开发效率，在重复渲染时它帮助我们计算如何更高效的更新，而不是它比DOM操作更快。 如果您对本部分的分析有什么不同见解，欢迎在评论区拍砖。 跨浏览器兼容 React基于VitrualDom自己实现了一套自己的事件机制，自己模拟了事件冒泡和捕获的过程，采用了事件代理，批量更新等方法，抹平了各个浏览器的事件兼容性问题。 跨平台兼容 VitrualDom为React带来了跨平台渲染的能力。以React Native为例子。React根据VitrualDom画出相应平台的ui层，只不过不同平台画的姿势不同而已。 虚拟DOM实现原理如果你不想看繁杂的源码，或者现在没有足够时间，可以跳过这一章，直接👇虚拟DOM原理总结 在上面的图上我们继续进行扩展，按照图中的流程，我们依次来分析虚拟DOM的实现原理。 JSX和createElement我们在实现一个React组件时可以选择两种编码方式，第一种是使用JSX编写： class Hello extends Component &#123; render() &#123; return &lt;div&gt;Hello ConardLi&lt;/div&gt;; &#125;&#125; 第二种是直接使用React.createElement编写： class Hello extends Component &#123; render() &#123; return React.createElement('div', null, `Hello ConardLi`); &#125;&#125; 实际上，上面两种写法是等价的，JSX只是为 React.createElement(component, props, ...children)方法提供的语法糖。也就是说所有的JSX代码最后都会转换成React.createElement(...)，Babel帮助我们完成了这个转换的过程。 如下面的JSX &lt;div&gt; &lt;img src=\"avatar.png\" className=\"profile\" /&gt; &lt;Hello /&gt;&lt;/div&gt;; 将会被Babel转换为React.createElement(\"div\", null, React.createElement(\"img\", &#123; src: \"avatar.png\", className: \"profile\"&#125;), React.createElement(Hello, null)); 注意，babel在编译时会判断JSX中组件的首字母，当首字母为小写时，其被认定为原生DOM标签，createElement的第一个变量被编译为字符串；当首字母为大写时，其被认定为自定义组件，createElement的第一个变量被编译为对象； 另外，由于JSX提前要被Babel编译，所以JSX是不能在运行时动态选择类型的，比如下面的代码： function Story(props) &#123; // Wrong! JSX type can't be an expression. return &lt;components[props.storyType] story=&#123;props.story&#125; /&gt;;&#125; 需要变成下面的写法： function Story(props) &#123; // Correct! JSX type can be a capitalized variable. const SpecificStory = components[props.storyType]; return &lt;SpecificStory story=&#123;props.story&#125; /&gt;;&#125; 所以，使用JSX你需要安装Babel插件babel-plugin-transform-react-jsx &#123; \"plugins\": [ [\"transform-react-jsx\", &#123; \"pragma\": \"React.createElement\" &#125;] ]&#125; 创建虚拟DOM下面我们来看看虚拟DOM的真实模样，将下面的JSX代码在控制台打印出来： &lt;div className=\"title\"&gt; &lt;span&gt;Hello ConardLi&lt;/span&gt; &lt;ul&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;橘子&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 这个结构和我们上面自己描绘的结构很像，那么React是如何将我们的代码转换成这个结构的呢，下面我们来看看createElement函数的具体实现（文中的源码经过精简）。 createElement函数内部做的操作很简单，将props和子元素进行处理后返回一个ReactElement对象，下面我们来逐一分析： (1).处理props： 1.将特殊属性ref、key从config中取出并赋值 2.将特殊属性self、source从config中取出并赋值 3.将除特殊属性的其他属性取出并赋值给props 后面的文章会详细介绍这些特殊属性的作用。 (2).获取子元素 1.获取子元素的个数 —— 第二个参数后面的所有参数 2.若只有一个子元素，赋值给props.children 3.若有多个子元素，将子元素填充为一个数组赋值给props.children (3).处理默认props 将组件的静态属性defaultProps定义的默认props进行赋值 ReactElement ReactElement将传入的几个属性进行组合，并返回。 type：元素的类型，可以是原生html类型（字符串），或者自定义组件（函数或class） key：组件的唯一标识，用于Diff算法，下面会详细介绍 ref：用于访问原生dom节点 props：传入组件的props owner：当前正在构建的Component所属的Component $$typeof：一个我们不常见到的属性，它被赋值为REACT_ELEMENT_TYPE： var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &amp;&amp; Symbol.for &amp;&amp; Symbol.for('react.element')) || 0xeac7; 可见，$$typeof是一个Symbol类型的变量，这个变量可以防止XSS。 如果你的服务器有一个漏洞，允许用户存储任意JSON对象， 而客户端代码需要一个字符串，这可能会成为一个问题：// JSONlet expectedTextButGotJSON = &#123; type: 'div', props: &#123; dangerouslySetInnerHTML: &#123; __html: '/* put your exploit here */' &#125;, &#125;,&#125;;let message = &#123; text: expectedTextButGotJSON &#125;;&lt;p&gt; &#123;message.text&#125;&lt;/p&gt; JSON中不能存储Symbol类型的变量。 ReactElement.isValidElement函数用来判断一个React组件是否是有效的，下面是它的具体实现。 ReactElement.isValidElement = function (object) &#123; return typeof object === 'object' &amp;&amp; object !== null &amp;&amp; object.$$typeof === REACT_ELEMENT_TYPE;&#125;; 可见React渲染时会把没有$$typeof标识，以及规则校验不通过的组件过滤掉。 当你的环境不支持Symbol时，$$typeof被赋值为0xeac7，至于为什么，React开发者给出了答案： 0xeac7看起来有点像React。 self、source只有在非生产环境才会被加入对象中。 self指定当前位于哪个组件实例。 _source指定调试代码来自的文件(fileName)和代码行数(lineNumber)。 虚拟DOM转换为真实DOM上面我们分析了代码转换成了虚拟DOM的过程，下面来看一下React如何将虚拟DOM转换成真实DOM。 本部分逻辑较复杂，我们先用流程图梳理一下整个过程，整个过程大概可分为四步： 过程1：初始参数处理 在编写好我们的React组件后，我们需要调用ReactDOM.render(element, container[, callback])将组件进行渲染。 render函数内部实际调用了_renderSubtreeIntoContainer，我们来看看它的具体实现： render: function (nextElement, container, callback) &#123; return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);&#125;, 1.将当前组件使用TopLevelWrapper进行包裹 TopLevelWrapper只一个空壳，它为你需要挂载的组件提供了一个rootID属性，并在render函数中返回该组件。 TopLevelWrapper.prototype.render = function () &#123; return this.props.child;&#125;; ReactDOM.render函数的第一个参数可以是原生DOM也可以是React组件，包裹一层TopLevelWrapper可以在后面的渲染中将它们进行统一处理，而不用关心是否原生。 2.判断根结点下是否已经渲染过元素，如果已经渲染过，判断执行更新或者卸载操作 3.处理shouldReuseMarkup变量，该变量表示是否需要重新标记元素 4.调用将上面处理好的参数传入_renderNewRootComponent，渲染完成后调用callback。 在_renderNewRootComponent中调用instantiateReactComponent对我们传入的组件进行分类包装： 根据组件的类型，React根据原组件创建了下面四大类组件，对组件进行分类渲染： ReactDOMEmptyComponent:空组件 ReactDOMTextComponent:文本 ReactDOMComponent:原生DOM ReactCompositeComponent:自定义React组件 他们都具备以下三个方法： construct:用来接收ReactElement进行初始化。 mountComponent:用来生成ReactElement对应的真实DOM或DOMLazyTree。 unmountComponent:卸载DOM节点，解绑事件。 具体是如何渲染我们在过程3中进行分析。 过程2：批处理、事务调用 在_renderNewRootComponent中使用ReactUpdates.batchedUpdates调用batchedMountComponentIntoNode进行批处理。 ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context); 在batchedMountComponentIntoNode中，使用transaction.perform调用mountComponentIntoNode让其基于事务机制进行调用。 transaction.perform(mountComponentIntoNode, null, componentInstance, container, transaction, shouldReuseMarkup, context); 关于批处理事务，在我前面的分析setState执行机制中有更多介绍。 过程3：生成html 在mountComponentIntoNode函数中调用ReactReconciler.mountComponent生成原生DOM节点。 mountComponent内部实际上是调用了过程1生成的四种对象的mountComponent方法。首先来看一下ReactDOMComponent： 1.对特殊DOM标签、props进行处理。 2.根据标签类型创建DOM节点。 3.调用_updateDOMProperties将props插入到DOM节点，_updateDOMProperties也可用于props Diff，第一个参数为上次渲染的props，第二个参数为当前props，若第一个参数为空，则为首次创建。 4.生成一个DOMLazyTree对象并调用_createInitialChildren将孩子节点渲染到上面。 那么为什么不直接生成一个DOM节点而是要创建一个DOMLazyTree呢？我们先来看看_createInitialChildren做了什么： 判断当前节点的dangerouslySetInnerHTML属性、孩子节点是否为文本和其他节点分别调用DOMLazyTree的queueHTML、queueText、queueChild。 可以发现：DOMLazyTree实际上是一个包裹对象，node属性中存储了真实的DOM节点，children、html、text分别存储孩子、html节点和文本节点。 它提供了几个方法用于插入孩子、html以及文本节点，这些插入都是有条件限制的，当enableLazy属性为true时，这些孩子、html以及文本节点会被插入到DOMLazyTree对象中，当其为false时会插入到真实DOM节点中。 var enableLazy = typeof document !== 'undefined' &amp;&amp; typeof document.documentMode === 'number' || typeof navigator !== 'undefined' &amp;&amp; typeof navigator.userAgent === 'string' &amp;&amp; /\\bEdge\\/\\d/.test(navigator.userAgent); 可见：enableLazy是一个变量，当前浏览器是IE或Edge时为true。 在IE（8-11）和Edge浏览器中，一个一个插入无子孙的节点，效率要远高于插入一整个序列化完整的节点树。 所以lazyTree主要解决的是在IE（8-11）和Edge浏览器中插入节点的效率问题，在后面的过程4我们会分析到：若当前是IE或Edge，则需要递归插入DOMLazyTree中缓存的子节点，其他浏览器只需要插入一次当前节点，因为他们的孩子已经被渲染好了，而不用担心效率问题。 下面来看一下ReactCompositeComponent，由于代码非常多这里就不再贴这个模块的代码，其内部主要做了以下几步： 处理props、contex等变量，调用构造函数创建组件实例 判断是否为无状态组件，处理state 调用performInitialMount生命周期，处理子节点，获取markup。 调用componentDidMount生命周期 在performInitialMount函数中，首先调用了componentWillMount生命周期，由于自定义的React组件并不是一个真实的DOM，所以在函数中又调用了孩子节点的mountComponent。这也是一个递归的过程，当所有孩子节点渲染完成后，返回markup并调用componentDidMount。 过程4：渲染html 在mountComponentIntoNode函数中调用将上一步生成的markup插入container容器。 在首次渲染时，_mountImageIntoNode会清空container的子节点后调用DOMLazyTree.insertTreeBefore： 判断是否为fragment节点或者&lt;object&gt;插件： 如果是以上两种，首先调用insertTreeChildren将此节点的孩子节点渲染到当前节点上，再将渲染完的节点插入到html 如果是其他节点，先将节点插入到插入到html，再调用insertTreeChildren将孩子节点插入到html。 若当前不是IE或Edge，则不需要再递归插入子节点，只需要插入一次当前节点。 判断不是IE或bEdge时return 若children不为空，递归insertTreeBefore进行插入 渲染html节点 渲染文本节点 原生DOM事件代理有关虚拟DOM的事件机制，我曾专门写过一篇文章，有兴趣可以👇【React深入】React事件机制 虚拟DOM原理、特性总结React组件的渲染流程 使用React.createElement或JSX编写React组件，实际上所有的JSX代码最后都会转换成React.createElement(...)，Babel帮助我们完成了这个转换的过程。 createElement函数对key和ref等特殊的props进行处理，并获取defaultProps对默认props进行赋值，并且对传入的孩子节点进行处理，最终构造成一个ReactElement对象（所谓的虚拟DOM）。 ReactDOM.render将生成好的虚拟DOM渲染到指定容器上，其中采用了批处理、事务等机制并且对特定浏览器进行了性能优化，最终转换为真实DOM。 虚拟DOM的组成即ReactElementelement对象，我们的组件最终会被渲染成下面的结构： type：元素的类型，可以是原生html类型（字符串），或者自定义组件（函数或class） key：组件的唯一标识，用于Diff算法，下面会详细介绍 ref：用于访问原生dom节点 props：传入组件的props，chidren是props中的一个属性，它存储了当前组件的孩子节点，可以是数组（多个孩子节点）或对象（只有一个孩子节点） owner：当前正在构建的Component所属的Component self：（非生产环境）指定当前位于哪个组件实例 _source：（非生产环境）指定调试代码来自的文件(fileName)和代码行数(lineNumber) 防止XSSReactElement对象还有一个$$typeof属性，它是一个Symbol类型的变量Symbol.for(&#39;react.element&#39;)，当环境不支持Symbol时，$$typeof被赋值为0xeac7。 这个变量可以防止XSS。如果你的服务器有一个漏洞，允许用户存储任意JSON对象， 而客户端代码需要一个字符串，这可能为你的应用程序带来风险。JSON中不能存储Symbol类型的变量，而React渲染时会把没有$$typeof标识的组件过滤掉。 批处理和事务React在渲染虚拟DOM时应用了批处理以及事务机制，以提高渲染性能。 关于批处理以及事务机制，在我之前的文章【React深入】setState的执行机制中有详细介绍。 针对性的性能优化在IE（8-11）和Edge浏览器中，一个一个插入无子孙的节点，效率要远高于插入一整个序列化完整的节点树。 React通过lazyTree，在IE（8-11）和Edge中进行单个节点依次渲染节点，而在其他浏览器中则首先将整个大的DOM结构构建好，然后再整体插入容器。 并且，在单独渲染节点时，React还考虑了fragment等特殊节点，这些节点则不会一个一个插入渲染。 虚拟DOM事件机制React自己实现了一套事件机制，其将所有绑定在虚拟DOM上的事件映射到真正的DOM事件，并将所有的事件都代理到document上，自己模拟了事件冒泡和捕获的过程，并且进行统一的事件分发。 React自己构造了合成事件对象SyntheticEvent，这是一个跨浏览器原生事件包装器。 它具有与浏览器原生事件相同的接口，包括stopPropagation()和preventDefault()等等，在所有浏览器中他们工作方式都相同。这抹平了各个浏览器的事件兼容性问题。 上面只分析虚拟DOM首次渲染的原理和过程，当然这并不包括虚拟 DOM进行 Diff的过程，下一篇文章我们再来详细探讨。 关于开篇提的几个问题，我们在下篇文章中进行统一回答。 末尾文中如有错误，欢迎在评论区指正，或者您对文章的排版，阅读体验有什么好的建议，欢迎在评论区指出，谢谢阅读。 想阅读更多优质文章、下载文章中思维导图源文件、阅读文中demo源码、可关注我的github博客，你的star✨、点赞和关注是我持续创作的动力！","categories":[],"tags":[{"name":"React","slug":"React","permalink":"www.conardli.top/tags/React/"}]},{"title":"【React深入】从Mixin到HOC再到Hook","slug":"【React深入】从Mixin到HOC再到Hook","date":"2019-04-09T15:27:27.000Z","updated":"2019-04-09T15:28:00.607Z","comments":true,"path":"2019/04/09/【React深入】从Mixin到HOC再到Hook/","link":"","permalink":"www.conardli.top/2019/04/09/【React深入】从Mixin到HOC再到Hook/","excerpt":"","text":"导读前端发展速度非常之快，页面和组件变得越来越复杂，如何更好的实现状态逻辑复用一直都是应用程序中重要的一部分，这直接关系着应用程序的质量以及维护的难易程度。 本文介绍了React采用的三种实现状态逻辑复用的技术，并分析了他们的实现原理、使用方法、实际应用以及如何选择使用他们。 本文略长，下面是本文的思维导图，您可以从头开始阅读，也可以选择感兴趣的部分阅读： Mixin设计模式 Mixin（混入）是一种通过扩展收集功能的方式，它本质上是将一个对象的属性拷贝到另一个对象上面去，不过你可以拷贝任意多个对象的任意个方法到一个新对象上去，这是继承所不能实现的。它的出现主要就是为了解决代码复用问题。 很多开源库提供了Mixin的实现，如Underscore的_.extend方法、JQuery的extend方法。 使用_.extend方法实现代码复用： var LogMixin = &#123; actionLog: function() &#123; console.log('action...'); &#125;, requestLog: function() &#123; console.log('request...'); &#125;,&#125;;function User() &#123; /*..*/ &#125;function Goods() &#123; /*..*/ &#125;_.extend(User.prototype, LogMixin);_.extend(Goods.prototype, LogMixin);var user = new User();var good = new Goods();user.actionLog();good.requestLog(); 我们可以尝试手动写一个简单的Mixin方法： function setMixin(target, mixin) &#123; if (arguments[2]) &#123; for (var i = 2, len = arguments.length; i &lt; len; i++) &#123; target.prototype[arguments[i]] = mixin.prototype[arguments[i]]; &#125; &#125; else &#123; for (var methodName in mixin.prototype) &#123; if (!Object.hasOwnProperty(target.prototype, methodName)) &#123; target.prototype[methodName] = mixin.prototype[methodName]; &#125; &#125; &#125;&#125;setMixin(User,LogMixin,'actionLog');setMixin(Goods,LogMixin,'requestLog'); 您可以使用setMixin\b方法将任意对象的任意方法扩展到目标对象上。 React中应用MixinReact也提供了Mixin的实现，如果完全不同的组件有相似的功能，我们可以引入来实现代码复用，当然只有在使用createClass来创建React组件时才可以使用，因为在React组件的es6写法中它已经被废弃掉了。 例如下面的例子，很多组件或页面都需要记录用户行为，性能指标等。如果我们在每个组件都引入写日志的逻辑，会产生大量重复代码，通过Mixin我们可以解决这一问题： var LogMixin = &#123; log: function() &#123; console.log('log'); &#125;, componentDidMount: function() &#123; console.log('in'); &#125;, componentWillUnmount: function() &#123; console.log('out'); &#125;&#125;;var User = React.createClass(&#123; mixins: [LogMixin], render: function() &#123; return (&lt;div&gt;...&lt;/div&gt;) &#125;&#125;);var Goods = React.createClass(&#123; mixins: [LogMixin], render: function() &#123; return (&lt;div&gt;...&lt;/div&gt;) &#125;&#125;); Mixin带来的危害React官方文档在Mixins Considered Harmful一文中提到了Mixin带来了危害： Mixin 可能会相互依赖，相互耦合，不利于代码维护 不同的Mixin中的方法可能会相互冲突 Mixin非常多时，组件是可以感知到的，甚至还要为其做相关处理，这样会给代码造成滚雪球式的复杂性 React现在已经不再推荐使用Mixin来解决代码复用问题，因为Mixin带来的危害比他产生的价值还要巨大，并且React全面推荐使用高阶组件来替代它。另外，高阶组件还能实现更多其他更强大的功能，在学习高阶组件之前，我们先来看一个设计模式。 装饰模式 装饰者(decorator)模式能够在不改变对象自身的基础上，在程序运行期间给对像动态的添加职责。与继承相比，装饰者是一种更轻便灵活的做法。 高阶组件（HOC） 高阶组件可以看作React对装饰模式的一种实现，高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。 高阶组件（HOC）是React中的高级技术，用来重用组件逻辑。但高阶组件本身并不是React API。它只是一种模式，这种模式是由React自身的组合性质必然产生的。 function visible(WrappedComponent) &#123; return class extends Component &#123; render() &#123; const &#123; visible, ...props &#125; = this.props; if (visible === false) return null; return &lt;WrappedComponent &#123;...props&#125; /&gt;; &#125; &#125;&#125; 上面的代码就是一个HOC的简单应用，函数接收一个组件作为参数，并返回一个新组件，新组建可以接收一个visible props，根据visible的值来判断是否渲染Visible。 下面我们从以下几方面来具体探索HOC。 HOC的实现方式属性代理函数返回一个我们自己定义的组件，然后在render中返回要包裹的组件，这样我们就可以代理所有传入的props，并且决定如何渲染，实际上 ，这种方式生成的高阶组件就是原组件的父组件，上面的函数visible就是一个HOC属性代理的实现方式。 function proxyHOC(WrappedComponent) &#123; return class extends Component &#123; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; /&gt;; &#125; &#125;&#125; 对比原生组件增强的项： 可操作所有传入的props 可操作组件的生命周期 可操作组件的static方法 获取refs 反向继承返回一个组件，继承原组件，在render中调用原组件的render。由于继承了原组件，能通过this访问到原组件的生命周期、props、state、render等，相比属性代理它能操作更多的属性。 function inheritHOC(WrappedComponent) &#123; return class extends WrappedComponent &#123; render() &#123; return super.render(); &#125; &#125;&#125; 对比原生组件增强的项： 可操作所有传入的props 可操作组件的生命周期 可操作组件的static方法 获取refs 可操作state 可以渲染劫持 HOC可以实现什么功能组合渲染可使用任何其他组件和原组件进行组合渲染，达到样式、布局复用等效果。 通过属性代理实现 function stylHOC(WrappedComponent) &#123; return class extends Component &#123; render() &#123; return (&lt;div&gt; &lt;div className=\"title\"&gt;&#123;this.props.title&#125;&lt;/div&gt; &lt;WrappedComponent &#123;...this.props&#125; /&gt; &lt;/div&gt;); &#125; &#125;&#125; 通过反向继承实现 function styleHOC(WrappedComponent) &#123; return class extends WrappedComponent &#123; render() &#123; return &lt;div&gt; &lt;div className=\"title\"&gt;&#123;this.props.title&#125;&lt;/div&gt; &#123;super.render()&#125; &lt;/div&gt; &#125; &#125;&#125; 条件渲染根据特定的属性决定原组件是否渲染 通过属性代理实现 function visibleHOC(WrappedComponent) &#123; return class extends Component &#123; render() &#123; if (this.props.visible === false) return null; return &lt;WrappedComponent &#123;...props&#125; /&gt;; &#125; &#125;&#125; 通过反向继承实现 function visibleHOC(WrappedComponent) &#123; return class extends WrappedComponent &#123; render() &#123; if (this.props.visible === false) &#123; return null &#125; else &#123; return super.render() &#125; &#125; &#125;&#125; 操作props可以对传入组件的props进行增加、修改、删除或者根据特定的props进行特殊的操作。 通过属性代理实现 function proxyHOC(WrappedComponent) &#123; return class extends Component &#123; render() &#123; const newProps = &#123; ...this.props, user: 'ConardLi' &#125; return &lt;WrappedComponent &#123;...newProps&#125; /&gt;; &#125; &#125;&#125; 获取refs高阶组件中可获取原组件的ref，通过ref获取组件实力，如下面的代码，当程序初始化完成后调用原组件的log方法。(不知道refs怎么用，请👇Refs &amp; DOM) 通过属性代理实现 function refHOC(WrappedComponent) &#123; return class extends Component &#123; componentDidMount() &#123; this.wapperRef.log() &#125; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; ref=&#123;ref =&gt; &#123; this.wapperRef = ref &#125;&#125; /&gt;; &#125; &#125;&#125; 这里注意：调用高阶组件的时候并不能获取到原组件的真实ref，需要手动进行传递，具体请看传递refs 状态管理将原组件的状态提取到HOC中进行管理，如下面的代码，我们将Input的value提取到HOC中进行管理，使它变成受控组件，同时不影响它使用onChange方法进行一些其他操作。基于这种方式，我们可以实现一个简单的双向绑定，具体请看双向绑定。 通过属性代理实现 function proxyHoc(WrappedComponent) &#123; return class extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: '' &#125;; &#125; onChange = (event) =&gt; &#123; const &#123; onChange &#125; = this.props; this.setState(&#123; value: event.target.value, &#125;, () =&gt; &#123; if(typeof onChange ==='function')&#123; onChange(event); &#125; &#125;) &#125; render() &#123; const newProps = &#123; value: this.state.value, onChange: this.onChange, &#125; return &lt;WrappedComponent &#123;...this.props&#125; &#123;...newProps&#125; /&gt;; &#125; &#125;&#125;class HOC extends Component &#123; render() &#123; return &lt;input &#123;...this.props&#125;&gt;&lt;/input&gt; &#125;&#125;export default proxyHoc(HOC); 操作state上面的例子通过属性代理利用HOC的state对原组件进行了一定的增强，但并不能直接控制原组件的state，而通过反向继承，我们可以直接操作原组件的state。但是并不推荐直接修改或添加原组件的state，因为这样有可能和组件内部的操作构成冲突。 通过反向继承实现 function debugHOC(WrappedComponent) &#123; return class extends WrappedComponent &#123; render() &#123; console.log('props', this.props); console.log('state', this.state); return ( &lt;div className=\"debuging\"&gt; &#123;super.render()&#125; &lt;/div&gt; ) &#125; &#125;&#125; 上面的HOC在render中将props和state打印出来，可以用作调试阶段，当然你可以在里面写更多的调试代码。想象一下，只需要在我们想要调试的组件上加上@debug就可以对该组件进行调试，而不需要在每次调试的时候写很多冗余代码。(如果你还不知道怎么使用HOC，请👇如何使用HOC) 渲染劫持高阶组件可以在render函数中做非常多的操作，从而控制原组件的渲染输出。只要改变了原组件的渲染，我们都将它称之为一种渲染劫持。 实际上，上面的组合渲染和条件渲染都是渲染劫持的一种，通过反向继承，不仅可以实现以上两点，还可直接增强由原组件render函数产生的React元素。 通过反向继承实现 function hijackHOC(WrappedComponent) &#123; return class extends WrappedComponent &#123; render() &#123; const tree = super.render(); let newProps = &#123;&#125;; if (tree &amp;&amp; tree.type === 'input') &#123; newProps = &#123; value: '渲染被劫持了' &#125;; &#125; const props = Object.assign(&#123;&#125;, tree.props, newProps); const newTree = React.cloneElement(tree, props, tree.props.children); return newTree; &#125; &#125;&#125; 注意上面的说明我用的是增强而不是更改。render函数内实际上是调用React.creatElement产生的React元素： 虽然我们能拿到它，但是我们不能直接修改它里面的属性，我们通过getOwnPropertyDescriptors函数来打印下它的配置项： 可以发现，所有的writable属性均被配置为了false，即所有属性是不可变的。（对这些配置项有疑问，请👇defineProperty） 不能直接修改，我们可以借助cloneElement方法来在原组件的基础上增强一个新组件： React.cloneElement()克隆并返回一个新的React元素，使用element作为起点。生成的元素将会拥有原始元素props与新props的浅合并。新的子级会替换现有的子级。来自原始元素的 key 和 ref 将会保留。 React.cloneElement()几乎相当于： &lt;element.type &#123;...element.props&#125; &#123;...props&#125;&gt;&#123;children&#125;&lt;/element.type&gt; 如何使用HOC上面的示例代码都写的是如何声明一个HOC，HOC实际上是一个函数，所以我们将要增强的组件作为参数调用HOC函数，得到增强后的组件。 class myComponent extends Component &#123; render() &#123; return (&lt;span&gt;原组件&lt;/span&gt;) &#125;&#125;export default inheritHOC(myComponent); compose在实际应用中，一个组件可能被多个HOC增强，我们使用的是被所有的HOC增强后的组件，借用一张装饰模式的图来说明，可能更容易理解： 假设现在我们有logger，visible，style等多个HOC，现在要同时增强一个Input组件： logger(visible(style(Input))) 这种代码非常的难以阅读，我们可以手动封装一个简单的函数组合工具，将写法改写如下： const compose = (...fns) =&gt; fns.reduce((f, g) =&gt; (...args) =&gt; g(f(...args)));compose(logger,visible,style)(Input); compose函数返回一个所有函数组合后的函数，compose(f, g, h) 和 (...args) =&gt; f(g(h(...args)))是一样的。 很多第三方库都提供了类似compose的函数，例如lodash.flowRight，Redux提供的combineReducers函数等。 Decorators我们还可以借助ES7为我们提供的Decorators来让我们的写法变的更加优雅： @logger@visible@styleclass Input extends Component &#123; // ...&#125; Decorators是ES7的一个提案，还没有被标准化，但目前Babel转码器已经支持，我们需要提前配置babel-plugin-transform-decorators-legacy： \"plugins\": [\"transform-decorators-legacy\"] 还可以结合上面的compose函数使用： const hoc = compose(logger, visible, style);@hocclass Input extends Component &#123; // ...&#125; HOC的实际应用下面是一些我在公司项目中实际对HOC的实际应用场景，由于文章篇幅原因，代码经过很多简化，如有问题欢迎在评论区指出： 日志打点实际上这属于一类最常见的应用，多个组件拥有类似的逻辑，我们要对重复的逻辑进行复用，官方文档中CommentList的示例也是解决了代码复用问题，写的很详细，有兴趣可以👇使用高阶组件（HOC）解决横切关注点。 某些页面需要记录用户行为，性能指标等等，通过高阶组件做这些事情可以省去很多重复代码。 function logHoc(WrappedComponent) &#123; return class extends Component &#123; componentWillMount() &#123; this.start = Date.now(); &#125; componentDidMount() &#123; this.end = Date.now(); console.log(`$&#123;WrappedComponent.dispalyName&#125; 渲染时间：$&#123;this.end - this.start&#125; ms`); console.log(`$&#123;user&#125;进入$&#123;WrappedComponent.dispalyName&#125;`); &#125; componentWillUnmount() &#123; console.log(`$&#123;user&#125;退出$&#123;WrappedComponent.dispalyName&#125;`); &#125; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; /&gt; &#125; &#125;&#125; 可用、权限控制function auth(WrappedComponent) &#123; return class extends Component &#123; render() &#123; const &#123; visible, auth, display = null, ...props &#125; = this.props; if (visible === false || (auth &amp;&amp; authList.indexOf(auth) === -1)) &#123; return display &#125; return &lt;WrappedComponent &#123;...props&#125; /&gt;; &#125; &#125;&#125; authList是我们在进入程序时向后端请求的所有权限列表，当组件所需要的权限不列表中，或者设置的visible是false，我们将其显示为传入的组件样式，或者null。我们可以将任何需要进行权限校验的组件应用HOC： @authclass Input extends Component &#123; ... &#125;@authclass Button extends Component &#123; ... &#125;&lt;Button auth=\"user/addUser\"&gt;添加用户&lt;/Button&gt;&lt;Input auth=\"user/search\" visible=&#123;false&#125; &gt;添加用户&lt;/Input&gt; 双向绑定在vue中，绑定一个变量后可实现双向数据绑定，即表单中的值改变后绑定的变量也会自动改变。而React中没有做这样的处理，在默认情况下，表单元素都是非受控组件。给表单元素绑定一个状态后，往往需要手动书写onChange方法来将其改写为受控组件，在表单元素非常多的情况下这些重复操作是非常痛苦的。 我们可以借助高阶组件来实现一个简单的双向绑定，代码略长，可以结合下面的思维导图进行理解。 首先我们自定义一个Form组件，该组件用于包裹所有需要包裹的表单组件，通过contex向子组件暴露两个属性： model：当前Form管控的所有数据，由表单name和value组成，如{name:&#39;ConardLi&#39;,pwd:&#39;123&#39;}。model可由外部传入，也可自行管控。 changeModel：改变model中某个name的值。 class Form extends Component &#123; static childContextTypes = &#123; model: PropTypes.object, changeModel: PropTypes.func &#125; constructor(props, context) &#123; super(props, context); this.state = &#123; model: props.model || &#123;&#125; &#125;; &#125; componentWillReceiveProps(nextProps) &#123; if (nextProps.model) &#123; this.setState(&#123; model: nextProps.model &#125;) &#125; &#125; changeModel = (name, value) =&gt; &#123; this.setState(&#123; model: &#123; ...this.state.model, [name]: value &#125; &#125;) &#125; getChildContext() &#123; return &#123; changeModel: this.changeModel, model: this.props.model || this.state.model &#125;; &#125; onSubmit = () =&gt; &#123; console.log(this.state.model); &#125; render() &#123; return &lt;div&gt; &#123;this.props.children&#125; &lt;button onClick=&#123;this.onSubmit&#125;&gt;提交&lt;/button&gt; &lt;/div&gt; &#125;&#125; 下面定义用于双向绑定的HOC，其代理了表单的onChange属性和value属性： 发生onChange事件时调用上层Form的changeModel方法来改变context中的model。 在渲染时将value改为从context中取出的值。 function proxyHoc(WrappedComponent) &#123; return class extends Component &#123; static contextTypes = &#123; model: PropTypes.object, changeModel: PropTypes.func &#125; onChange = (event) =&gt; &#123; const &#123; changeModel &#125; = this.context; const &#123; onChange &#125; = this.props; const &#123; v_model &#125; = this.props; changeModel(v_model, event.target.value); if(typeof onChange === 'function')&#123;onChange(event);&#125; &#125; render() &#123; const &#123; model &#125; = this.context; const &#123; v_model &#125; = this.props; return &lt;WrappedComponent &#123;...this.props&#125; value=&#123;model[v_model]&#125; onChange=&#123;this.onChange&#125; /&gt;; &#125; &#125;&#125;@proxyHocclass Input extends Component &#123; render() &#123; return &lt;input &#123;...this.props&#125;&gt;&lt;/input&gt; &#125;&#125; 上面的代码只是简略的一部分，除了input，我们还可以将HOC应用在select等其他表单组件，甚至还可以将上面的HOC兼容到span、table等展示组件，这样做可以大大简化代码，让我们省去了很多状态管理的工作，使用如下： export default class extends Component &#123; render() &#123; return ( &lt;Form &gt; &lt;Input v_model=\"name\"&gt;&lt;/Input&gt; &lt;Input v_model=\"pwd\"&gt;&lt;/Input&gt; &lt;/Form&gt; ) &#125;&#125; 表单校验基于上面的双向绑定的例子，我们再来一个表单验证器，表单验证器可以包含验证函数以及提示信息，当验证不通过时，展示错误信息： function validateHoc(WrappedComponent) &#123; return class extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; error: '' &#125; &#125; onChange = (event) =&gt; &#123; const &#123; validator &#125; = this.props; if (validator &amp;&amp; typeof validator.func === 'function') &#123; if (!validator.func(event.target.value)) &#123; this.setState(&#123; error: validator.msg &#125;) &#125; else &#123; this.setState(&#123; error: '' &#125;) &#125; &#125; &#125; render() &#123; return &lt;div&gt; &lt;WrappedComponent onChange=&#123;this.onChange&#125; &#123;...this.props&#125; /&gt; &lt;div&gt;&#123;this.state.error || ''&#125;&lt;/div&gt; &lt;/div&gt; &#125; &#125;&#125; const validatorName = &#123; func: (val) =&gt; val &amp;&amp; !isNaN(val), msg: '请输入数字'&#125;const validatorPwd = &#123; func: (val) =&gt; val &amp;&amp; val.length &gt; 6, msg: '密码必须大于6位'&#125;&lt;HOCInput validator=&#123;validatorName&#125; v_model=\"name\"&gt;&lt;/HOCInput&gt;&lt;HOCInput validator=&#123;validatorPwd&#125; v_model=\"pwd\"&gt;&lt;/HOCInput&gt; 当然，还可以在Form提交的时候判断所有验证器是否通过，验证器也可以设置为数组等等，由于文章篇幅原因，代码被简化了很多，有兴趣的同学可以自己实现。 Redux的connect redux中的connect，其实就是一个HOC，下面就是一个简化版的connect实现： export const connect = (mapStateToProps, mapDispatchToProps) =&gt; (WrappedComponent) =&gt; &#123; class Connect extends Component &#123; static contextTypes = &#123; store: PropTypes.object &#125; constructor () &#123; super() this.state = &#123; allProps: &#123;&#125; &#125; &#125; componentWillMount () &#123; const &#123; store &#125; = this.context this._updateProps() store.subscribe(() =&gt; this._updateProps()) &#125; _updateProps () &#123; const &#123; store &#125; = this.context let stateProps = mapStateToProps ? mapStateToProps(store.getState(), this.props): &#123;&#125; let dispatchProps = mapDispatchToProps? mapDispatchToProps(store.dispatch, this.props) : &#123;&#125; this.setState(&#123; allProps: &#123; ...stateProps, ...dispatchProps, ...this.props &#125; &#125;) &#125; render () &#123; return &lt;WrappedComponent &#123;...this.state.allProps&#125; /&gt; &#125; &#125; return Connect&#125; 代码非常清晰，connect函数其实就做了一件事，将mapStateToProps和mapDispatchToProps分别解构后传给原组件，这样我们在原组件内就可以直接用props获取state以及dispatch函数了。 使用HOC的注意事项告诫—静态属性拷贝当我们应用HOC去增强另一个组件时，我们实际使用的组件已经不是原组件了，所以我们拿不到原组件的任何静态属性，我们可以在HOC的结尾手动拷贝他们： function proxyHOC(WrappedComponent) &#123; class HOCComponent extends Component &#123; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; /&gt;; &#125; &#125; HOCComponent.staticMethod = WrappedComponent.staticMethod; // ... return HOCComponent;&#125; 如果原组件有非常多的静态属性，这个过程是非常痛苦的，而且你需要去了解需要增强的所有组件的静态属性是什么，我们可以使用hoist-non-react-statics来帮助我们解决这个问题，它可以自动帮我们拷贝所有非React的静态方法，使用方式如下： import hoistNonReactStatic from 'hoist-non-react-statics';function proxyHOC(WrappedComponent) &#123; class HOCComponent extends Component &#123; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; /&gt;; &#125; &#125; hoistNonReactStatic(HOCComponent,WrappedComponent); return HOCComponent;&#125; 告诫—传递refs使用高阶组件后，获取到的ref实际上是最外层的容器组件，而非原组件，但是很多情况下我们需要用到原组件的ref。 高阶组件并不能像透传props那样将refs透传，我们可以用一个回调函数来完成ref的传递：function hoc(WrappedComponent) &#123; return class extends Component &#123; getWrappedRef = () =&gt; this.wrappedRef; render() &#123; return &lt;WrappedComponent ref=&#123;ref =&gt; &#123; this.wrappedRef = ref &#125;&#125; &#123;...this.props&#125; /&gt;; &#125; &#125;&#125;@hocclass Input extends Component &#123; render() &#123; return &lt;input&gt;&lt;/input&gt; &#125;&#125;class App extends Component &#123; render() &#123; return ( &lt;Input ref=&#123;ref =&gt; &#123; this.inpitRef = ref.getWrappedRef() &#125;&#125; &gt;&lt;/Input&gt; ); &#125;&#125; React 16.3版本提供了一个forwardRef API来帮助我们进行refs传递，这样我们在高阶组件上获取的ref就是原组件的ref了，而不需要再手动传递，如果你的React版本大于16.3，可以使用下面的方式: function hoc(WrappedComponent) &#123; class HOC extends Component &#123; render() &#123; const &#123; forwardedRef, ...props &#125; = this.props; return &lt;WrappedComponent ref=&#123;forwardedRef&#125; &#123;...props&#125; /&gt;; &#125; &#125; return React.forwardRef((props, ref) =&gt; &#123; return &lt;HOC forwardedRef=&#123;ref&#125; &#123;...props&#125; /&gt;; &#125;);&#125; 告诫—不要在render方法内使用高阶组件React Diff算法的原则是： 使用组件标识确定是卸载还是更新组件 如果组件的和前一次渲染时标识是相同的，递归更新子组件 如果标识不同卸载组件重新挂载新组件 每次调用高阶组件生成的都是是一个全新的组件，组件的唯一标识响应的也会改变，如果在render方法调用了高阶组件，这会导致组件每次都会被卸载后重新挂载。 约定-不要改变原始组件官方文档对高阶组件的说明： 高阶组件就是一个没有副作用的纯函数。 我们再来看看纯函数的定义： 如果函数的调用参数相同，则永远返回相同的结果。它不依赖于程序执行期间函数外部任何状态或数据的变化，必须只依赖于其输入参数。该函数不会产生任何可观察的副作用，例如网络请求，输入和输出设备或数据突变。 如果我们在高阶组件对原组件进行了修改，例如下面的代码： InputComponent.prototype.componentWillReceiveProps = function(nextProps) &#123; ... &#125; 这样就破坏了我们对高阶组件的约定，同时也改变了使用高阶组件的初衷：我们使用高阶组件是为了增强而非改变原组件。 约定-透传不相关的props使用高阶组件，我们可以代理所有的props，但往往特定的HOC只会用到其中的一个或几个props。我们需要把其他不相关的props透传给原组件，如下面的代码： function visible(WrappedComponent) &#123; return class extends Component &#123; render() &#123; const &#123; visible, ...props &#125; = this.props; if (visible === false) return null; return &lt;WrappedComponent &#123;...props&#125; /&gt;; &#125; &#125;&#125; 我们只使用visible属性来控制组件的显示可隐藏，把其他props透传下去。 约定-displayName在使用React Developer Tools进行调试时，如果我们使用了HOC，调试界面可能变得非常难以阅读，如下面的代码： @visibleclass Show extends Component &#123; render() &#123; return &lt;h1&gt;我是一个标签&lt;/h1&gt; &#125;&#125;@visibleclass Title extends Component &#123; render() &#123; return &lt;h1&gt;我是一个标题&lt;/h1&gt; &#125;&#125; 为了方便调试，我们可以手动为HOC指定一个displayName，官方推荐使用HOCName(WrappedComponentName)： static displayName = `Visible($&#123;WrappedComponent.displayName&#125;)` 这个约定帮助确保高阶组件最大程度的灵活性和可重用性。 使用HOC的动机回顾下上文提到的 Mixin 带来的风险： Mixin 可能会相互依赖，相互耦合，不利于代码维护 不同的Mixin中的方法可能会相互冲突 Mixin非常多时，组件是可以感知到的，甚至还要为其做相关处理，这样会给代码造成滚雪球式的复杂性 而HOC的出现可以解决这些问题： 高阶组件就是一个没有副作用的纯函数，各个高阶组件不会互相依赖耦合 高阶组件也有可能造成冲突，但我们可以在遵守约定的情况下避免这些行为 高阶组件并不关心数据使用的方式和原因，而被包裹的组件也不关心数据来自何处。高阶组件的增加不会为原组件增加负担 HOC的缺陷 HOC需要在原组件上进行包裹或者嵌套，如果大量使用HOC，将会产生非常多的嵌套，这让调试变得非常困难。 HOC可以劫持props，在不遵守约定的情况下也可能造成冲突。 Hooks Hooks是React v16.7.0-alpha中加入的新特性。它可以让你在class以外使用state和其他React特性。 使用Hooks，你可以在将含有state的逻辑从组件中抽象出来，这将可以让这些逻辑容易被测试。同时，Hooks可以帮助你在不重写组件结构的情况下复用这些逻辑。所以，它也可以作为一种实现状态逻辑复用的方案。 阅读下面的章节使用Hook的动机你可以发现，它可以同时解决Mixin和HOC带来的问题。 官方提供的HooksState Hook我们要使用class组件实现一个计数器功能，我们可能会这样写： export default class Count extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125; &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; &#123; this.setState(&#123; count: this.state.count + 1 &#125;) &#125;&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 通过useState，我们使用函数式组件也能实现这样的功能： export default function HookTest() &#123; const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1); setNumber(number + 1); &#125;&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; useState是一个钩子，他可以为函数式组件增加一些状态，并且提供改变这些状态的函数，同时它接收一个参数，这个参数作为状态的默认值。 Effect Hook Effect Hook 可以让你在函数组件中执行一些具有 side effect（副作用）的操作 参数 useEffect方法接收传入两个参数： 1.回调函数：在第组件一次render和之后的每次update后运行，React保证在DOM已经更新完成之后才会运行回调。 2.状态依赖(数组)：当配置了状态依赖项后，只有检测到配置的状态变化时，才会调用回调函数。 useEffect(() =&gt; &#123; // 只要组件render后就会执行&#125;);useEffect(() =&gt; &#123; // 只有count改变时才会执行&#125;,[count]); 回调返回值 useEffect的第一个参数可以返回一个函数，当页面渲染了下一次更新的结果后，执行下一次useEffect之前，会调用这个函数。这个函数常常用来对上一次调用useEffect进行清理。 export default function HookTest() &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; console.log('执行...', count); return () =&gt; &#123; console.log('清理...', count); &#125; &#125;, [count]); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1); setNumber(number + 1); &#125;&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; 执行上面的代码，并点击几次按钮，会得到下面的结果： 注意，如果加上浏览器渲染的情况，结果应该是这样的： 页面渲染...1执行... 1页面渲染...2清理... 1执行... 2页面渲染...3清理... 2执行... 3页面渲染...4清理... 3执行... 4 那么为什么在浏览器渲染完后，再执行清理的方法还能找到上次的state呢？原因很简单，我们在useEffect中返回的是一个函数，这形成了一个闭包，这能保证我们上一次执行函数存储的变量不被销毁和污染。 你可以尝试下面的代码可能更好理解 var flag = 1;var clean;function effect(flag) &#123; return function () &#123; console.log(flag); &#125;&#125;clean = effect(flag);flag = 2;clean();clean = effect(flag);flag = 3;clean();clean = effect(flag);// 执行结果effect... 1clean... 1effect... 2clean... 2effect... 3 模拟componentDidMount componentDidMount等价于useEffect的回调仅在页面初始化完成后执行一次，当useEffect的第二个参数传入一个空数组时可以实现这个效果。 function useDidMount(callback) &#123; useEffect(callback, []);&#125; 官方不推荐上面这种写法，因为这有可能导致一些错误。 模拟componentWillUnmount function useUnMount(callback) &#123; useEffect(() =&gt; callback, []);&#125; 不像 componentDidMount 或者 componentDidUpdate，useEffect 中使用的 effect 并不会阻滞浏览器渲染页面。这让你的 app 看起来更加流畅。 ref Hook使用useRef Hook，你可以轻松的获取到dom的ref。 export default function Input() &#123; const inputEl = useRef(null); const onButtonClick = () =&gt; &#123; inputEl.current.focus(); &#125;; return ( &lt;div&gt; &lt;input ref=&#123;inputEl&#125; type=\"text\" /&gt; &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;/button&gt; &lt;/div&gt; );&#125; 注意useRef()并不仅仅可以用来当作获取ref使用，使用useRef产生的ref的current属性是可变的，这意味着你可以用它来保存一个任意值。 模拟componentDidUpdate componentDidUpdate就相当于除去第一次调用的useEffect，我们可以借助useRef生成一个标识，来记录是否为第一次执行： function useDidUpdate(callback, prop) &#123; const init = useRef(true); useEffect(() =&gt; &#123; if (init.current) &#123; init.current = false; &#125; else &#123; return callback(); &#125; &#125;, prop);&#125; 使用Hook的注意事项使用范围 只能在React函数式组件或自定义Hook中使用Hook。 Hook的提出主要就是为了解决class组件的一系列问题，所以我们能在class组件中使用它。 声明约束 不要在循环，条件或嵌套函数中调用Hook。 Hook通过数组实现的，每次useState 都会改变下标，React需要利用调用顺序来正确更新相应的状态，如果useState 被包裹循环或条件语句中，那每就可能会引起调用顺序的错乱，从而造成意想不到的错误。 我们可以安装一个eslint插件来帮助我们避免这些问题。// 安装npm install eslint-plugin-react-hooks --save-dev// 配置&#123; \"plugins\": [ // ... \"react-hooks\" ], \"rules\": &#123; // ... \"react-hooks/rules-of-hooks\": \"error\" &#125;&#125; 自定义Hook像上面介绍的HOC和mixin一样，我们同样可以通过自定义的Hook将组件中类似的状态逻辑抽取出来。 自定义Hook非常简单，我们只需要定义一个函数，并且把相应需要的状态和effect封装进去，同时，Hook之间也是可以相互引用的。使用use开头命名自定义Hook，这样可以方便eslint进行检查。 下面我们看几个具体的Hook封装： 日志打点我们可以使用上面封装的生命周期Hook。 const useLogger = (componentName, ...params) =&gt; &#123; useDidMount(() =&gt; &#123; console.log(`$&#123;componentName&#125;初始化`, ...params); &#125;); useUnMount(() =&gt; &#123; console.log(`$&#123;componentName&#125;卸载`, ...params); &#125;) useDidUpdate(() =&gt; &#123; console.log(`$&#123;componentName&#125;更新`, ...params); &#125;);&#125;;function Page1(props)&#123; useLogger('Page1',props); return (&lt;div&gt;...&lt;/div&gt;)&#125; 修改title根据不同的页面名称修改页面title: function useTitle(title) &#123; useEffect( () =&gt; &#123; document.title = title; return () =&gt; (document.title = \"主页\"); &#125;, [title] );&#125;function Page1(props)&#123; useTitle('Page1'); return (&lt;div&gt;...&lt;/div&gt;)&#125; 双向绑定我们将表单onChange的逻辑抽取出来封装成一个Hook，这样所有需要进行双向绑定的表单组件都可以进行复用：function useBind(init) &#123; let [value, setValue] = useState(init); let onChange = useCallback(function(event) &#123; setValue(event.currentTarget.value); &#125;, []); return &#123; value, onChange &#125;;&#125;function Page1(props)&#123; let value = useBind(''); return &lt;input &#123;...value&#125; /&gt;;&#125; 当然，你可以向上面的HOC那样，结合context和form来封装一个更通用的双向绑定，有兴趣可以手动实现一下。 使用Hook的动机减少状态逻辑复用的风险Hook和Mixin在用法上有一定的相似之处，但是Mixin引入的逻辑和状态是可以相互覆盖的，而多个Hook之间互不影响，这让我们不需要在把一部分精力放在防止避免逻辑复用的冲突上。 在不遵守约定的情况下使用HOC也有可能带来一定冲突，比如props覆盖等等，使用Hook则可以避免这些问题。 避免地狱式嵌套大量使用HOC的情况下让我们的代码变得嵌套层级非常深，使用HOC，我们可以实现扁平式的状态逻辑复用，而避免了大量的组件嵌套。 让组件更容易理解在使用class组件构建我们的程序时，他们各自拥有自己的状态，业务逻辑的复杂使这些组件变得越来越庞大，各个生命周期中会调用越来越多的逻辑，越来越难以维护。使用Hook，可以让你更大限度的将公用逻辑抽离，将一个组件分割成更小的函数，而不是强制基于生命周期方法进行分割。 使用函数代替class相比函数，编写一个class可能需要掌握更多的知识，需要注意的点也越多，比如this指向、绑定事件等等。另外，计算机理解一个class比理解一个函数更快。Hooks让你可以在classes之外使用更多React的新特性。 理性的选择实际上，Hook在react 16.8.0才正式发布Hook稳定版本，笔者也还未在生产环境下使用，目前笔者在生产环境下使用的最多的是HOC。 React官方完全没有把classes从React中移除的打算，class组件和Hook完全可以同时存在，官方也建议避免任何“大范围重构”，毕竟这是一个非常新的版本，如果你喜欢它，可以在新的非关键性的代码中使用Hook。 小结mixin已被抛弃，HOC正当壮年，Hook初露锋芒，前端圈就是这样，技术迭代速度非常之快，但我们在学习这些知识之时一定要明白为什么要学，学了有没有用，要不要用。不忘初心，方得始终。 文中如有错误，欢迎在评论区指正，谢谢阅读。","categories":[],"tags":[{"name":"React","slug":"React","permalink":"www.conardli.top/tags/React/"}]},{"title":"全面分析前端的网络请求方式","slug":"【浏览器和网络】全面分析前端的网络请求方式","date":"2019-03-28T12:38:59.000Z","updated":"2019-06-01T10:32:37.982Z","comments":true,"path":"2019/03/28/【浏览器和网络】全面分析前端的网络请求方式/","link":"","permalink":"www.conardli.top/2019/03/28/【浏览器和网络】全面分析前端的网络请求方式/","excerpt":"","text":"一、前端进行网络请求的关注点大多数情况下，在前端发起一个网络请求我们只需关注下面几点： 传入基本参数（url，请求方式） 请求参数、请求参数类型 设置请求头 获取响应的方式 获取响应头、响应状态、响应结果 异常处理 携带cookie设置 跨域请求 二、前端进行网络请求的方式 form表单、ifream、刷新页面 Ajax - 异步网络请求的开山鼻祖 jQuery - 一个时代 fetch - Ajax的替代者 axios、request等众多开源库 三、关于网络请求的疑问 Ajax的出现解决了什么问题 原生Ajax如何使用 jQuery的网络请求方式 fetch的用法以及坑点 如何正确的使用fetch 如何选择合适的跨域方式 带着以上这些问题、关注点我们对几种网络请求进行一次全面的分析。 四、Ajax的出现解决了什么问题在Ajax出现之前，web程序是这样工作的： 这种交互的的缺陷是显而易见的，任何和服务器的交互都需要刷新页面，用户体验非常差，Ajax的出现解决了这个问题。Ajax全称Asynchronous JavaScript + XML（异步JavaScript和XML） 使用Ajax，网页应用能够快速地将增量更新呈现在用户界面上，而不需要重载（刷新）整个页面。 Ajax本身不是一种新技术，而是用来描述一种使用现有技术集合实现的一个技术方案，浏览器的XMLHttpRequest是实现Ajax最重要的对象（IE6以下使用ActiveXObject）。 尽管X在Ajax中代表XML, 但由于JSON的许多优势，比如更加轻量以及作为Javascript的一部分，目前JSON的使用比XML更加普遍。 五、原生Ajax的用法这里主要分析XMLHttpRequest对象，下面是它的一段基础使用： var xhr = new XMLHttpRequest();xhr.open('post','www.xxx.com',true)// 接收返回值xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4 )&#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; console.log(xhr.responseText); &#125; &#125;&#125;// 处理请求参数postData = &#123;\"name1\":\"value1\",\"name2\":\"value2\"&#125;;postData = (function(value)&#123;var dataString = \"\";for(var key in value)&#123; dataString += key+\"=\"+value[key]+\"&amp;\";&#125;; return dataString;&#125;(postData));// 设置请求头xhr.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");// 异常处理xhr.onerror = function() &#123; console.log('Network request failed')&#125;// 跨域携带cookiexhr.withCredentials = true;// 发出请求xhr.send(postData); 下面分别对XMLHttpRequest对象常用的的函数、属性、事件进行分析。 函数open 用于初始化一个请求，用法： xhr.open(method, url, async); method：请求方式，如get、post url：请求的url async：是否为异步请求 send 用于发送HTTP请求，即调用该方法后HTTP请求才会被真正发出，用法： xhr.send(param) param：http请求的参数，可以为string、Blob等类型。 abort 用于终止一个ajax请求，调用此方法后readyState将被设置为0，用法： xhr.abort() setRequestHeader 用于设置HTTP请求头，此方法必须在open()方法和send()之间调用，用法： xhr.setRequestHeader(header, value); getResponseHeader 用于获取http返回头，如果在返回头中有多个一样的名称，那么返回的值就会是用逗号和空格将值分隔的字符串，用法： var header = xhr.getResponseHeader(name); 属性readyState 用来标识当前XMLHttpRequest对象所处的状态，XMLHttpRequest对象总是位于下列状态中的一个： 值 状态 描述 0 UNSENT 代理被创建，但尚未调用 open() 方法。 1 OPENED open() 方法已经被调用。 2 HEADERS_RECEIVED send()方法已经被调用，并且头部和状态已经可获得。 3 LOADING 下载中； responseText 属性已经包含部分数据。 4 DONE 下载操作已完成。 status 表示http请求的状态, 初始值为0。如果服务器没有显式地指定状态码, 那么status将被设置为默认值, 即200。 responseType 表示响应的数据类型，并允许我们手动设置，如果为空，默认为text类型，可以有下面的取值： 值 描述 &quot;&quot; 将 responseType设为空字符串与设置为&quot;text&quot;相同， 是默认类型 （实际上是 DOMString）。 &quot;arraybuffer&quot; response 是一个包含二进制数据的JavaScript ArrayBuffer 。 &quot;blob&quot; response是一个包含二进制数据的 Blob 对象 。 &quot;document&quot; response 是一个HTML Document或XML XMLDocument，这取决于接收到的数据的 MIME 类型。 &quot;json&quot; response 是一个 JavaScript 对象。这个对象是通过将接收到的数据类型视为JSON解析得到的。 &quot;text&quot; response是包含在DOMString对象中的文本。 response 返回响应的正文，返回的类型由上面的responseType决定。 withCredentials ajax请求默认会携带同源请求的cookie，而跨域请求则不会携带cookie，设置xhr的withCredentials的属性为true将允许携带跨域cookie。 事件回调onreadystatechange xhr.onreadystatechange = callback; 当readyState属性发生变化时，callback会被触发。 onloadstart xhr.onloadstart = callback; 在ajax请求发送之前（readyState==1后, readyState==2前），callback会被触发。 onprogress xhr.onprogress = function(event)&#123; console.log(event.loaded / event.total);&#125; 回调函数可以获取资源总大小total，已经加载的资源大小loaded，用这两个值可以计算加载进度。 onload xhr.onload = callback; 当一个资源及其依赖资源已完成加载时，将触发callback，通常我们会在onload事件中处理返回值。 异常处理onerror xhr.onerror = callback; 当ajax资源加载失败时会触发callback。 ontimeout xhr.ontimeout = callback; 当进度由于预定时间到期而终止时，会触发callback，超时时间可使用timeout属性进行设置。 六、jQuery对Ajax的封装在很长一段时间里，人们使用jQuery提供的ajax封装进行网络请求，包括$.ajax、$.get、$.post等，这几个方法放到现在，我依然觉得很实用。 $.ajax(&#123; dataType: 'json', // 设置返回值类型 contentType: 'application/json', // 设置参数类型 headers: &#123;'Content-Type','application/json'&#125;,// 设置请求头 xhrFields: &#123; withCredentials: true &#125;, // 跨域携带cookie data: JSON.stringify(&#123;a: [&#123;b:1, a:1&#125;]&#125;), // 传递参数 error:function(xhr,status)&#123; // 错误处理 console.log(xhr,status); &#125;, success: function (data,status) &#123; // 获取结果 console.log(data,status); &#125;&#125;) $.ajax只接收一个参数，这个参数接收一系列配置，其自己封装了一个jqXHR对象，有兴趣可以阅读一下jQuary-ajax 源码 常用配置： url 当前页地址。发送请求的地址。 type 类型：String 请求方式 (&quot;POST&quot; 或&quot;GET&quot;)， 默认为 &quot;GET&quot;。注意：其它HTTP请求方法，如PUT和 DELETE也可以使用，但仅部分浏览器支持。 timeout 类型：Number设置请求超时时间（毫秒）。此设置将覆盖全局设置。 success 类型：Function 请求成功后的回调函数。 jsonp 在一个jsonp请求中重写回调函数的名字。这个值用来替代在&quot;callback=?&quot;这种GET或POST请求中URL参数里的&quot;callback&quot;部分。 error 类型：Function 。请求失败时调用此函数。 注意：源码里对错误的判定： isSuccess = status &gt;= 200 &amp;&amp; status &lt; 300 || status === 304; 返回值除了这几个状态码都会进error回调。 dataType \"xml\": 返回 XML 文档，可用 jQuery 处理。\"html\": 返回纯文本 HTML 信息；包含的 script 标签会在插入 dom 时执行。\"script\": 返回纯文本 JavaScript 代码。不会自动缓存结果。除非设置了 \"cache\" 参数。注意：在远程请求时(不在同一个域下)，所有 POST 请求都将转为 GET 请求。（因为将使用 DOM 的 script标签来加载）\"json\": 返回 JSON 数据 。\"jsonp\": JSONP 格式。使用 JSONP 形式调用函数时，如 \"myurl?callback=?\" jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。\"text\": 返回纯文本字符串 data 类型：String 使用JSON.stringify转码 complete 类型：Function请求完成后回调函数 (请求成功或失败之后均调用)。 async 类型：Boolean 默认值:true。默认设置下，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为 false。 contentType 类型：String默认值: &quot;application/x-www-form-urlencoded&quot;。发送信息至服务器时内容编码类型。 键值对这样组织在一般的情况下是没有什么问题的，这里说的一般是，不带嵌套类型JSON，也就是 简单的JSON，形如这样： &#123; a: 1, b: 2, c: 3&#125; 但是在一些复杂的情况下就有问题了。 例如在 Ajax中你要传一个复杂的 json 对像，也就说是对象嵌数组，数组中包括对象，你这样传：application/x-www-form-urlencoded 这种形式是没有办法将复杂的JSON组织成键值对形式。 &#123; data: &#123; a: [&#123; x: 2 &#125;] &#125;&#125; 可以用如下方式传递复杂的json对象 $.ajax(&#123; dataType: 'json', contentType: 'application/json', data: JSON.stringify(&#123;a: [&#123;b:1, a:1&#125;]&#125;)&#125;) 七、jQuery的替代者近年来前端MV*的发展壮大，人们越来越少的使用jQuery，我们不可能单独为了使用jQuery的Ajax api来单独引入他，无可避免的，我们需要寻找新的技术方案。 尤雨溪在他的文档中推荐大家用axios进行网络请求。axios基于Promise对原生的XHR进行了非常全面的封装，使用方式也非常的优雅。另外，axios同样提供了在node环境下的支持，可谓是网络请求的首选方案。 未来必定还会出现更优秀的封装，他们有非常周全的考虑以及详细的文档，这里我们不多做考究，我们把关注的重点放在更底层的APIfetch。 Fetch API是一个用用于访问和操纵HTTP管道的强大的原生 API。 这种功能以前是使用 XMLHttpRequest实现的。Fetch提供了一个更好的替代方法，可以很容易地被其他技术使用，例如 Service Workers。Fetch还提供了单个逻辑位置来定义其他HTTP相关概念，例如CORS和HTTP的扩展。 可见fetch是作为XMLHttpRequest的替代品出现的。 使用fetch，你不需要再额外加载一个外部资源。但它还没有被浏览器完全支持，所以你仍然需要一个polyfill。 八、fetch的使用一个基本的 fetch请求： const options = &#123; method: \"POST\", // 请求参数 headers: &#123; \"Content-Type\": \"application/json\"&#125;, // 设置请求头 body: JSON.stringify(&#123;name:'123'&#125;), // 请求参数 credentials: \"same-origin\", // cookie设置 mode: \"cors\", // 跨域&#125;fetch('http://www.xxx.com') .then(function(response) &#123; return response.json(); &#125;) .then(function(myJson) &#123; console.log(myJson); // 响应数据 &#125;) .catch(function(err)&#123; console.log(err); // 异常处理 &#125;) Fetch API提供了一个全局的fetch()方法，以及几个辅助对象来发起一个网络请求。 fetch() fetch()方法用于发起获取资源的请求。它返回一个promise，这个 promise 会在请求响应后被 resolve，并传回 Response 对象。 Headers 可以通过Headers()构造函数来创建一个你自己的headers对象，相当于 response/request 的头信息，可以使你查询到这些头信息，或者针对不同的结果做不同的操作。var myHeaders = new Headers();myHeaders.append(\"Content-Type\", \"text/plain\"); Request 通过Request()构造函数可以创建一个Request对象，这个对象可以作为fetch函数的第二个参数。 Response 在fetch()处理完promises之后返回一个Response实例，也可以手动创建一个Response实例。 九、fetch polyfill源码分析由于fetch是一个非常底层的API，所以我们无法进一步的探究它的底层，但是我们可以借助它的polyfill探究它的基本原理，并找出其中的坑点。 代码结构 由代码可见，polyfill主要对Fetch API提供的四大对象进行了封装： fetch 封装 代码非常清晰： 构造一个Promise对象并返回 创建一个Request对象 创建一个XMLHttpRequest对象 取出Request对象中的请求url，请求方发，open一个xhr请求，并将Request对象中存储的headers取出赋给xhr xhr onload后取出response的status、headers、body封装Response对象，调用resolve。 异常处理 可以发现，调用reject有三种可能： 1.请求超时 2.请求失败 注意：当和服务器建立简介，并收到服务器的异常状态码如404、500等并不能触发onerror。当网络故障时或请求被阻止时，才会标记为 reject，如跨域、url不存在，网络异常等会触发onerror。 所以使用fetch当接收到异常状态码都是会进入then而不是catch。这些错误请求往往要手动处理。 3.手动终止 可以在request参数中传入signal对象，并对signal对象添加abort事件监听，当xhr.readyState变为4（响应内容解析完成）后将signal对象的abort事件监听移除掉。 这表示，在一个fetch请求结束之前可以调用signal.abort将其终止。在浏览器中可以使用AbortController()构造函数创建一个控制器，然后使用AbortController.signal属性 这是一个实验中的功能，此功能某些浏览器尚在开发中 Headers封装 在header对象中维护了一个map对象，构造函数中可以传入Header对象、数组、普通对象类型的header，并将所有的值维护到map中。 之前在fetch函数中看到调用了header的forEach方法，下面是它的实现： 可见header的遍历即其内部map的遍历。 另外Header还提供了append、delete、get、set等方法，都是对其内部的map对象进行操作。 Request对象 Request对象接收的两个参数即fetch函数接收的两个参数，第一个参数可以直接传递url，也可以传递一个构造好的request对象。第二个参数即控制不同配置的option对象。 可以传入credentials、headers、method、mode、signal、referrer等属性。 这里注意： 传入的headers被当作Headers构造函数的参数来构造header对象。 cookie处理fetch函数中还有如下的代码： if (request.credentials === 'include') &#123; xhr.withCredentials = true&#125; else if (request.credentials === 'omit') &#123; xhr.withCredentials = false&#125; 默认的credentials类型为same-origin,即可携带同源请求的coodkie。 然后我发现这里polyfill的实现和MDN-使用Fetch以及很多资料是不一致的： mdn: 默认情况下，fetch 不会从服务端发送或接收任何 cookies 于是我分别实验了下使用polyfill和使用原生fetch携带cookie的情况，发现在不设置credentials的情况下居然都是默认携带同源cookie的，这和文档的说明说不一致的，查阅了许多资料后都是说fetch默认不会携带cookie，下面是使用原生fetch在浏览器进行请求的情况： 然后我发现在MDN-Fetch-Request已经指出新版浏览器credentials默认值已更改为same-origin，旧版依然是omit。 确实MDN-使用Fetch这里的文档更新的有些不及时，误人子弟了… Response对象Response对象是fetch调用成功后的返回值： 回顾下fetch中对Response`的操作： xhr.onload = function () &#123; var options = &#123; status: xhr.status, statusText: xhr.statusText, headers: parseHeaders(xhr.getAllResponseHeaders() || '') &#125; options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL') var body = 'response' in xhr ? xhr.response : xhr.responseText resolve(new Response(body, options))&#125; Response构造函数： 可见在构造函数中主要对options中的status、statusText、headers、url等分别做了处理并挂载到Response对象上。 构造函数里面并没有对responseText的明确处理，最后交给了_initBody函数处理，而Response并没有主动声明_initBody属性，代码最后使用Response调用了Body函数，实际上_initBody函数是通过Body函数挂载到Response身上的，先来看看_initBody函数： 可见，_initBody函数根据xhr.response的类型（Blob、FormData、String...），为不同的参数进行赋值，这些参数在Body方法中得到不同的应用，下面具体看看Body函数还做了哪些其他的操作： Body函数中还为Response对象挂载了四个函数，text、json、blob、formData，这些函数中的操作就是将_initBody中得到的不同类型的返回值返回。 这也说明了，在fetch执行完毕后，不能直接在response中获取到返回值而必须调用text()、json()等函数才能获取到返回值。 这里还有一点需要说明：几个函数中都有类似下面的逻辑： var rejected = consumed(this)if (rejected) &#123; return rejected&#125; consumed函数：function consumed(body) &#123; if (body.bodyUsed) &#123; return Promise.reject(new TypeError('Already read')) &#125; body.bodyUsed = true&#125; 每次调用text()、json()等函数后会将bodyUsed变量变为true，用来标识返回值已经读取过了，下一次再读取直接抛出TypeError(&#39;Already read&#39;)。这也遵循了原生fetch的原则： 因为Responses对象被设置为了 stream 的方式，所以它们只能被读取一次 十、fetch的坑点VUE的文档中对fetch有下面的描述： 使用fetch还有很多别的注意事项，这也是为什么大家现阶段还是更喜欢axios 多一些。当然这个事情在未来可能会发生改变。 由于fetch是一个非常底层的API，它并没有被进行很多封装，还有许多问题需要处理： 不能直接传递JavaScript对象作为参数 需要自己判断返回值类型，并执行响应获取返回值的方法 获取返回值方法只能调用一次，不能多次调用 无法正常的捕获异常 老版浏览器不会默认携带cookie 不支持jsonp 十一、对fetch的封装请求参数处理支持传入不同的参数类型：function stringify(url, data) &#123; var dataString = url.indexOf('?') == -1 ? '?' : '&amp;'; for (var key in data) &#123; dataString += key + '=' + data[key] + '&amp;'; &#125;; return dataString;&#125;if (request.formData) &#123; request.body = request.data;&#125; else if (/^get$/i.test(request.method)) &#123; request.url = `$&#123;request.url&#125;$&#123;stringify(request.url, request.data)&#125;`;&#125; else if (request.form) &#123; request.headers.set('Content-Type', 'application/x-www-form-urlencoded;charset=UTF-8'); request.body = stringify(request.data);&#125; else &#123; request.headers.set('Content-Type', 'application/json;charset=UTF-8'); request.body = JSON.stringify(request.data);&#125; cookie携带fetch在新版浏览器已经开始默认携带同源cookie，但在老版浏览器中不会默认携带，我们需要对他进行统一设置： request.credentials = 'same-origin'; // 同源携带request.credentials = 'include'; // 可跨域携带 异常处理 当接收到一个代表错误的 HTTP 状态码时，从 fetch()返回的 Promise 不会被标记为 reject， 即使该 HTTP 响应的状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 ok 属性设置为 false ），仅当网络故障时或请求被阻止时，才会标记为 reject。 因此我们要对fetch的异常进行统一处理 .then(response =&gt; &#123; if (response.ok) &#123; return Promise.resolve(response); &#125;else&#123; const error = new Error(`请求失败! 状态码: $&#123;response.status&#125;, 失败信息: $&#123;response.statusText&#125;`); error.response = response; return Promise.reject(error); &#125;&#125;); 返回值处理对不同的返回值类型调用不同的函数接收，这里必须提前判断好类型，不能多次调用获取返回值的方法： .then(response =&gt; &#123; let contentType = response.headers.get('content-type'); if (contentType.includes('application/json')) &#123; return response.json(); &#125; else &#123; return response.text(); &#125;&#125;); jsonpfetch本身没有提供对jsonp的支持，jsonp本身也不属于一种非常好的解决跨域的方式，推荐使用cors或者nginx解决跨域，具体请看下面的章节。 fetch封装好了，可以愉快的使用了。 嗯，axios真好用… 十二、跨域总结谈到网络请求，就不得不提跨域。 浏览器的同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。通常不允许不同源间的读操作。 跨域条件：协议，域名，端口，有一个不同就算跨域。 下面是解决跨域的几种方式： nginx使用nginx反向代理实现跨域，参考我这篇文章：前端开发者必备的nginx知识 corsCORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求。 服务端设置Access-Control-Allow-Origin就可以开启CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。 app.all('*', function (req, res, next) &#123; res.header(\"Access-Control-Allow-Origin\", \"*\"); res.header(\"Access-Control-Allow-Headers\", \"X-Requested-With\"); res.header(\"Access-Control-Allow-Methods\", \"PUT,POST,GET,DELETE,OPTIONS\"); next();&#125;); jsonpscript标签的src属性中的链接可以访问跨域的js脚本，利用这个特性，服务端不再返回JSON格式的数据，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。 jquery对jsonp的支持： $.ajax(&#123; type : \"get\", url : \"http://xxxx\" dataType: \"jsonp\", jsonp:\"callback\", jsonpCallback: \"doo\", success : function(data) &#123; console.log(data); &#125;&#125;); fetch、axios等并没有直接提供对jsonp的支持，如果需要使用这种方式，我们可以尝试进行手动封装： (function (window,document) &#123; \"use strict\"; var jsonp = function (url,data,callback) &#123; // 1.将传入的data数据转化为url字符串形式 // &#123;id:1,name:'jack'&#125; =&gt; id=1&amp;name=jack var dataString = url.indexof('?') == -1? '?': '&amp;'; for(var key in data)&#123; dataString += key + '=' + data[key] + '&amp;'; &#125;; // 2 处理url中的回调函数 // cbFuncName回调函数的名字 ：my_json_cb_名字的前缀 + 随机数（把小数点去掉） var cbFuncName = 'my_json_cb_' + Math.random().toString().replace('.',''); dataString += 'callback=' + cbFuncName; // 3.创建一个script标签并插入到页面中 var scriptEle = document.createElement('script'); scriptEle.src = url + dataString; // 4.挂载回调函数 window[cbFuncName] = function (data) &#123; callback(data); // 处理完回调函数的数据之后，删除jsonp的script标签 document.body.removeChild(scriptEle); &#125; document.body.appendChild(scriptEle); &#125; window.$jsonp = jsonp;&#125;)(window,document) postMessage跨域postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。 //捕获iframevar domain = 'http://scriptandstyle.com';var iframe = document.getElementById('myIFrame').contentWindow;//发送消息setInterval(function()&#123; var message = 'Hello! The time is: ' + (new Date().getTime()); console.log('blog.local: sending message: ' + message); //send the message and target URI iframe.postMessage(message,domain); &#125;,6000); //响应事件window.addEventListener('message',function(event) &#123; if(event.origin !== 'http://davidwalsh.name') return; console.log('message received: ' + event.data,event); event.source.postMessage('holla back youngin!',event.origin);&#125;,false); postMessage跨域适用于以下场景：同浏览器多窗口间跨域通信、iframe间跨域通信。 WebSocketWebSocket 是一种双向通信协议，在建立连接之后，WebSocket的 server与 client都能主动向对方发送或接收数据而不受同源策略的限制。 function WebSocketTest()&#123; if (\"WebSocket\" in window)&#123; alert(\"您的浏览器支持 WebSocket!\"); // 打开一个 web socket var ws = new WebSocket(\"ws://localhost:3000/abcd\"); ws.onopen = function()&#123; // Web Socket 已连接上，使用 send() 方法发送数据 ws.send(\"发送数据\"); alert(\"数据发送中...\"); &#125;; ws.onmessage = function (evt) &#123; var received_msg = evt.data; alert(\"数据已接收...\"); &#125;; ws.onclose = function()&#123; // 关闭 websocket alert(\"连接已关闭...\"); &#125;; &#125; else&#123; // 浏览器不支持 WebSocket alert(\"您的浏览器不支持 WebSocket!\"); &#125;&#125; 文中如有错误，欢迎在评论区指正，谢谢阅读。","categories":[],"tags":[{"name":"浏览器和网络","slug":"浏览器和网络","permalink":"www.conardli.top/tags/浏览器和网络/"}]},{"title":"前端开发者必备的nginx知识","slug":"【前端工程】前端开发者必备的nginx知识","date":"2019-03-12T06:50:35.000Z","updated":"2019-04-06T05:25:56.565Z","comments":true,"path":"2019/03/12/【前端工程】前端开发者必备的nginx知识/","link":"","permalink":"www.conardli.top/2019/03/12/【前端工程】前端开发者必备的nginx知识/","excerpt":"","text":"nginx在应用程序中的作用 解决跨域 请求过滤 配置gzip 负载均衡 静态资源服务器 nginx是一个高性能的HTTP和反向代理服务器，也是一个通用的TCP/UDP代理服务器，最初由俄罗斯人Igor Sysoev编写。 nginx现在几乎是众多大型网站的必用技术，大多数情况下，我们不需要亲自去配置它，但是了解它在应用程序中所担任的角色，以及如何解决这些问题是非常必要的。 下面我将从nginx在企业中的真实应用来解释nginx在应用程序中起到的作用。 为了便于理解，首先先来了解一下一些基础知识，nginx是一个高性能的反向代理服务器那么什么是反向代理呢？ 正向代理与反向代理代理是在服务器和客户端之间假设的一层服务器，代理将接收客户端的请求并将它转发给服务器，然后将服务端的响应转发给客户端。 不管是正向代理还是反向代理，实现的都是上面的功能。 正向代理 正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。 正向代理是为我们服务的，即为客户端服务的，客户端可以根据正向代理访问到它本身无法访问到的服务器资源。 正向代理对我们是透明的，对服务端是非透明的，即服务端并不知道自己收到的是来自代理的访问还是来自真实客户端的访问。 反向代理 反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。 反向代理是为服务端服务的，反向代理可以帮助服务器接收来自客户端的请求，帮助服务器做请求转发，负载均衡等。 反向代理对服务端是透明的，对我们是非透明的，即我们并不知道自己访问的是代理服务器，而服务器知道反向代理在为他服务。 基本配置配置结构下面是一个nginx配置文件的基本结构： events &#123; &#125;http &#123; server &#123; location path &#123; ... &#125; location path &#123; ... &#125; &#125; server &#123; ... &#125;&#125; main:nginx的全局配置，对全局生效。 events:配置影响nginx服务器或与用户的网络连接。 http：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。 server：配置虚拟主机的相关参数，一个http中可以有多个server。 location：配置请求的路由，以及各种页面的处理情况。 upstream：配置后端服务器具体地址，负载均衡配置不可或缺的部分。 内置变量下面是nginx一些配置中常用的内置全局变量，你可以在配置的任何位置使用它们。 变量名 功能 $host 请求信息中的Host，如果请求中没有Host行，则等于设置的服务器名 $request_method 客户端请求类型，如GET、POST $remote_addr 客户端的IP地址 $args 请求中的参数 $content_length 请求头中的Content-length字段 $http_user_agent 客户端agent信息 $http_cookie 客户端cookie信息 $remote_addr 客户端的IP地址 $remote_port 客户端的端口 $server_protocol 请求使用的协议，如HTTP/1.0、·HTTP/1.1` $server_addr 服务器地址 $server_name 服务器名称 $server_port 服务器的端口号 解决跨域先追本溯源以下，跨域究竟是怎么回事。 跨域的定义同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。通常不允许不同源间的读操作。 同源的定义如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源。 nginx解决跨域的原理例如： 前端server的域名为：fe.server.com 后端服务的域名为：dev.server.com 现在我在fe.server.com对dev.server.com发起请求一定会出现跨域。 现在我们只需要启动一个nginx服务器，将server_name设置为fe.server.com,然后设置相应的location以拦截前端需要跨域的请求，最后将请求代理回dev.server.com。如下面的配置： server &#123; listen 80; server_name fe.server.com; location / &#123; proxy_pass dev.server.com; &#125;&#125; 这样可以完美绕过浏览器的同源策略：fe.server.com访问nginx的fe.server.com属于同源访问，而nginx对服务端转发的请求不会触发浏览器的同源策略。 请求过滤 根据状态码过滤error_page 500 501 502 503 504 506 /50x.html; location = /50x.html &#123; #将跟路径改编为存放html的路径。 root /root/static/html; &#125; 根据URL名称过滤，精准匹配URL，不匹配的URL全部重定向到主页。 location / &#123; rewrite ^.*$ /index.html redirect;&#125; 根据请求类型过滤。if ( $request_method !~ ^(GET|POST|HEAD)$ ) &#123; return 403; &#125; 配置gzip GZIP是规定的三种标准HTTP压缩格式之一。目前绝大多数的网站都在使用GZIP传输 HTML、CSS、JavaScript 等资源文件。 对于文本文件，GZip 的效果非常明显，开启后传输所需流量大约会降至 1/4 ~ 1/3。 并不是每个浏览器都支持gzip的，如何知道客户端是否支持gzip呢，请求头中的Accept-Encoding来标识对压缩的支持。 启用gzip同时需要客户端和服务端的支持，如果客户端支持gzip的解析，那么只要服务端能够返回gzip的文件就可以启用gzip了,我们可以通过nginx的配置来让服务端支持gzip。下面的respone中content-encoding:gzip，指服务端开启了gzip的压缩方式。 gzip on;gzip_http_version 1.1; gzip_comp_level 5;gzip_min_length 1000;gzip_types text/csv text/xml text/css text/plain text/javascript application/javascript application/x-javascript application/json application/xml; gzip 开启或者关闭gzip模块 默认值为off 可配置为on / off gzip_http_version 启用 GZip 所需的HTTP 最低版本 默认值为HTTP/1.1 这里为什么默认版本不是1.0呢？ HTTP 运行在TCP 连接之上，自然也有着跟TCP 一样的三次握手、慢启动等特性。 启用持久连接情况下，服务器发出响应后让TCP连接继续打开着。同一对客户/服务器之间的后续请求和响应可以通过这个连接发送。 为了尽可能的提高 HTTP 性能，使用持久连接就显得尤为重要了。 HTTP/1.1默认支持TCP持久连接，HTTP/1.0 也可以通过显式指定 Connection: keep-alive 来启用持久连接。对于TCP持久连接上的HTTP 报文，客户端需要一种机制来准确判断结束位置，而在 HTTP/1.0中，这种机制只有Content-Length。而在HTTP/1.1中新增的 Transfer-Encoding: chunked 所对应的分块传输机制可以完美解决这类问题。 nginx同样有着配置chunked的属性chunked_transfer_encoding，这个属性是默认开启的。 Nginx在启用了GZip的情况下，不会等文件 GZip 完成再返回响应，而是边压缩边响应，这样可以显著提高 TTFB(Time To First Byte，首字节时间，WEB 性能优化重要指标)。这样唯一的问题是，Nginx 开始返回响应时，它无法知道将要传输的文件最终有多大，也就是无法给出Content-Length这个响应头部。 所以，在HTTP1.0中如果利用Nginx启用了GZip，是无法获得Content-Length的，这导致HTTP1.0中开启持久链接和使用GZip只能二选一，所以在这里gzip_http_version默认设置为1.1。 gzip_comp_level 压缩级别，级别越高压缩率越大，当然压缩时间也就越长（传输快但比较消耗cpu）。 默认值为 1 压缩级别取值为1-9 gzip_min_length 设置允许压缩的页面最小字节数，Content-Length小于该值的请求将不会被压缩 默认值:0 当设置的值较小时，压缩后的长度可能比原文件大，建议设置1000以上 gzip_types 要采用gzip压缩的文件类型(MIME类型) 默认值:text/html(默认不压缩js/css) 负载均衡什么是负载均衡 如上面的图，前面是众多的服务窗口，下面有很多用户需要服务，我们需要一个工具或策略来帮助我们将如此多的用户分配到每个窗口，来达到资源的充分利用以及更少的排队时间。 把前面的服务窗口想像成我们的后端服务器，而后面终端的人则是无数个客户端正在发起请求。负载均衡就是用来帮助我们将众多的客户端请求合理的分配到各个服务器，以达到服务端资源的充分利用和更少的请求时间。 nginx如何实现负载均衡Upstream指定后端服务器地址列表 upstream balanceServer &#123; server 10.1.22.33:12345; server 10.1.22.34:12345; server 10.1.22.35:12345;&#125; 在server中拦截响应请求，并将请求转发到Upstream中配置的服务器列表。 server &#123; server_name fe.server.com; listen 80; location /api &#123; proxy_pass http://balanceServer; &#125;&#125; 上面的配置只是指定了nginx需要转发的服务端列表，并没有指定分配策略。 nginx实现负载均衡的策略 轮询策略 默认情况下采用的策略，将所有客户端请求轮询分配给服务端。这种策略是可以正常工作的，但是如果其中某一台服务器压力太大，出现延迟，会影响所有分配在这台服务器下的用户。 upstream balanceServer &#123; server 10.1.22.33:12345; server 10.1.22.34:12345; server 10.1.22.35:12345;&#125; 最小连接数策略 将请求优先分配给压力较小的服务器，它可以平衡每个队列的长度，并避免向压力大的服务器添加更多的请求。 upstream balanceServer &#123; least_conn; server 10.1.22.33:12345; server 10.1.22.34:12345; server 10.1.22.35:12345;&#125; 最快响应时间策略 依赖于NGINX Plus，优先分配给响应时间最短的服务器。 upstream balanceServer &#123; fair; server 10.1.22.33:12345; server 10.1.22.34:12345; server 10.1.22.35:12345;&#125; 客户端ip绑定 来自同一个ip的请求永远只分配一台服务器，有效解决了动态网页存在的session共享问题。upstream balanceServer &#123; ip_hash; server 10.1.22.33:12345; server 10.1.22.34:12345; server 10.1.22.35:12345;&#125; 静态资源服务器location ~* \\.(png|gif|jpg|jpeg)$ &#123; root /root/static/; autoindex on; access_log off; expires 10h;# 设置过期时间为10小时 &#125; 匹配以png|gif|jpg|jpeg为结尾的请求，并将请求转发到本地路径，root中指定的路径即nginx本地路径。同时也可以进行一些缓存的设置。 小结nginx的功能非常强大，还有很多需要探索，上面的一些配置都是公司配置的真实应用（精简过了），如果您有什么意见或者建议，欢迎在下方留言…","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"www.conardli.top/tags/nginx/"}]},{"title":"【React深入】React事件机制","slug":"【React深入】React事件机制","date":"2019-03-06T08:19:35.000Z","updated":"2019-04-16T11:42:58.977Z","comments":true,"path":"2019/03/06/【React深入】React事件机制/","link":"","permalink":"www.conardli.top/2019/03/06/【React深入】React事件机制/","excerpt":"","text":"关于React事件的疑问 1.为什么要手动绑定this 2.React事件和原生事件有什么区别 3.React事件和原生事件的执行顺序，可以混用吗 4.React事件如何解决跨浏览器兼容 5.什么是合成事件 下面是我阅读过源码后，将所有的执行流程总结出来的流程图，不会贴代码，如果你想阅读代码看看具体是如何实现的，可以根据流程图去源码里寻找。 事件注册 组件装载 / 更新。 通过lastProps、nextProps判断是否新增、删除事件分别调用事件注册、卸载方法。 调用EventPluginHub的enqueuePutListener进行事件存储 获取document对象。 根据事件名称（如onClick、onCaptureClick）判断是进行冒泡还是捕获。 判断是否存在addEventListener方法，否则使用attachEvent（兼容IE）。 给document注册原生事件回调为dispatchEvent（统一的事件分发机制）。 事件存储 EventPluginHub负责管理React合成事件的callback，它将callback存储在listenerBank中，另外还存储了负责合成事件的Plugin。 EventPluginHub的putListener方法是向存储容器中增加一个listener。 获取绑定事件的元素的唯一标识key。 将callback根据事件类型，元素的唯一标识key存储在listenerBank中。 listenerBank的结构是：listenerBank[registrationName][key]。 例如： &#123; onClick:&#123; nodeid1:()=&gt;&#123;...&#125; nodeid2:()=&gt;&#123;...&#125; &#125;, onChange:&#123; nodeid3:()=&gt;&#123;...&#125; nodeid4:()=&gt;&#123;...&#125; &#125;&#125; 事件触发 / 执行 这里的事件执行利用了React的批处理机制，在前一篇的【React深入】setState执行机制中已经分析过，这里不再多加分析。 触发document注册原生事件的回调dispatchEvent 获取到触发这个事件最深一级的元素 例如下面的代码：首先会获取到this.child &lt;div onClick=&#123;this.parentClick&#125; ref=&#123;ref =&gt; this.parent = ref&#125;&gt; &lt;div onClick=&#123;this.childClick&#125; ref=&#123;ref =&gt; this.child = ref&#125;&gt; test &lt;/div&gt;&lt;/div&gt; 遍历这个元素的所有父元素，依次对每一级元素进行处理。 构造合成事件。 将每一级的合成事件存储在eventQueue事件队列中。 遍历eventQueue。 通过isPropagationStopped判断当前事件是否执行了阻止冒泡方法。 如果阻止了冒泡，停止遍历，否则通过executeDispatch执行合成事件。 释放处理完成的事件。 react在自己的合成事件中重写了stopPropagation方法，将isPropagationStopped设置为true，然后在遍历每一级事件的过程中根据此遍历判断是否继续执行。这就是react自己实现的冒泡机制。 合成事件 调用EventPluginHub的extractEvents方法。 循环所有类型的EventPlugin（用来处理不同事件的工具方法）。 在每个EventPlugin中根据不同的事件类型，返回不同的事件池。 在事件池中取出合成事件，如果事件池是空的，那么创建一个新的。 根据元素nodeid(唯一标识key)和事件类型从listenerBink中取出回调函数 返回带有合成事件参数的回调函数 总流程将上面的四个流程串联起来。 为什么要手动绑定this通过事件触发过程的分析，dispatchEvent调用了invokeGuardedCallback方法。 function invokeGuardedCallback(name, func, a) &#123; try &#123; func(a); &#125; catch (x) &#123; if (caughtError === null) &#123; caughtError = x; &#125; &#125;&#125; 可见，回调函数是直接调用调用的，并没有指定调用的组件，所以不进行手动绑定的情况下直接获取到的this是undefined。 这里可以使用实验性的属性初始化语法 ，也就是直接在组件声明箭头函数。箭头函数不会创建自己的this，它只会从自己的作用域链的上一层继承this。因此这样我们在React事件中获取到的就是组件本身了。 和原生事件有什么区别 React 事件使用驼峰命名，而不是全部小写。 通过 JSX , 你传递一个函数作为事件处理程序，而不是一个字符串。 例如，HTML：&lt;button onclick=\"activateLasers()\"&gt; Activate Lasers&lt;/button&gt; 在 React 中略有不同：&lt;button onClick=&#123;activateLasers&#125;&gt; Activate Lasers&lt;/button&gt; 另一个区别是，在 React 中你不能通过返回false 来阻止默认行为。必须明确调用 preventDefault。 由上面执行机制我们可以得出：React自己实现了一套事件机制，自己模拟了事件冒泡和捕获的过程，采用了事件代理，批量更新等方法，并且抹平了各个浏览器的兼容性问题。 React事件和原生事件的执行顺序componentDidMount() &#123; this.parent.addEventListener('click', (e) =&gt; &#123; console.log('dom parent'); &#125;) this.child.addEventListener('click', (e) =&gt; &#123; console.log('dom child'); &#125;) document.addEventListener('click', (e) =&gt; &#123; console.log('document'); &#125;)&#125;childClick = (e) =&gt; &#123; console.log('react child');&#125;parentClick = (e) =&gt; &#123; console.log('react parent');&#125;render() &#123; return ( &lt;div onClick=&#123;this.parentClick&#125; ref=&#123;ref =&gt; this.parent = ref&#125;&gt; &lt;div onClick=&#123;this.childClick&#125; ref=&#123;ref =&gt; this.child = ref&#125;&gt; test &lt;/div&gt; &lt;/div&gt;)&#125; 执行结果： 由上面的流程我们可以理解： react的所有事件都挂载在document中 当真实dom触发后冒泡到document后才会对react事件进行处理 所以原生的事件会先执行 然后执行react合成事件 最后执行真正在document上挂载的事件 react事件和原生事件可以混用吗？react事件和原生事件最好不要混用。 原生事件中如果执行了stopPropagation方法，则会导致其他react事件失效。因为所有元素的事件将无法冒泡到document上。 由上面的执行机制不难得出，所有的react事件都将无法被注册。 合成事件、浏览器兼容function handleClick(e) &#123; e.preventDefault(); console.log(&apos;The link was clicked.&apos;);&#125; 这里， e 是一个合成的事件。 React 根据 W3C 规范 定义了这个合成事件，所以你不需要担心跨浏览器的兼容性问题。 事件处理程序将传递 SyntheticEvent 的实例，这是一个跨浏览器原生事件包装器。 它具有与浏览器原生事件相同的接口，包括stopPropagation() 和 preventDefault() ，在所有浏览器中他们工作方式都相同。 每个SyntheticEvent对象都具有以下属性： boolean bubblesboolean cancelableDOMEventTarget currentTargetboolean defaultPreventednumber eventPhaseboolean isTrustedDOMEvent nativeEventvoid preventDefault()boolean isDefaultPrevented()void stopPropagation()boolean isPropagationStopped()DOMEventTarget targetnumber timeStampstring type React合成的SyntheticEvent采用了事件池，这样做可以大大节省内存，而不会频繁的创建和销毁事件对象。 另外，不管在什么浏览器环境下，浏览器会将该事件类型统一创建为合成事件，从而达到了浏览器兼容的目的。 推荐阅读【React深入】setState的执行机制","categories":[],"tags":[{"name":"React","slug":"React","permalink":"www.conardli.top/tags/React/"}]},{"title":"【React深入】setState的执行机制","slug":"【React深入】setState的执行机制","date":"2019-03-06T08:12:35.000Z","updated":"2019-04-06T05:27:16.846Z","comments":true,"path":"2019/03/06/【React深入】setState的执行机制/","link":"","permalink":"www.conardli.top/2019/03/06/【React深入】setState的执行机制/","excerpt":"","text":"一.几个开发中经常会遇到的问题以下几个问题是我们在实际开发中经常会遇到的场景，下面用几个简单的示例代码来还原一下。 1.setState是同步还是异步的，为什么有的时候不能立即拿到更新结果而有的时候可以?1.1 钩子函数和React合成事件中的setState现在有两个组件 componentDidMount() &#123; console.log('parent componentDidMount');&#125;render() &#123; return ( &lt;div&gt; &lt;SetState2&gt;&lt;/SetState2&gt; &lt;SetState&gt;&lt;/SetState&gt; &lt;/div&gt; );&#125; 组件内部放入同样的代码，并在Setstate1中的componentDidMount中放入一段同步延时代码，打印延时时间： componentWillUpdate() &#123; console.log('componentWillUpdate');&#125;componentDidUpdate() &#123; console.log('componentDidUpdate');&#125;componentDidMount() &#123; console.log('SetState调用setState'); this.setState(&#123; index: this.state.index + 1 &#125;) console.log('state', this.state.index); console.log('SetState调用setState'); this.setState(&#123; index: this.state.index + 1 &#125;) console.log('state', this.state.index);&#125; 下面是执行结果： 说明： 1.调用setState不会立即更新 2.所有组件使用的是同一套更新机制，当所有组件didmount后，父组件didmount，然后执行更新 3.更新时会把每个组件的更新合并，每个组件只会触发一次更新的生命周期。 1.2 异步函数和原生事件中的setstate？在setTimeout中调用setState（例子和在浏览器原生事件以及接口回调中执行效果相同）componentDidMount() &#123; setTimeout(() =&gt; &#123; console.log(&apos;调用setState&apos;); this.setState(&#123; index: this.state.index + 1 &#125;) console.log(&apos;state&apos;, this.state.index); console.log(&apos;调用setState&apos;); this.setState(&#123; index: this.state.index + 1 &#125;) console.log(&apos;state&apos;, this.state.index); &#125;, 0);&#125; 执行结果： 说明： 1.在父组件didmount后执行 2.调用setState同步更新 2.为什么有时连续两次setState只有一次生效？分别执行以下代码： componentDidMount() &#123; this.setState(&#123; index: this.state.index + 1 &#125;, () =&gt; &#123; console.log(this.state.index); &#125;) this.setState(&#123; index: this.state.index + 1 &#125;, () =&gt; &#123; console.log(this.state.index); &#125;)&#125; componentDidMount() &#123; this.setState((preState) =&gt; (&#123; index: preState.index + 1 &#125;), () =&gt; &#123; console.log(this.state.index); &#125;) this.setState(preState =&gt; (&#123; index: preState.index + 1 &#125;), () =&gt; &#123; console.log(this.state.index); &#125;)&#125; 执行结果： 11 22 说明： 1.直接传递对象的setstate会被合并成一次 2.使用函数传递state不会被合并 二.setState执行过程由于源码比较复杂，就不贴在这里了，有兴趣的可以去github上clone一份然后按照下面的流程图去走一遍。 1.流程图 partialState：setState传入的第一个参数，对象或函数 _pendingStateQueue：当前组件等待执行更新的state队列 isBatchingUpdates：react用于标识当前是否处于批量更新状态，所有组件公用 dirtyComponent：当前所有处于待更新状态的组件队列 transcation：react的事务机制，在被事务调用的方法外包装n个waper对象，并一次执行：waper.init、被调用方法、waper.close FLUSH_BATCHED_UPDATES：用于执行更新的waper，只有一个close方法 2.执行过程对照上面流程图的文字说明，大概可分为以下几步： 1.将setState传入的partialState参数存储在当前组件实例的state暂存队列中。 2.判断当前React是否处于批量更新状态，如果是，将当前组件加入待更新的组件队列中。 3.如果未处于批量更新状态，将批量更新状态标识设置为true，用事务再次调用前一步方法，保证当前组件加入到了待更新组件队列中。 4.调用事务的waper方法，遍历待更新组件队列依次执行更新。 5.执行生命周期componentWillReceiveProps。 6.将组件的state暂存队列中的state进行合并，获得最终要更新的state对象，并将队列置为空。 7.执行生命周期componentShouldUpdate，根据返回值判断是否要继续更新。 8.执行生命周期componentWillUpdate。 9.执行真正的更新，render。 10.执行生命周期componentDidUpdate。 三.总结1.钩子函数和合成事件中：在react的生命周期和合成事件中，react仍然处于他的更新机制中，这时isBranchUpdate为true。 按照上述过程，这时无论调用多少次setState，都会不会执行更新，而是将要更新的state存入_pendingStateQueue，将要更新的组件存入dirtyComponent。 当上一次更新机制执行完毕，以生命周期为例，所有组件，即最顶层组件didmount后会将isBranchUpdate设置为false。这时将执行之前累积的setState。 2.异步函数和原生事件中由执行机制看，setState本身并不是异步的，而是如果在调用setState时，如果react正处于更新过程，当前更新会被暂存，等上一次更新执行后在执行，这个过程给人一种异步的假象。 在生命周期，根据JS的异步机制，会将异步函数先暂存，等所有同步代码执行完毕后在执行，这时上一次更新过程已经执行完毕，isBranchUpdate被设置为false，根据上面的流程，这时再调用setState即可立即执行更新，拿到更新结果。 3.partialState合并机制我们看下流程中_processPendingState的代码，这个函数是用来合并state暂存队列的，最后返回一个合并后的state。 _processPendingState: function (props, context) &#123; var inst = this._instance; var queue = this._pendingStateQueue; var replace = this._pendingReplaceState; this._pendingReplaceState = false; this._pendingStateQueue = null; if (!queue) &#123; return inst.state; &#125; if (replace &amp;&amp; queue.length === 1) &#123; return queue[0]; &#125; var nextState = _assign(&#123;&#125;, replace ? queue[0] : inst.state); for (var i = replace ? 1 : 0; i &lt; queue.length; i++) &#123; var partial = queue[i]; _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial); &#125; return nextState;&#125;, 我们只需要关注下面\b这段代码： _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial); 如果传入的是对象，很明显会被合并成一次： Object.assign( nextState, &#123;index: state.index+ 1&#125;, &#123;index: state.index+ 1&#125;) 如果传入的是函数，函数的参数preState是前一次合并后的结果，所以计算结果是准确的。 4.componentDidMount调用setstate 在componentDidMount()中，你 可以立即调用setState()。它将会触发一次额外的渲染，但是它将在浏览器刷新屏幕之前发生。这保证了在此情况下即使render()将会调用两次，用户也不会看到中间状态。谨慎使用这一模式，因为它常导致性能问题。在大多数情况下，你可以 在constructor()中使用赋值初始状态来代替。然而，有些情况下必须这样，比如像模态框和工具提示框。这时，你需要先测量这些DOM节点，才能渲染依赖尺寸或者位置的某些东西。 以上是官方文档的说明，不推荐直接在componentDidMount直接调用setState，由上面的分析：componentDidMount本身处于一次更新中，我们又调用了一次setState，就会在未来再进行一次render，造成不必要的性能浪费，大多数情况可以设置初始值来搞定。 当然在componentDidMount我们可以调用接口，再回调中去修改state，这是正确的做法。 当state初始值依赖dom属性时，在componentDidMount中setState是无法避免的。 5.componentWillUpdate componentDidUpdate这两个生命周期中不能调用setState。 由上面的流程图很容易发现，在它们里面调用setState会造成死循环，导致程序崩溃。 6.推荐使用方式在调用setState时使用函数传递state值，在回调函数中获取最新更新后的state。","categories":[],"tags":[{"name":"React","slug":"React","permalink":"www.conardli.top/tags/React/"}]},{"title":"前端性能优化总结","slug":"【性能优化】前端性能优化总结","date":"2018-12-28T14:33:19.000Z","updated":"2019-03-28T13:03:55.501Z","comments":true,"path":"2018/12/28/【性能优化】前端性能优化总结/","link":"","permalink":"www.conardli.top/2018/12/28/【性能优化】前端性能优化总结/","excerpt":"","text":"1.原则多使用内存，缓存或者其他方法 减少CPU计算，减少网络请求 减少IO操作（硬盘读写） 2.加载资源优化静态资源的合并和压缩。 静态资源缓存（浏览器缓存策略）。 使用CDN让静态资源加载更快。 3. 渲染优化CSS放head中，JS放body后 图片懒加载 减少DOM操作，对DOM操作做缓存 减少DOM操作，多个操作尽量合并在一起执行 事件节流 尽早执行操作 DOMContentLoaded 4. 示例4.1 资源合并a.js b.js c.js --- abc.js 4.2 缓存通过连接名称控制缓存 &lt;script src=\"abc_1.js\" &gt;&lt;/script&gt; 只有改变内容的时候，链接名称才会改变。 4.3 懒加载&lt;img src=\"preview.png\" realsrc=\"abc.png\" id=\"img1\" /&gt;&lt;script&gt; var i = document.getElementById('img1'); i.src = i.getAttribute('realsrc');&lt;/script&gt; 4.4 缓存dom查询//没有缓存domfor (let i = 0; i &lt; document.getElementsByTagName('p').length; i++) &#123;&#125;//缓存domvar p = document.getElementsByTagName('p');for (let i = 0; i &lt; p.length; i++) &#123;&#125; 4.5 合并dom插入var listNode = document.getElementById('list');var flag = document.createDocumentFragment();var li;for (let i = 0; i &lt; 10; i++) &#123; li = document.createElement('li'); li.innerHTML = i; flag.appendChild(li);&#125;listNode.appendChild(flag); 10次dom插入 —&gt; 1次dom插入 4.6 事件节流监听文字改变事件，无操作100毫秒后执行操作，不用每次触发。var textarea = document.getElementById('ta');var timeoutId;textarea.addEventListener('keyup',function()&#123; if(i)&#123; clearTimeout(i); &#125; timeoutId = setTimeout(() =&gt; &#123; //操作 &#125;, 100);&#125;); 事件节流主要用于触发频率较高的事件，设定一个缓冲触发事件。 补充异步加载非核心代码异步加载 – 异步加载的方式 – 区别 1.动态脚本加载 用js创建 2.defer 3.async &lt;script src=\"script.js\"&gt;&lt;/script&gt;没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。&lt;script async src=\"script.js\"&gt;&lt;/script&gt;有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。&lt;script defer src=\"myscript.js\"&gt;&lt;/script&gt;有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。 关于 defer，我们还要记住的是它是按照加载顺序执行脚本的 标记为async的脚本并不保证按照指定它们的先后顺序执行。对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，只要它加载完了就会立刻执行。 浏览器缓存总结的非常好 浏览器缓存 – 缓存的分类 – 缓存的原理 缓存就是html文件在本地存在的副本， 强缓存 发现有缓存直接用。 Expires: 绝对时间，判断客户端日期是否超过这个时间Cache-Control：相对时间，判断访问间隔是否大于3600秒//在设定时间之前不会和服务端进行通信了//如果两个都下发以后者为准 协商缓存 询问服务器缓存是否可以用，在进行判断是否用。 Last-Modified/If-Modified-Since 第一次请求，respone的header加上Last-Modified（最后修改时间）再次请求，在request的header上加上If-Modified-Since 和服务端的最后修改时间对比，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。浏览器收到304的响应后，就会从缓存中加载资源如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified的Header在重新加载的时候会被更新 Etag/If-None-Match 这两个值是由服务器生成的每个资源的唯一标识字符串，只要资源有变化就这个值就会改变；其判断过程与Last-Modified/If-Modified-Since类似，他可以精确到秒的更高级别。 DNS预解析&lt;meta http-equiv=\"x-dns-prefetch-control\" content=\"on\"&gt;&lt;link rel=\"dns-prefetch\" href=\"//www.zhix.net\"&gt; 在一些浏览器的a标签是默认打开dns预解析的，在https协议下dns预解析是关闭的，加入mate后会打开。","categories":[],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"www.conardli.top/tags/性能优化/"}]},{"title":"指令控制 windows 电源选项","slug":"【多端开发】指令控制-windows-电源选项","date":"2018-12-17T10:07:12.000Z","updated":"2019-05-18T04:37:52.701Z","comments":true,"path":"2018/12/17/【多端开发】指令控制-windows-电源选项/","link":"","permalink":"www.conardli.top/2018/12/17/【多端开发】指令控制-windows-电源选项/","excerpt":"","text":"1.powercfg命令。使用powercfg.exe控制电源计划（也称为电源使用方案）。 2.ac和dc一般电源有两种供电模式： ac代表交流电源 dc代表直流电源 一般情况下ac就是直接接通电源，dc是使用电池供电。 一般电源命令都需要分别设置在ac和dc下的模式。 3.电源选项的唯一标识每个电源选项都有一个唯一的guid标识，我们可以使用某些命令通过这个唯一标识来设定这个电源选项。 例如官方文档中的电源计划： 如图：电源计划 节电，平衡，高性能分别对应了一个guid。 我们可以通过查阅windows文档或者使用 powercfg /query 命令来查询每个选项对应的guid。 4.设置电源计划powercfg -setactive guid 可以通过-setactive来设置当前电源计划。 例如下面的代码将电源设置为平衡模式 powercfg -setactive 381b4222-f694-41f0-9685-ff5bb260df2e 5.修改电源计划中的电源选项直接查看控制面板中的电源选项可以看到下面的界面 我们可以通过下面的命令来修改powercfg -change value 后面的value有如下几个选项 monitor-timeout-ac &lt;分钟&gt;monitor-timeout-dc &lt;分钟&gt;disk-timeout-ac &lt;分钟&gt;disk-timeout-dc &lt;分钟&gt;standby-timeout-ac &lt;分钟&gt;standby-timeout-dc &lt;分钟&gt;hibernate-timeout-ac &lt;分钟&gt;hibernate-timeout-dc &lt;分钟&gt; monitor:屏幕disk:磁盘standby:待机hibernate:休眠 实例： powercfg /change monitor-timeout-ac 5 表示：在接通电源模式下设置屏幕5分钟后关闭。 powercfg /change monitor-hibernate-dc 0 表示：在不接通电源模式下永不休眠 6.高级选项还有一些其他选项，例如按下电源按钮，睡眠按钮，关闭盖子等发生的操作。 可以使用如下命令设置： powercfg /setacvalueindex scheme_GUID sub_GUID setting_GUID setting_indexpowercfg /setdcvalueindex scheme_GUID sub_GUID setting_GUID setting_index scheme_GUID : 电源计划guid，可以通过powercfg /list查询 sub_GUID：子组guid，可以解释成在众多的电源选项上又分的一层组，可以通过过powercfg /query查询 setting_GUID：选项guid，具体的电源选项。 setting_index：具体设置的索引，如下图： 不采取任何操作，睡眠，休眠，关机 例如： powercfg -SetAcValueIndex 381b4222-f694-41f0-9685-ff5bb260df2e 4f971e89-eebd-4455-a8de-9e59040e7347 5ca83367-6e45-459f-a27b-476b1d01c936 0 表示：设置接通电源的情况下，电源关盖后不采取任何操作。 powercfg -SetDcValueIndex 381b4222-f694-41f0-9685-ff5bb260df2e 4f971e89-eebd-4455-a8de-9e59040e7347 7648efa3-dd9c-4e3e-b566-50f929386280 1 表示：设置未接通电源的情况下，按下电源键使电脑进入睡眠。 7.总结有了这些操作，我们就可以使用某些语言比如node，来批处理windows电源选项了。 更详细的选项可以查询windows官方文档： https://docs.microsoft.com/en-us/windows-hardware/design/device-experiences/powercfg-command-line-options#option_getactivescheme","categories":[],"tags":[{"name":"electron","slug":"electron","permalink":"www.conardli.top/tags/electron/"}]},{"title":"react中key的正确使用方式","slug":"【React深入】react中key的正确使用方式","date":"2018-11-26T17:50:45.000Z","updated":"2019-04-16T11:42:43.649Z","comments":true,"path":"2018/11/27/【React深入】react中key的正确使用方式/","link":"","permalink":"www.conardli.top/2018/11/27/【React深入】react中key的正确使用方式/","excerpt":"","text":"在开发react程序时我们经常会遇到这样的警告，然后就会想到：哦！循环子组件忘记加key了～ 出于方便，有时候会不假思索的使用循环的索引作为key，但是这样真的好吗？什么样的值才是key的最佳选择？ 为了弄明白，本文将从三个方面来分析”key”： 1.为什么要使用key 2.使用index做key存在的问题 3.正确的选择key 1.为什么要使用keyreact官方文档是这样描述key的： Keys可以在DOM中的某些元素被增加或删除的时候帮助React识别哪些元素发生了变化。因此你应当给数组中的每一个元素赋予一个确定的标识。 react的diff算法是把key当成唯一id然后比对组件的value来确定是否需要更新的，所以如果没有key，react将不会知道该如何更新组件。 你不传key也能用是因为react检测到子组件没有key后，会默认将数组的索引作为key。 react根据key来决定是销毁重新创建组件还是更新组件，原则是： key相同，组件有所变化，react会只更新组件对应变化的属性。 key不同，组件会销毁之前的组件，将整个组件重新渲染。 2.使用index做key存在的问题2.1 受控组件单纯的展示组件比如span，这些组件是受控组件，意味着他们的值将是我们给定好的。 如果子组件只是受控组件，使用index作为key，可能表面上不会有什么问题，实际上性能会受很大的影响。例如下面的代码： // ['张三','李四','王五']=&gt;&lt;ul&gt; &lt;li key=\"0\"&gt;张三&lt;/li&gt; &lt;li key=\"1\"&gt;李四&lt;/li&gt; &lt;li key=\"2\"&gt;王五&lt;/li&gt;&lt;/ul&gt;// 数组重排 -&gt; ['王五','张三','李四'] =&gt;&lt;ul&gt; &lt;li key=\"0\"&gt;王五&lt;/li&gt; &lt;li key=\"1\"&gt;张三&lt;/li&gt; &lt;li key=\"2\"&gt;李四&lt;/li&gt;&lt;/ul&gt; 当元素数据源的顺序发生改变时，对应的： key为0，1，2的组件都发生了变化，三个子组件都会被重新渲染。（这里的重新渲染不是销毁，因为key还在） 相反，我们使用唯一id作为key： // ['张三','李四','王五']=&gt;&lt;ul&gt; &lt;li key=\"000\"&gt;张三&lt;/li&gt; &lt;li key=\"111\"&gt;李四&lt;/li&gt; &lt;li key=\"222\"&gt;王五&lt;/li&gt;&lt;/ul&gt;// 数组重排 -&gt; ['王五','张三','李四'] =&gt;&lt;ul&gt; &lt;li key=\"222\"&gt;王五&lt;/li&gt; &lt;li key=\"000\"&gt;张三&lt;/li&gt; &lt;li key=\"111\"&gt;李四&lt;/li&gt;&lt;/ul&gt; 根据上面的更新原则，子组件的值和key均未发生变化，只是顺序发生改变，因此react只是将他们做了移动，并未重新渲染。 2.2 非受控组件像input这样可以由用户任意改变值，不受我们控制的组件，在使用了index作为key时可能会发生问题，看如下的栗子： 子组件： render() &#123; return ( &lt;div&gt; &lt;p &gt;值：&#123;this.props.value&#125;&lt;/p&gt; &lt;input /&gt; &lt;/div&gt; ); &#125;&#125; 父组件&#123;this.state.data.map((element, index) =&gt; &#123; return &lt;Child value=&#123;element&#125; key=&#123;index&#125; /&gt; &#125;)&#125; 我们在前两个输入框分别输入对应的值： 然后在头部添加一个元素： 很明显，这个结果并不符合我们的预期，我们来分析一下发生了什么： &lt;div key=\"0\"&gt; &lt;p &gt;值：0&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=\"1\"&gt; &lt;p &gt;值：1&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=\"2\"&gt; &lt;p &gt;值：2&lt;/p&gt; &lt;input /&gt;&lt;/div&gt; 变化后： &lt;div key=\"0\"&gt; &lt;p &gt;值：5&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=\"1\"&gt; &lt;p &gt;值：0&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=\"2\"&gt; &lt;p &gt;值：1&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=\"3\"&gt; &lt;p &gt;值：2&lt;/p&gt; &lt;input /&gt;&lt;/div&gt; 可以发现：key 0，1，2并没有发生改变，根据规则，不会卸载组件，只会更新改变的属性。 react只diff到了p标签内值的变化，而input框中的值并未发生改变，因此不会重新渲染，只更新的p标签的值。 当使用唯一id作为key后： &lt;div key=\"000\"&gt; &lt;p &gt;值：0&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=\"111\"&gt; &lt;p &gt;值：1&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=\"222\"&gt; &lt;p &gt;值：2&lt;/p&gt; &lt;input /&gt;&lt;/div&gt; 变化后： &lt;div key=\"555\"&gt; &lt;p &gt;值：5&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=\"000\"&gt; &lt;p &gt;值：0&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=\"111\"&gt; &lt;p &gt;值：1&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=\"222\"&gt; &lt;p &gt;值：2&lt;/p&gt; &lt;input /&gt;&lt;/div&gt; 可以很明显的发现：key为 111，222，333的组件没有发生任何改变，react不会更新他们，只是新插入了子组件555，并改变了其他组件的位置。 3.正确的选择key3.1 纯展示如果组件单纯的用于展示，不会发生其他变更，那么使用index或者其他任何不相同的值作为key是没有任何问题的，因为不会发生diff，就不会用到key。 3.2 推荐使用index的情况并不是任何情况使用index作为key会有缺陷，比如如下情况： 你要分页渲染一个列表，每次点击翻页会重新渲染： 使用唯一id： 第一页&lt;ul&gt; &lt;li key=\"000\"&gt;张三&lt;/li&gt; &lt;li key=\"111\"&gt;李四&lt;/li&gt; &lt;li key=\"222\"&gt;王五&lt;/li&gt;&lt;/ul&gt;第二页&lt;ul&gt; &lt;li key=\"333\"&gt;张三三&lt;/li&gt; &lt;li key=\"444\"&gt;李四四&lt;/li&gt; &lt;li key=\"555\"&gt;王五五&lt;/li&gt;&lt;/ul&gt; 翻页后，三条记录的key和组件都发生了改变，因此三个子组件都会被卸载然后重新渲染。 使用index： 第一页&lt;ul&gt; &lt;li key=\"0\"&gt;张三&lt;/li&gt; &lt;li key=\"1\"&gt;李四&lt;/li&gt; &lt;li key=\"2\"&gt;王五&lt;/li&gt;&lt;/ul&gt;第二页&lt;ul&gt; &lt;li key=\"0\"&gt;张三三&lt;/li&gt; &lt;li key=\"1\"&gt;李四四&lt;/li&gt; &lt;li key=\"2\"&gt;王五五&lt;/li&gt;&lt;/ul&gt; 翻页后，key不变，子组件值发生改变，组件并不会被卸载，只发生更新。 3.3 子组件可能发生变更/使用了非受控组件大多数情况下，使用唯一id作为子组件的key是不会有任何问题的。 这个id一定要是唯一，并且稳定的，意思是这条记录对应的id一定是独一无二的，并且永远不会发生改变。 不推荐使用math.random或者其他的第三方库来生成唯一值作为key。 因为当数据变更后，相同的数据的key也有可能会发生变化，从而重新渲染，引起不必要的性能浪费。 如果数据源不满足我们这样的需求，我们可以在渲染之前为数据源手动添加唯一id，而不是在渲染时添加。","categories":[],"tags":[{"name":"React","slug":"React","permalink":"www.conardli.top/tags/React/"}]},{"title":"electron程序保护措施（崩溃监控，开机自启，托盘关闭）","slug":"【多端开发】electron程序保护措施（崩溃监控，开机自启，托盘关闭）","date":"2018-11-07T12:11:41.000Z","updated":"2019-05-30T06:43:37.277Z","comments":true,"path":"2018/11/07/【多端开发】electron程序保护措施（崩溃监控，开机自启，托盘关闭）/","link":"","permalink":"www.conardli.top/2018/11/07/【多端开发】electron程序保护措施（崩溃监控，开机自启，托盘关闭）/","excerpt":"","text":"在某种情况下，我们可能希望我们的客户端程序尽可能连续不断的运行在我们的系统中，并保持稳定。 以下几种方式可以帮助我们做到这一点： 1.崩溃监控electron为我们提供了监听程序崩溃的事件： Event: 'crashed'返回:event Eventkilled Boolean当渲染进程崩溃或被结束时触发 此事件是用来监听渲染进程崩溃的，但是当主进程意外崩溃时也会触发该事件。 在监测到程序崩溃后，我们要让程序重新启动，此时我们要首先判断window对象是否被销毁，也就是主进程是否被杀死，还是渲染进程崩溃，同时作出不同的处理。 当mainWin被销毁时我们直接重启整个应用，使用如下api： app.relaunch([options])options Object (可选)args StringexecPath String (可选)从当前实例退出，重启应用。默认情况下，新的实例会和当前实例使用相同的工作目录以及命令行参数。 当设置了 args 参数时， args 将作为命令行参数传递。 当设置了 execPath ，execPath 将被执行以重新启动，而不是当前的应用程序。请注意, 此方法在执行时不会退出当前的应用程序, 你需要在调用 app.relaunch 方法后再执行 app. quit 或者 app.exit 来让应用重启。 只是渲染进程崩溃，我们只需将其他窗体销毁，然后重新load我们的主窗口。 崩溃重启逻辑： if (mainWin.isDestroyed()) &#123; app.relaunch(); app.exit(0);&#125; else &#123; BrowserWindow.getAllWindows().forEach((w) =&gt; &#123; if (w.id !== mainWin.id) w.destroy(); &#125;); mainWin.reload();&#125; 当然，我们还要记录一下程序的崩溃日志，我们要确保日志接口发出成功后再重启我们的程序： 下面是程序崩溃后的完整逻辑： import &#123; BrowserWindow, app, dialog&#125; from 'electron'; const mainWindow = BrowserWindow.fromId(global.mainId);mainWindow.webContents.on('crashed', () =&gt; &#123; const options = &#123; type: 'error', title: '进程崩溃了', message: '这个进程已经崩溃.', buttons: ['重载', '退出'], &#125;; recordCrash().then(() =&gt; &#123; dialog.showMessageBox(options, (index) =&gt; &#123; if (index === 0) reloadWindow(mainWindow); else app.quit(); &#125;); &#125;).catch((e) =&gt; &#123; console.log('err', e); &#125;);&#125;)function recordCrash() &#123; return new Promise(resolve =&gt; &#123; // 崩溃日志请求成功.... resolve(); &#125;)&#125; function reloadWindow(mainWin) &#123; if (mainWin.isDestroyed()) &#123; app.relaunch(); app.exit(0); &#125; else &#123; BrowserWindow.getAllWindows().forEach((w) =&gt; &#123; if (w.id !== mainWin.id) w.destroy(); &#125;); mainWin.reload(); &#125;&#125; 写好代码之后，我们可以直接在控制台输入 process.crash()来进行测试，或者直接在任务管理器杀掉我们的进程进行测试。 2.开机自启开机自启是保证我们的程序能长时间在机器上运行很重要的一点。 电脑上有很多程序都设置了开机自启动，比如qq，微信，迅雷等，他们都是通过修改注册表来实现的，我们可以看一下注册表\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run: 所以我们也要将我们程序的路径写到这里。 发现了一个非常好的写注册表的模块，winreg注意mac不能使用这个模块，所以首先要判断是否为window再引用这个模块。 借助这个模块我们可以非常简单的修改注册表： const WinReg = require('winreg');const startOnBoot = &#123; enableAutoStart: function (name, file, callback) &#123; var key = getKey(); key.set(name, WinReg.REG_SZ, file, callback || noop); &#125;, disableAutoStart: function (name, callback) &#123; var key = getKey(); key.remove(name, callback || noop); &#125;, getAutoStartValue: function (name, callback) &#123; var key = getKey(); key.get(name, function (error, result) &#123; if (result) &#123; callback(result.value); &#125; else &#123; callback(null, error); &#125; &#125;); &#125;&#125;;function noop() &#123; &#125;const RUN_LOCATION = '\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run';function getKey() &#123; return new WinReg(&#123; hive: WinReg.HKCU, //CurrentUser, key: RUN_LOCATION &#125;);&#125;export default function autoStart() &#123; startOnBoot.getAutoStartValue('MY_CLIENT_AUTOSTART', function (value) &#123; if (!value) &#123; startOnBoot.enableAutoStart('MY_CLIENT_AUTOSTART', process.execPath, function () &#123; console.log('开机自动启设置'); &#125;); &#125; &#125;);&#125; 执行完程序之后，再看注册表，发现我们程序的路径已经写进去了： 然后电脑重启后你的程序就自动启动了。 3.托盘关闭向qq和微信一样，有的时候我们并不想让用户通过点关闭按钮的时候就关闭程序，而是把程序最小化到托盘，在托盘上做真正的退出操作。 首先要监听窗口的关闭事件，阻止用户关闭操作的默认行为。 mainWindow.on('close', (event) =&gt; &#123; mainWindow.hide(); event.preventDefault();&#125;); 然而这时你发现，这只是最小化了程序，任务栏里程序依然存在，我们需要让程序在任务栏里也消失： mainWindow.on('close', (event) =&gt; &#123; mainWindow.hide(); mainWindow.setSkipTaskbar(true); event.preventDefault();&#125;); 这时程序就再也找不到了，任务托盘中也没有我们的程序，所以我们要先创建好任务托盘，并做好事件监听 function createTray() &#123; const mainWindow = BrowserWindow.fromId(global.mainId); tray = new Tray(path.join(global.__dirname, 'icon.ico')); const contextMenu = Menu.buildFromTemplate([ &#123; label: '退出', click: () =&gt; &#123; mainWindow.destroy(); app.quit(); &#125; &#125;, ]) tray.setToolTip('我的客户端') tray.setContextMenu(contextMenu) tray.on('click', () =&gt; &#123; if (mainWindow.isVisible()) &#123; mainWindow.hide(); mainWindow.setSkipTaskbar(false); &#125; else &#123; mainWindow.show(); mainWindow.setSkipTaskbar(true); &#125; &#125;) &#125; 以上这些操作为我们的程序又增加了好几层的防护措施，我们的程序就不会那么轻而易举的挂掉啦！","categories":[],"tags":[{"name":"electron","slug":"electron","permalink":"www.conardli.top/tags/electron/"},{"name":"多端开发","slug":"多端开发","permalink":"www.conardli.top/tags/多端开发/"}]},{"title":"使用electron静默打印","slug":"【多端开发】使用electron静默打印","date":"2018-11-01T10:30:14.000Z","updated":"2019-06-10T12:46:20.434Z","comments":true,"path":"2018/11/01/【多端开发】使用electron静默打印/","link":"","permalink":"www.conardli.top/2018/11/01/【多端开发】使用electron静默打印/","excerpt":"","text":"1.使用electron打印的理由很多情况下程序中使用的打印都是用户无感知的。并且想要灵活的控制打印内容，往往需要借助打印机给我们提供的api再进行开发，这种开发方式非常繁琐，并且开发难度较大。 electron提供的打印api可以非常灵活的控制打印设置的显示，并且可以通过html来书写打印内容。 2.apielectron提供了两种方式进行打印，一种是直接调用打印机打印，一种是打印到pdf。 并且有两种对象可以调用打印： 第一是通过window的webcontent对象，使用此种方式需要单独开出一个打印的窗口，可以将该窗口隐藏，但是通信调用相对复杂。 另一种是使用页面的webview元素调用打印，可以将webview隐藏在调用的页面中，通信方式比较简单。 两个对象调用打印方法的使用方式都一样。 2.1 print官网api如下 contents.print([options], [callback])选项 Object (可选)silent Boolean (可选) - 不询问用户打印信息，默认为 false。printBackground Boolean (optional) - Also prints the background color and image of the web page. Default is false.deviceName String (optional) - Set the printer device name to use. Default is ''.callback Function (可选)success Boolean - Indicates success of the print call. 打印配置(options)中只有简单的三个配置： silent：打印时是否不展示打印配置（是否静默打印） printBackground：是否打印背景 deviceName：打印机设备名称 首先要将我们使用的打印机名称配置好，并且要在调用打印前首先要判断打印机是否可用。 使用getPrinters方法可获取当前设备已经配置的打印机列表，注意配置过不是可用，只是在此设备上安装过驱动。 通过getprinter获取到的打印机对象：https://electronjs.org/docs/api/structures/printer-info 我们这里只管关心两个，name和status，status为0时表示打印机可用。 这里的status必须经历一次打印失败才能返回非0值，也就是说第一次获取打印机状态一定是0。但是这一次的打印虽然不能判断出错误，打印的任务已经预存在队列中了，当下一次打印机状态变为可用时，将会打印暂存的任务。 当打印机纸张用完时也是这种情况，剩余任务会暂存起来，下次打印机可用时即可以打印了。 print的第二个参数callback是用于判断打印任务是否发出的回调，而不是打印任务完成后的回调。所以一般打印任务发出，回调函数即会调用并返回参数true。这个回调并不能判断打印是否真的成功了。 2.2 printToPdfcontents.printToPDF(options, callback)选项 ObjectmarginsType Integer (optional) - Specifies the type of margins to use. Uses 0 for default margin, 1 for no margin, and 2 for minimum margin.pageSize String (optional) - Specify page size of the generated PDF. Can be A3, A4, A5, Legal, Letter, Tabloid or an Object containing height and width in microns.printBackground Boolean (optional) - Whether to print CSS backgrounds.printSelectionOnly Boolean (optional) - Whether to print selection only.landscape Boolean (optional) - true for landscape, false for portrait.callback Function - 回调函数error Errordata Buffer printToPdf的用法基本和print相同，但是由于print是native code提供的方法，配置项非常少，而printToPdf则扩展了很多属性。 包括可以对打印的margin，打印页眉页脚等进行配置。 配置项很多，翻了一下源码发现还有很多没有被贴进api的： const defaultPrintingSetting = &#123; pageRage: [], mediaSize: &#123;&#125;, landscape: false, color: 2, headerFooterEnabled: false, marginsType: 0, isFirstRequest: false, requestID: getNextId(), previewModifiable: true, printToPDF: true, printWithCloudPrint: false, printWithPrivet: false, printWithExtension: false, deviceName: 'Save as PDF', generateDraftData: true, fitToPageEnabled: false, scaleFactor: 1, dpiHorizontal: 72, dpiVertical: 72, rasterizePDF: false, duplex: 0, copies: 1, collate: true, shouldPrintBackgrounds: false, shouldPrintSelectionOnly: false&#125; 3.打印边距问题打印的时候打印机会给纸张留一个默认边距，如果是A4这样的纸张几乎可以忽略不计了，但是打印小规格纸张如50mm*50mm，这个边距就十分明显了，严重影响了整体布局。 printToPdf方法提供了非常多的配置项，其中包括了配置打印边距的参数，但是print方法却没有该配置项。 我们可以通过一项css配置来解决这个问题,即@page: @page &#123; margin: 0px;&#125; 通过此配置可灵活配置打印边距。 还有一个css属性@media print {} 此配置是只有在打印时才生效的css，控制的是打印边距以内的css，并不能控制打印边距。 4.打印方案使用webcontent打印，首先要有一个打印窗口，这个窗口不能随时打印随时创建，比较耗费性能。可以将它在程序运行时启动好，并做好事件监听。 此过程需和调用打印的进行做好通信：大致过程如下： 可见通信非常繁琐 使用webview进行打印可实现同样的效果但是通信方式会变得简单，因为渲染进程和webview通信不需要经过主进程，通过如下方式即可： // In embedder page. const webview = document.querySelector('webview') webview.addEventListener('ipc-message', (event) =&gt; &#123; console.log(event.channel) // Prints \"pong\" &#125;) webview.send('ping')Copy // 在访客页。 const &#123;ipcRenderer&#125; = require('electron') ipcRenderer.on('ping', () =&gt; &#123; ipcRenderer.sendToHost('pong') &#125;) 5.示例程序示例demo：https://github.com/ConardLi/electron-print-demo","categories":[],"tags":[{"name":"electron","slug":"electron","permalink":"www.conardli.top/tags/electron/"},{"name":"多端开发","slug":"多端开发","permalink":"www.conardli.top/tags/多端开发/"}]},{"title":"个人博客搭建及配置","slug":"【博客搭建】个人博客搭建及配置","date":"2018-01-01T12:13:20.000Z","updated":"2019-04-18T14:30:44.226Z","comments":true,"path":"2018/01/01/【博客搭建】个人博客搭建及配置/","link":"","permalink":"www.conardli.top/2018/01/01/【博客搭建】个人博客搭建及配置/","excerpt":"","text":"一、基础配置 1.1.本地安装hexo首先保证你电脑上有node环境，这个不懂的可以自定百度。 控制台输入node -v出现版本号说明安装成功。 有了node就可以安装hexo了，控制台输入如下命令 npm i -g hexo 同样控制台输入hexo -v出现版本号说明安装成功。 然后开始初始化项目，控制台输入： hexo init 得到如下项目目录： node_modules：是依赖包public：存放的是生成的页面scaffolds：命令生成文章等的模板source：用命令创建的各种文章themes：主题_config.yml：整个博客的配置db.json：source解析所得到的package.json：项目所需模块项目的配置信息 1.2.本地运行首先在本地跑起来你的代码 控制台安装hexo-server npm i hexo-server 然后运行 hexo-server 在浏览器中访问：http://localhost:4000就可以看到你本定运行的页面了 这时你可以在本地调试一下你的blog。 1.3.github配置首先要创建一个github账号 并配置好ssh 这些不懂的可以自行百度。 创建一个repo，名称为yourname.github.io, 其中yourname是你的github名称，按照这个规则创建github page才会生效。 修改_config.yml中的git配置 deploy: type: git repo: https://github.com/xxxx.git branch: master 1.4.部署上传在本地安装上传工具 npm install hexo-deployer-git --save 依次执行如下命令 hexo clean //删除上次打包hexo generate //打包hexo deploy /上传 这里我单独写了sh执行这三段脚本，这样每次只需要执行这个sh即可。 在浏览器中输入http://yourgithubname.github.io就可以看到你的个人博客了！ 1.5一些其他配置搜索功能使用搜索功能首先需要： npm install -S hexo-generator-json-content 然后： search: insight: true readme1.首先在source文件夹下建立一个README.md 2.修改_config.yml skip_render: README.md 二、绑定二人域名2.1购买一个域名这里我选择的是阿里云，挑选一个自己喜欢的域名购买。 2.2域名解析进入控制台添加域名解析。 按照如下规则添加两条记录。 这时去访问解析好的域名会出现如下页面。 这说明域名解析没有问题，接下来进入github进行配置 2.3 hexo配置在本地的博客目录中找到source文件夹。 新建一个没有后缀名的文件GNAME 在文件中添加你的域名，如： lisq.xyz 保存后重新生成，并提交你的博客。 2.4 github配置在github中找到你的博客仓库。 点击找到```Custom domain 输入你的域名点击save 然后你就可以在浏览器用你的域名愉快的访问啦！ 三、同时托管到github和coding上github page毕竟是国外站点，访问速度相对来说比较慢，但是同时你又想在gihub上保存一下代码，可以尝试同时托管两个仓库。 做解析的时候海外的ip 指向到github，国内的或者说百度的直接指向coding。 3.1.在coding上提交代码首先做的操作和github是一样的，就是创建一个ssh。 这里要注意的是，你的电脑上已经有了gihub的ssh，如果还像github一样一路回车会把gihub的ssh给覆盖掉。 所以这里在执行 $ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 时要注意，给生成的文件配置一个新路径： 然后配置生成的ssh 在coding中创建一个仓库，这里注意仓库的名字可以随意取，不像gihub一样可以随意给定。 将创建仓库的git地址添加到_config.yml中： deploy:js type: git repo: github: https://github.com/ConardLi/ConardLi.github.io.git coding: https://git.dev.tencent.com/ConardLi/lisqBlog.git branch: master 然后重新部署并上传博客，去仓库查看代码证明上传成功： 3.2.开启coding page点击coding的pages服务，直接点击一键开启即可。 开启后即可通过给定域名直接访问了： http://conardli.coding.me/ 3.3.域名解析将新生成的coding域名进行解析，这样国内就默认访问coding的页面，比github要快不少。 另外还可以将github的ip进行国外站点配置。 在coding page中将自己的域名进行绑定。 配置完成后发现速度快了不少，有木有… 四、站长统计 使用一个站长统计工具，可以为博客添加一个如上面似的详细的访问报表。 站长统计工具有很多，每个工具大同小异，这里我选择了CNZZ。 4.1.CNZZ配置1.注册一个账号。 2.添加网站。 按照如下要求添加网站 3.选择统计代码 添加完网站后就可以选择一段代码插入你的博客里了，CNZZ提供了几种样式，你可以选择展示真实的统计数量，一个cnzz图标或者什么都不显示。 4.2.代码配置将上面复制的代码插入到你主题代码的公共区域中。 每个主题的代码都不一样，但是大体结构是相同的，都会将通用的组件抽取出来。 这里我找到了每个页面都使用的footer组件，我使用的是hueman主题，代码在themes/hueman/common/footer.ejs 在此文件中找到合适的位置插入你的统计代码。 比如我的（script内的部分）： 五、阅读统计这里的统计是用来展示在页面上的，可以标示文章以及博客的热度。 使用不蒜子来展示文章访问统计和页面访问统计。 5.1.引入不蒜子将不蒜子js文件引入博客主题公共组件中。 &lt;script async src=\"//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt; 这里我同站长统计一样放在themes/hueman/common/footer.ejs 5.2.文章访问统计要显示每篇文章的访问量，复制以下代码添加到你需要显示的位置。 可以在标签上自定义一些样式。 算法：pv的方式，单个用户点击1篇文章，本篇文章记录1次阅读量。 &lt;span id=\"busuanzi_container_page_pv\"&gt; 本文总阅读量&lt;span id=\"busuanzi_value_page_pv\"&gt;&lt;/span&gt;次&lt;/span&gt; 5.3.整站访问统计算法a：pv的方式，单个用户连续点击n篇文章，记录n次访问量。 &lt;span id=\"busuanzi_container_site_pv\"&gt; 本站总访问量&lt;span id=\"busuanzi_value_site_pv\"&gt;&lt;/span&gt;次&lt;/span&gt; 算法b：uv的方式，单个用户连续点击n篇文章，只记录1次访客数。&lt;span id=\"busuanzi_container_site_uv\"&gt; 本站访客数&lt;span id=\"busuanzi_value_site_uv\"&gt;&lt;/span&gt;人次&lt;/span&gt; 六、评论系统博客使用valine作为评论工具，原因是他使用简介，体积轻量，灵活配置，速度很快！ 6.1 注册LeanCloudvaline接住了LeanCloud的力量，所以需要LeanCloud的APP ID 和 APP Key 首先注册和登录LeanCloud 创建一个应用： 应用创建好以后，进入刚刚创建的应用，选择左下角的设置&gt;应用Key，然后就能看到你的APP ID和APP Key了： 6.2 代码将如下代码插入你的文章模板中 &lt;head&gt; ... &lt;script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"&gt;&lt;/script&gt; &lt;script src='//unpkg.com/valine/dist/Valine.min.js'&gt;&lt;/script&gt; ...&lt;/head&gt;&lt;body&gt; ... &lt;div id=\"vcomments\"&gt;&lt;/div&gt; &lt;script&gt; new Valine(&#123; el: '#vcomments', appId: '&lt;API_ID&gt;', appKey: '&lt;API_Key&gt;' &#125;) &lt;/script&gt;&lt;/body&gt; 配置好这些，等待两分钟，就可以在文章里使用你的评论啦。 6.3 数据管理由于Valine 是无后端评论系统，所以也就没有开发评论数据管理功能。 可以在leanCloud中管理评论 登录&gt;选择你创建的应用&gt;存储&gt;选择Class Comment 6.4 安全域名为了数据安全，在leanCloud中配置你的安全域名 6.5 配置项Valine还有一些其他的配置项 new Valine(&#123; el: '#vcomments' , appId: '&lt;APP_ID&gt;', appKey: '&lt;APP_KEY&gt;', notify:false, verify:false, avatar:'mm', placeholder: 'just go go' &#125;); placeholder类型:String默认值:Just go go必要性:false评论框占位提示符。notify类型:Boolean默认值:false必要性:false评论回复邮件提醒，请参考配置。verify类型:Boolean默认值:false必要性:false验证码服务。path类型:String默认值:window.location.pathname必要性:false当前文章页路径，用于区分不同的文章页，以保证正确读取该文章页下的评论列表。可选值：window.location.pathname (默认值，推荐)window.location.href自定义I. 请保证每个文章页路径的唯一性，否则可能会出现不同文章页下加载相同评论列表的情况。II. 如果值为window.location.href，可能会出现随便加不同参数进入该页面，而被判断成新页面的情况。avatar类型:String默认值:mm必要性:falseGravatar 头像展示方式。可选值：''(空字符串)mpidenticonmonsteridwavatarretrorobohashhide更多信息，请查看头像配置。meta类型:Array默认值:['nick','mail','link']必要性:false评论者相关属性。pageSize类型:Number默认值:10必要性:false评论列表分页，每页条数。lang类型:String默认值:zh-cn必要性:false多语言支持。可选值：zh-cnen如需自定义语言，请参考i18n。visitor类型:Boolean默认值:false必要性:false文章访问量统计。highlight类型：Boolean默认值: true必要性: false代码高亮，默认开启，若不需要，请手动关闭avatarForce类型: Boolean默认值: false必要性: false 七、SEO优化SEO是由英文Search Engine Optimization缩写而来， 中文意译为“搜索引擎优化”。SEO是指通过站内优化比如网站结构调整、网站内容建设、网站代码优化等以及站外优化。 简而言之，就是让人们更容易搜索到你的站点。 首先要做的就是让搜索引擎收录我们的站点。 7.1.百度7.1.1 提交网址在搜索引擎中输入site:&lt;域名&gt;,如果如下图所示就是说明我们的网站并没有被百度收录。我们可以直接点击下面的“网址提交”来提交我们的网站 然后点击途中的提交网址 选择站点的相关属性： 接下来进行网站验证，推荐使用第三种GNAME验证，简单快捷，只需要给你的链接增加一条解析即可: 7.1.2 生成网站地图接下来要让你的网站生成网站地图，及生产sitemap，将sitemap提交到百度，先安装地图生成插件： npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 注意根目录的_config.yml将url配置成你的站点# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://lisq.xyz/root: / 重新部署博客后就会生成两个新文件sitemap.xml和baidusitemap.xml 7.1.3 将sitemap提交给百度点击链接提交 使用主动推送 主动推送安装插件npm install hexo-baidu-url-submit –save然后再根目录的配置文件中新增字段baidu_url_submit: count: 100 host: https://lisq.xyz/ token: 8OGYpxowYnhgVsUM path: baidu_urls.txt # 文本文档的地址 在加入新的deployedeploy: - type:baidu_url_submitter 百度收录的时间非常长，耐心等待吧。 7.2.谷歌点击这里添加你的网址 点击添加属性后即可添加你的博客地址。 进行验证： 谷歌收录的速度还是相当快的，而且操作比较简单。 八、文章目录hueman模版是不带文章目录的，所以需要手动给给文章增加导航功能。 hexo为我们提供了toc插件 toc：解析内容中的标题标签(h1~h6)并插入目录。 &lt;%- toc(str, [options]) %&gt; 参数 描述 默认值class Class 名称 toclist_number 显示编号 true 在layoit目录下新建文件toc.ejs 这里，我们可以为目录自定义一些样式： &lt;aside id=\"article-toc\" role=\"navigation\" class=\"fixed\"&gt; &lt;div id=\"article-toc-inner\"&gt; &lt;strong class=\"sidebar-title\"&gt; 目录&lt;/strong&gt; &lt;%- toc(post.content, &#123;list_number: false&#125;) %&gt; &lt;/div&gt;&lt;/aside&gt; 在common/article.ejs下将其插入： &lt;%- partial('toc') %&gt; 这里感觉整体的布局没地方放个目录了，所以就弄了个打开目录的按钮放在侧边栏。 九、部署到虚拟主机github page的速度实在欠佳，coding的page服务还不太稳定，所以我决定将博客迁移到虚拟主机上。 个人博客一般没什么太大的流量，作为新手入门来讲，去阿里云上选一个最便宜的即可。 由于hexo最终生成的文件完全是静态页面，我们不需要数据库，这时候我们要做的只是把文件通过ftp扔到虚拟主机上即可。 购买完虚拟主机后，会为我们提供FTP登录主机地址、FTP登录用户名、FTP登录密码，你可以手动下载一个ftp上传工具比如FileZilla手动完成文件上传，当然hexo为我们提供了更方便的方式，我们需要安装一个插件： npm install hexo-deployer-ftpsync --save deploy: type: ftpsync host: xxx //FTP登录主机地址 user: xxx //FTP登录用户名 pass: xxx //FTP登录密码 remote: /htdocs //指定文件放置的目录（一般虚拟主机默认就是这个） port: ignore: .DS_Store connections: verbose: true 配置完成后重新进行构建： hexo clean //删除上次打包hexo generate //打包hexo deploy /上传 最后，将虚拟主机的默认访问页指向我们博客的默认页面index.html，就可以愉快的访问了～ 注意，将我们的个人域名解析到虚拟主机上是需要进行备案的。","categories":[],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"www.conardli.top/tags/博客搭建/"}]}]}