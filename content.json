{"meta":{"title":"李世奇的技术专栏","subtitle":null,"description":"Fe Coder","author":"ConardLi","url":"http://lisq.xyz"},"pages":[],"posts":[{"title":"vue问题记录","slug":"vue问题记录","date":"2017-12-24T05:26:55.000Z","updated":"2018-10-28T14:32:32.076Z","comments":true,"path":"2017/12/24/vue问题记录/","link":"","permalink":"http://lisq.xyz/2017/12/24/vue问题记录/","excerpt":"","text":"vue生命周期https://segmentfault.com/a/1190000008010666 v-show和v-if指令的共同点和不同点?v-show指令是通过修改元素的displayCSS属性让其显示或者隐藏 v-if指令是直接销毁和重建DOM达到让元素显示和隐藏的效果 如何让CSS只在当前组件中起作用?将当前组件的修改为 的作用是什么?大白话: 比如有一个列表和一个详情，那么用户就会经常执行打开详情=&gt;返回列表=&gt;打开详情…这样的话列表和详情都是一个频率很高的页面，那么就可以对列表组件使用进行缓存，这样用户每次返回列表的时候，都能从缓存中快速渲染，而不是重新渲染 vue中使用组件1.采用ES6的import … from …语法或CommonJS的require()方法引入组件 2.对组件进行注册,代码如下1234// 注册Vue.component('my-component', &#123; template: '&lt;div&gt;A custom component!&lt;/div&gt;'&#125;) 3.使用组件 使用插件采用ES6的import … from …语法或CommonJSd的require()方法引入插件 使用全局方法Vue.use( plugin )使用插件,可以传入一个选项对象Vue.use(MyPlugin, { someOption: true }) 如使用vue-router，vue-resource插件 组件通信父组件向子组件先定义一个子组件，在组件中注册props 12345678910111213&lt;template&gt; &lt;div&gt; &lt;div&gt;&#123;&#123;message&#125;&#125;(子组件)&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; message: String //定义传值的类型&lt;br&gt; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 在父组件中，引入子组件，并传入子组件内需要的值 1234567891011121314151617181920212223&lt;template&gt; &lt;div&gt; &lt;div&gt;父组件&lt;/div&gt; &lt;child :message=\"parentMsg\"&gt;&lt;/child&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt; import child from './child' //引入child组件export default &#123; data() &#123; return &#123; parentMsg: 'a message from parent' //在data中定义需要传入的值 &#125; &#125;, components: &#123; child &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 子组件向父组件12345678910子组件:&lt;template&gt; &lt;div @click=\"up\"&gt;&lt;/div&gt;&lt;/template&gt;methods: &#123; up() &#123; this.$emit('upup','hehe'); //主动触发upup方法，'hehe'为向父组件传递的数据 &#125;&#125; 12345678&lt;div&gt; &lt;child @upup=\"change\" :msg=\"msg\"&gt;&lt;/child&gt; //监听子组件触发的upup事件,然后调用change方法&lt;/div&gt;methods: &#123; change(msg) &#123; this.msg = msg; &#125;&#125; 兄弟组件通信组件1触发：123456&lt;div @click=\"eve\"&gt;&lt;/div&gt;methods: &#123; eve() &#123; Hub.$emit('change','hehe'); //Hub触发事件 &#125;&#125; 组件2接收:123456&lt;div&gt;&lt;/div&gt;created() &#123; Hub.$on('change', () =&gt; &#123; //Hub接收事件 this.msg = 'hehe'; &#125;);&#125; 这样就实现了非父子组件之间的通信了.原理就是把Hub当作一个中转站！ computed 和 watch12345678910111213141516 new Vue(&#123; el: '#myDiv', data: &#123; firstName: 'Foo', lastName: 'Bar', fullName: 'Foo Bar' &#125;, watch: &#123; firstName: function (val) &#123; this.fullName = val + ' ' + this.lastName &#125;, lastName: function (val) &#123; this.fullName = this.firstName + ' ' + val &#125; &#125;&#125;) 12345678910111213new Vue(&#123; el:\"#myDiv\", data:&#123; firstName:\"Den\", lastName:\"wang\", &#125;, computed:&#123; fullName:function()&#123; return this.firstName + \" \" +this.lastName; &#125; &#125; &#125;) 12345678910111213computed:&#123; fullName:&#123; //这里用了es6书写方法 set()&#123; alert(\"set\"); &#125;, get()&#123; alert(\"get\"); return this.firstName + \" \" +this.lastName; &#125;, &#125; &#125; 1.从属性名上，computed是计算属性，也就是依赖其它的属性计算所得出最后的值。watch是去监听一个值的变化，然后执行相对应的函数。 2.从实现上，computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时才会重新调用对应的getter来计算。watch在每次监听的值变化时，都会执行回调。其实从这一点来看，都是在依赖的值变化之后，去执行回调。很多功能本来就很多属性都可以用，只不过有更适合的。如果一个值依赖多个属性（多对一），用computed肯定是更加方便的。如果一个值变化后会引起一系列操作，或者一个值变化会引起一系列值的变化（一对多），用watch更加方便一些。 3.watch的回调里面会传入监听属性的新旧值，通过这两个值可以做一些特定的操作。computed通常就是简单的计算。 4.watch和computed并没有哪个更底层，watch内部调用的是vm.$watch，它们的共同之处就是每个定义的属性都单独建立了一个Watcher对象。","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://lisq.xyz/tags/vue/"}]},{"title":"vue双向绑定浅析","slug":"vue双向绑定浅析","date":"2017-12-02T13:53:09.000Z","updated":"2018-10-28T14:26:22.821Z","comments":true,"path":"2017/12/02/vue双向绑定浅析/","link":"","permalink":"http://lisq.xyz/2017/12/02/vue双向绑定浅析/","excerpt":"","text":"原理数据劫持: vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 实现流程1、实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者 2、实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数 3、实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图 4、mvvm入口函数，整合以上三者 实现Observer可以利用Obeject.defineProperty()来监听属性变动那么将需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。。相关代码可以是这样： 12345678910111213141516171819202122232425262728var data = &#123;name: 'kindeng'&#125;;observe(data);data.name = 'dmq'; // 哈哈哈，监听到值变化了 kindeng --&gt; dmqfunction observe(data) &#123; if (!data || typeof data !== 'object') &#123; return; &#125; // 取出所有属性遍历 Object.keys(data).forEach(function(key) &#123; defineReactive(data, key, data[key]); &#125;);&#125;;function defineReactive(data, key, val) &#123; observe(val); // 监听子属性 Object.defineProperty(data, key, &#123; enumerable: true, // 可枚举 configurable: false, // 不能再define get: function() &#123; return val; &#125;, set: function(newVal) &#123; console.log('哈哈哈，监听到值变化了 ', val, ' --&gt; ', newVal); val = newVal; &#125; &#125;);&#125; depdep的作用是消息订阅器，很简单，维护一个数组，用来收集订阅者，数据变动触发notify，再调用订阅者的update方法 compliecompile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图 因为遍历解析的过程有多次操作dom节点，为提高性能和效率，会先将跟节点el转换成文档碎片fragment进行解析编译操作，解析完成，再将fragment添加回原来的真实dom节点中。 12345678910111213141516171819function Compile(el) &#123; this.$el = this.isElementNode(el) ? el : document.querySelector(el); if (this.$el) &#123; this.$fragment = this.node2Fragment(this.$el); this.init(); this.$el.appendChild(this.$fragment); &#125;&#125;Compile.prototype = &#123; init: function() &#123; this.compileElement(this.$fragment); &#125;, node2Fragment: function(el) &#123; var fragment = document.createDocumentFragment(), child; // 将原生节点拷贝到fragment while (child = el.firstChild) &#123; fragment.appendChild(child); &#125; return fragment; &#125;&#125;; compileElement方法将遍历所有节点及其子节点，进行扫描解析编译，调用对应的指令渲染函数进行数据渲染，并调用对应的指令更新函数进行绑定。遍历后将自己每一个元素作为一个订阅者添加到dep的数组中。 在compileElement中做监听，值改变了再去改变MVVM的值。 watcher1、在自身实例化时往属性订阅器(dep)里面添加自己 2、自身必须有一个update()方法 3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调 主要作用是将元素封装成一个订阅对象，内含有updae函数，从而把自身加入到订阅器列表中作为订阅者。","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://lisq.xyz/tags/vue/"},{"name":"双向绑定","slug":"双向绑定","permalink":"http://lisq.xyz/tags/双向绑定/"},{"name":"数据流","slug":"数据流","permalink":"http://lisq.xyz/tags/数据流/"}]},{"title":"前端常见算法","slug":"前端常见算法","date":"2017-11-09T05:44:18.000Z","updated":"2018-10-28T14:28:26.377Z","comments":true,"path":"2017/11/09/前端常见算法/","link":"","permalink":"http://lisq.xyz/2017/11/09/前端常见算法/","excerpt":"","text":"判断回文123function checkPalindrom(str) &#123; return str == str.split('').reverse().join('');&#125; 去掉一组整型数组重复的值123比如输入: [1,13,24,11,11,14,1,2] 输出: [1,13,24,11,14,2]需要去掉重复的11 和 1 这两个元素。 方法1：使用object 考察个人对Object的使用，利用key来进行筛选。 1234567891011function unique(arr)&#123; var hasTable = &#123;&#125;; var result = []; for (let i = 0; i &lt; arr.length; i++) &#123; if(!hasTable[arr[i]])&#123; result.push(arr[i]); hasTable[arr[i]] = true; &#125; &#125; return result;&#125; 方法2：使用indexOf(IE8以下不支持)1234567function unique1(array) &#123; var n = []; for (var i = 0; i &lt; array.length; i++) &#123; if (n.indexOf(array[i]) == -1) n.push(array[i]); &#125; return n;&#125; 方法3：利用filter方法 判断数据元素是不是第一次出现 123var r = arr.filter(function (element, index, self) &#123; return self.indexOf(element) === index;&#125;); 统计一个字符串出现最多的字母123输入 ： afjghdfraaaasdenas 输出 ： a 1234567891011121314151617181920212223function findMaxChar(str) &#123; var arr = str.split(''); var countObj = &#123;&#125;; for (let i = 0; i &lt; arr.length; i++) &#123; const element = arr[i]; if (countObj[element]) &#123; countObj[element]++; &#125; else &#123; countObj[element] = 1; &#125; &#125; let maxNum = 0, maxValue = ''; for (const key in countObj) &#123; if (countObj.hasOwnProperty(key)) &#123; const element = countObj[key]; if(element&gt;maxNum)&#123; maxNum = element; maxValue = key; &#125; &#125; &#125; return maxValue;&#125; 获取数组中的最大差12Math.max()Math.min() 最快捷的数组求最大值12var arr = [ 1,5,1,7,5,9]; Math.max(...arr) // 9 随机生成指定长度的字符串123Math.floor() 向下取整Math.round() 四舍五入Math.Ceil() 向上取整 123456789function randomString(n)&#123; var base = 'abcdefghijklmnopqrstuvwxyz0123456789'; var l = base.length; var m =''; for (let i = 0; i &lt; n; i++) &#123; m = m + base.charAt(Math.floor(Math.random()*l)); &#125; return m;&#125; 寻找第k大的数使用快速排序思想 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function getk(arr, left, right, k) &#123; var temp = arr[left];//基准数 var i = left;//副本可改变 var j = right;//副本可改变 var t;//临时交换值 if (i &gt;= j) &#123; return arr[i]; &#125; while (i != j) &#123; //从右侧找基准数大的放左边 while (arr[j] &lt;= temp &amp;&amp; i &lt; j) &#123; j--; &#125; //从左侧找基准数小的放右边 while (arr[i] &gt;= temp &amp;&amp; i &lt; j) &#123; i++; &#125; //交换i和j if (i != j) &#123; t = arr[i]; arr[i] = arr[j]; arr[j] = t; &#125; &#125; if (i == k) &#123; return temp; &#125; arr[left] = arr[i]; arr[i] = temp; if (k &lt; i) &#123; return getk(arr, left, i - 1, k); &#125; else if (k &gt; i) &#123; return getk(arr, i + 1, right, k); &#125;&#125;var arr = [1, 4, 2, 4, 5, 6, 3, 2, 1, 4, 22];console.log(getk(arr, 0, arr.length - 1, 5));//注意这里的k参数为下标值 数组乱序12345678var a = [1, 2, 3, 4, 5, 6, 7, 8, 9];var random = function(array) &#123; return array.sort(function()&#123;return Math.random() &gt; 0.5&#125;);&#125;;console.log(random(a)); 如果要某一定值不变就先将其用splice取出来，乱序完成在加进去。","categories":[],"tags":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://lisq.xyz/tags/算法和数据结构/"}]},{"title":"排序总结","slug":"排序总结","date":"2017-11-05T13:21:04.000Z","updated":"2018-10-28T14:29:27.902Z","comments":true,"path":"2017/11/05/排序总结/","link":"","permalink":"http://lisq.xyz/2017/11/05/排序总结/","excerpt":"","text":"冒泡排序基本思路： 从第一个数开始，和右侧的数比较，如果右侧比左侧小，交换左右位置。 这样第一轮比较后，最大的数排到最后。 第二轮比较，不用比较最后一个数。 优化算法 直接使用普通的冒泡排序，无论排序是否完成，都会执行数组的总个数次，实际情况下排序成功所需次数可能非常少。 所以优化思路就是在已经完成排序后跳出循环。 12345678910111213141516171819function bubling(arr) &#123; var isComplete; var temp; for (let i = 0; i &lt; arr.length - 1; i++) &#123; isComplete = true; for (let j = 0; j &lt; arr.length - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; a = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = a; isComplete = false; &#125; &#125; if (isComplete) &#123; break; &#125; &#125; return arr;&#125; 测试排序10000个数花费1113毫秒 插入排序思路对于给定的一组记录，初始时假设第一个记录自成一个有序序列，其余记录为无序序列。 从第二个记录开始，按照记录的大小依次将当期处理的记录插入到其之前的有序序列中，直至最后一个记录插入到有序序列为止。 思路： 取出第二个数，将它插入到由开头1个数组成的有序序列中。 取出第三个数，插入到开头2个数组成的有序序列中。 取出第n个数，插入到开头n-1个数组成的有序序列中。 直到n为最后一个数。 关键找到插入的节点m 让arr[m] - arr[i-1] 整体后移一位 1234567891011121314151617181920212223function insert(arr) &#123; //最大插入次数 n-1次 var temp; for (let i = 1; i &lt; arr.length; i++) &#123; var m = -1; for (let j = 0; j &lt; i; j++) &#123; if(arr[i]&lt;arr[j])&#123; m = j; break; &#125; &#125; if(m != -1)&#123; //将arr[i] 插入 arr[m] //即将arr[m] - arr[i-1]整体后移一位 temp = arr[i]; for (let j = i; j &gt; m; j--) &#123; arr[j] = arr[j-1]; &#125; arr[m] = temp; &#125; &#125; return arr;&#125; 一万个数花费700毫秒 上述实现可以改进： 不去先找m的位置，而是直接进行插入。 让i和有序序列从右到左开始比较，如果比较的值比i大，交换两个数的位置。 1234567891011121314function insert(arr) &#123; //最大插入次数 n-1次 var temp,j; for (let i = 1; i &lt; arr.length; i++) &#123; temp = arr[i]; j = i - 1; while( j&gt;=0 &amp;&amp; temp &lt; arr[j] )&#123; arr[j+1] = arr[j]; j--; &#125; arr[j+1] = temp; &#125; return arr;&#125; 快速排序思路 找出一个基准数 从右侧找比基准数小的 从左侧找比基准数大的 交换值直到没有可以交换的。 将基准数复位 将基准数左侧的数进行快排 将基准数右侧的数进行快排 关键退出快排的条件：left == right 先找基准数小的数 大于等于和小于等于（避免找到相同的数） 123456789101112131415161718192021222324252627282930313233343536function quick(arr,left,right) &#123; var temp = arr[left];//基准数 var i = left;//副本可改变 var j = right;//副本可改变 var t;//临时交换值 if(i&gt;=j)&#123; return; &#125; while(i!=j)&#123; //找到比基准数小的数 （如果没有比基准数小的数，那么i=j=left 不用做交换） while(arr[j]&gt;=temp &amp;&amp; i&lt;j )&#123; j--; &#125; //找到比基准数大的数 while (arr[i]&lt;=temp &amp;&amp; i&lt;j) &#123; i++; &#125; //交换i和j if(i!=j)&#123; t = arr[i]; arr[i] = arr[j]; arr[j] = t; &#125; &#125; arr[left] = arr[i]; arr[i] = temp; quick(arr,left,i-1); quick(arr,i+1,right);&#125; 一万个数花费7毫秒 优化版比temp小的数放在左数组里，比temp大的数放在右数组里，左数组+右数组+temp就是排序好的数。 12345678910111213141516function quick(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; let left = []; let right = []; let temp = arr[0]; for (let i = 1, l = arr.length; i &lt; l; i++) &#123; if (arr[i] &gt; temp) &#123; right.push(arr[i]); &#125; else &#123; left.push(arr[i]); &#125; &#125; return [].concat(quick(left), [temp], quick(right));&#125; 选择排序将每个数与开头数作比较，比它小则交换位置。重复比较n-1轮 12345678910111213function select(arr) &#123; var temp; for (let i = 0; i &lt; arr.length - 1; i++) &#123; for (let j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[i]) &#123; temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125; 希尔排序把记录按步长 gap 分组，对每组记录采用直接插入排序方法进行排序。随着步长逐渐减小，所分成的组包含的记录越来越多，当步长的值减小到 1 时，整个数据合成为一组，构成一组有序记录，则完成排序。 例子：9 1 2 5 7 4 8 6 3 5 gap是步长，也就是两个数之间的间隔。 gap=length/2 gap=gap/2 跳出循环的条件为gap&gt;0 插入排序 1234567891011121314function insert(arr) &#123; //最大插入次数 n-1次 var temp,j; for (let i = 1; i &lt; arr.length; i++) &#123; temp = arr[i]; j = i - 1; while( j&gt;=0 &amp;&amp; temp &lt; arr[j] )&#123; arr[j+1] = arr[j]; j--; &#125; arr[j+1] = temp; &#125; return arr; &#125; 给定增量值 123456789101112function shellSort(arr, gap) &#123; var temp, j; for (let i = gap; i &lt; arr.length; i++) &#123; temp = arr[i]; j = i - gap; while (j &gt; 0 &amp;&amp; temp &lt; arr[i]) &#123; arr[j + gap] = arr[j]; j -= gap; &#125; arr[j + 1] = temp; &#125;&#125; 增量值递减： 123456789101112131415161718function shell(arr) &#123; var gap = Math.floor(arr.length / 2); var temp, j; while (gap &gt; 0) &#123; console.log(gap); for (let i = gap; i &lt; arr.length; i++) &#123; temp = arr[i]; j = i - gap; while (j &gt;= 0 &amp;&amp; temp &lt; arr[j]) &#123; arr[j + gap] = arr[j]; j -= gap; &#125; arr[j + gap] = temp; &#125; gap = Math.floor(gap / 2); &#125; return arr;&#125;","categories":[],"tags":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://lisq.xyz/tags/算法和数据结构/"},{"name":"排序","slug":"排序","permalink":"http://lisq.xyz/tags/排序/"}]},{"title":"二叉树","slug":"二叉树","date":"2017-11-03T07:42:10.000Z","updated":"2018-10-28T14:28:15.200Z","comments":true,"path":"2017/11/03/二叉树/","link":"","permalink":"http://lisq.xyz/2017/11/03/二叉树/","excerpt":"","text":"基本结构插入，遍历，深度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293function Node(data, left, right) &#123; this.data = data; this.left = left; this.right = right;&#125;Node.prototype = &#123; show: function () &#123; console.log(this.data); &#125;&#125;function Tree() &#123; this.root = null;&#125;Tree.prototype = &#123; insert: function (data) &#123; var node = new Node(data, null, null); if (!this.root) &#123; this.root = node; return; &#125; var current = this.root; var parent = null; while (current) &#123; parent = current; if (data &lt; parent.data) &#123; current = current.left; if (!current) &#123; parent.left = node; return; &#125; &#125; else &#123; current = current.right; if (!current) &#123; parent.right = node; return; &#125; &#125; &#125; &#125;, preOrder: function (node) &#123; if (node) &#123; node.show(); this.preOrder(node.left); this.preOrder(node.right); &#125; &#125;, middleOrder: function (node) &#123; if (node) &#123; this.middleOrder(node.left); node.show(); this.middleOrder(node.right); &#125; &#125;, laterOrder: function (node) &#123; if (node) &#123; this.laterOrder(node.left); this.laterOrder(node.right); node.show(); &#125; &#125;, getMin: function () &#123; var current = this.root; while(current)&#123; if(!current.left)&#123; return current; &#125; current = current.left; &#125; &#125;, getMax: function () &#123; var current = this.root; while(current)&#123; if(!current.right)&#123; return current; &#125; current = current.right; &#125; &#125;, getDeep: function (node,deep) &#123; deep = deep || 0; if(node == null)&#123; return deep; &#125; deep++; var dleft = this.getDeep(node.left,deep); var dright = this.getDeep(node.right,deep); return Math.max(dleft,dright); &#125;&#125; 1234567891011121314var t = new Tree();t.insert(3);t.insert(8);t.insert(1);t.insert(2);t.insert(5);t.insert(7);t.insert(6);t.insert(0);console.log(t);// t.middleOrder(t.root);console.log(t.getMin(), t.getMax());console.log(t.getDeep(t.root, 0));console.log(t.getNode(5,t.root)); 树查找12345678910111213getNode: function (data, node) &#123; if (node) &#123; if (data === node.data) &#123; return node; &#125; else if (data &lt; node.data) &#123; return this.getNode(data,node.left); &#125; else &#123; return this.getNode(data,node.right); &#125; &#125; else &#123; return null; &#125;&#125; 利用二分的思想 二分查找二分查找的条件是必须是有序的线性表。 和线性表的中点值进行比较，如果小就继续在小的序列中查找，如此递归直到找到相同的值。 123456789101112131415function binarySearch(data, arr, start, end) &#123; if (start &gt; end) &#123; return -1; &#125; var mid = Math.floor((end + start) / 2); if (data == arr[mid]) &#123; return mid; &#125; else if (data &lt; arr[mid]) &#123; return binarySearch(data, arr, start, mid - 1); &#125; else &#123; return binarySearch(data, arr, mid + 1, end); &#125;&#125;var arr = [0, 1, 1, 1, 1, 1, 4, 6, 7, 8]console.log(binarySearch(1, arr, 0, arr.length-1));","categories":[],"tags":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://lisq.xyz/tags/算法和数据结构/"}]},{"title":"基本数据结构及特点","slug":"基本数据结构及特点","date":"2017-11-02T13:13:54.000Z","updated":"2018-10-28T14:28:45.117Z","comments":true,"path":"2017/11/02/基本数据结构及特点/","link":"","permalink":"http://lisq.xyz/2017/11/02/基本数据结构及特点/","excerpt":"","text":"什么是数据结构数据元素相互之间存在的一种和多种特定的关系集合 包括二个部分组成逻辑结构，存储结构。 逻辑结构 简单的来说 逻辑结构就是数据之间的关系,逻辑结构大概统一的可以分成两种 一种是线性结构，非线性结构 。 线性结构 是一个有序数据元素的集合。 其中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的。 常用的线性结构有: 栈，队列，链表，线性表。 非线性结构 各个数据元素不再保持在一个线性序列中，每个数据元素可能与零个或者多个其他数据元素发生联系。 常见的线性结构有 二维数组，树(二叉树等)等。 存储结构 逻辑结构指的是数据间的关系，而存储结构是逻辑结构用计算机语言的实现。 常见的存储结构有顺序存储、链式存储、索引存储以及散列存储（哈希表）。 时间复杂度一个算法的时间复杂度反映了程序运行从开始到结束所需要的时间。 把算法中基本操作重复执行的次数（频度）作为算法的时间复杂度。 没有循环语句，记作O(1)，也称为常数阶。 只有一重循环，则算法的基本操作的执行频度与问题规模n呈线性增大关系，记作O（n），也叫线性阶。 常用的还有平方阶O（n2）、立方阶O（n3）、对数阶O(log2n)等。 常见的时间复杂度有：1O(1)&lt; O(log2n)&lt; O（n）&lt; O（n2）&lt; O（ n3 ）&lt; O（ 2n ） 顺序表把线性表的结点按逻辑顺序一次存放在一组地址连续的存储单元中。 可以直接通过下标获取到数据，查询快。 插入和删除时要移动后续元素，还要考虑扩容问题，插入慢。 12345678910function List() &#123; // 列表的元素个数 this.listSize = 0; // 列表的当前位置 是第几个 this.pos = 0; // 初始化一个空数组来保存列表元素 this.dataStore = [];&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374List.prototype = (function () &#123; return &#123; clear: clear, find: find, toString: toString, insert: insert, append: append, remove: remove, front: front, end: end, prev: prev, next: next, hasNext: hasNext, hasPrev: hasPrev, length: length, currPos: currPos, moveTo: moveTo, getElement: getElement &#125;; /** * 给列表最后添加元素的时候，列表元素个数+1 * @param element */ function append(element) &#123; this.listSize++; this.dataSource.push(element); &#125; /** * @param element * @returns &#123;number&#125; 如果找到，返回位置，否则-1 */ function find(element) &#123; for (var i = 0; i &lt; this.dataSource.length; i++) &#123; if (this.dataSource[i] === element) &#123; return i; &#125; &#125; return -1; &#125; /** * 删除元素成功，元素个数-1 * @param element * @returns &#123;boolean&#125; */ function remove(element) &#123; var removeIndex = this.find(element); if (removeIndex !== -1) &#123; this.dataSource.splice(removeIndex, 1); this.listSize--; return true; &#125; return false; &#125; /** * 插入某个元素 * @param element 要插入的元素 * @param afterElement 列表中的元素之后 * @returns &#123;boolean&#125; */ function insert(element, afterElement) &#123; var insertIndex = this.find(afterElement); if (insertIndex !== -1) &#123; this.dataSource.splice(insertIndex + 1, 0, element); this.listSize++; return true; &#125; return false; &#125; &#125;()); 链表用一组任意存储的单元来存储线性表的数据元素。 一个对象存储着本身的值和下一个元素的地址。 需要遍历才能查询到元素，查询慢。 插入元素只需断开连接重新赋值，插入快。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function LinkList()&#123; function node(element)&#123; this.value = element; this.next = null; &#125; let length = 0; let head = null;&#125;LinkList.prototype = &#123; append:function(element)&#123; var node = new node(element); var temp = this.head; if(this.head)&#123; //遍历找到链表的终点 while(temp.next)&#123; temp = temp.next; &#125; temp.next = node; &#125;else&#123; this.head = node; &#125; this.length++; &#125;, insert:function(element,index)&#123; if(index &lt;= this.length &amp;&amp; index&gt;0)&#123; var node = new node(element); var currentIndex = 0; var currentNode = this.head; var preNode = null; if (currentIndex === 0) &#123; node.next = currentNode; this.head = node; return; &#125; while(currentIndex&lt;index)&#123; preNode = currentNode; currentNode = currentNode.next; currentIndex++; &#125; preNode.next = node; node.next = currentNode; this.length++; &#125; &#125;&#125; 链表翻转12345678910reverse: function (node) &#123; //把初始链表头当做基准点，移动下一个元素到头部，直到下一个元素为空 var currentNode = node.next; node.next = node.next.next; currentNode.next = this.head; this.head = currentNode; if(node.next)&#123; this.reverse(node); &#125; &#125;z 栈先进后出 进栈：push (在尾部插入元素) 出栈：pop（在尾部删除元素并返回此元素） 队列先进先出 进队列：unshift（在头部插入元素） 出队列：pop(在尾部删除元素并返回) 哈希表哈希的基本原理是将给定的键值转换为偏移地址来检索记录。 键转换为地址是通过一种关系（公式）来完成的，这就是哈希（散列）函数。 虽然哈希表是一种有效的搜索技术，但是它还有些缺点。两个不同的关键字，由于哈希函数值相同，因而被映射到同一表位置上。该现象称为冲突(Collision)或碰撞。发生冲突的两个关键字称为该哈希函数的同义词(Synonym)。 好的哈希函数的选择有两条标准： 1)简单并且能够快速计算 2)能够在址空间中获取键的均匀人分布 除余法是最为简单常用的一种方法。它是以表长m来除关键字，取其余数作为散列地址，即 h(key)=key％m 解决hash冲突：链表法 链表法解决冲突的做法是：将所有关键字为同义词的结点链接在同一个单链表中。 具体的关键字列表为（19,14,23,01,68,20,84,27,55,11,10,79），则哈希函数为H（key）=key MOD 13。则采用除留余数法和链地址法后得到的预想结果应该为： 哈希造表完成后，进行查找时，首先是根据哈希函数找到关键字的位置链，然后在该链中进行搜索，如果存在和关键字值相同的值，则查找成功，否则若到链表尾部仍未找到，则该关键字不存在。 插入元素：直接按地址插入到链表末尾。 综合了链表和数组的优点，查询插入都很快。 构造hash表 12345678function linklist()&#123; ...&#125;funtion hashtable&#123; length 0 data [] &#125;","categories":[],"tags":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://lisq.xyz/tags/算法和数据结构/"}]},{"title":"老版本浏览器兼容问题总结","slug":"老版本浏览器兼容问题总结","date":"2017-10-28T15:43:12.000Z","updated":"2018-10-28T14:30:06.650Z","comments":true,"path":"2017/10/28/老版本浏览器兼容问题总结/","link":"","permalink":"http://lisq.xyz/2017/10/28/老版本浏览器兼容问题总结/","excerpt":"","text":"1.ajax12345try&#123; xhr = new XMLHttpRequest();&#125;catch(e)&#123; xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);&#125;; 2.事件12345678var addEvent = function(element,type,callback)&#123; if(element.addEventListener)&#123; element.addEventListener(type,callback,false); &#125;else if(element.attachEvent)&#123; element.attachEvent(&apos;on&apos; + type,callback) &#125; &#125; 3.innerText123function getInnerText(element) &#123; return (typeof element.textContent == &quot;string&quot;) ? element.textContent : element.innerText;&#125; 4.indexof()IE8以下不兼容indexof()方法, 添加indexof的原型方法即可；12345if (!Array.prototype.indexOf)&#123; Array.prototype.indexOf = function(elt)&#123; ... &#125;;&#125; 5.父节点parentElement1234ele.parentElement//firebox不支持ele.parentNode//通用 6.setattribute1234object.setAttribute(&quot;class&quot;,&quot;style&quot;);//在IE8、Chrome、火狐、Opera10中都能设置成功；但是在IE7下无法设置。object.setAttribute(&quot;className&quot;,&quot;className&quot;);//只有IE7能设置成功，但是其他浏览器均无法设置。 7.IE6 高度无法小于10px12添加overflow的属性设置font-size的属性为高度的大小 8.双倍float123456.divBox&#123; float:left; width:100px; margin:0 0 0 100px; //这种情况之下IE会产生200px的距离 display:inline; //使浮动忽略&#125;","categories":[],"tags":[{"name":"浏览器兼容","slug":"浏览器兼容","permalink":"http://lisq.xyz/tags/浏览器兼容/"}]},{"title":"git分支操作","slug":"git分支操作","date":"2017-10-21T13:02:18.000Z","updated":"2018-10-28T14:25:42.407Z","comments":true,"path":"2017/10/21/git分支操作/","link":"","permalink":"http://lisq.xyz/2017/10/21/git分支操作/","excerpt":"","text":"应用场景，代码运行过程中一部分要上线，新修改的代码不能影响上线代码，上线代码和正在修改的代码就要使用两个分支。 开发分支，线上分支 查看本地分支：1git branch 查看远程分支1git branch -a 创建分支：1git branch dev 创建并切换分支1git checkout -b dev 切换分支1git checkout master 提交到远程分支1git push origin dev 与另一个分支代码合并（切换到master后）1git merge dev 流程： 创建本地dev分支 提交代码到本地dev分支 提交本地dev分支到远程dev分支 合并本地master分支和本地dev分支 提交本地master分支到远程master分支","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://lisq.xyz/tags/git/"},{"name":"版本控制","slug":"版本控制","permalink":"http://lisq.xyz/tags/版本控制/"}]},{"title":"本地git链接到github","slug":"本地git链接到github","date":"2017-09-20T15:07:36.000Z","updated":"2018-10-28T14:29:37.134Z","comments":true,"path":"2017/09/20/本地git链接到github/","link":"","permalink":"http://lisq.xyz/2017/09/20/本地git链接到github/","excerpt":"","text":"本地git服务器与github建立链接Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。 我们使用GitHub完全可以代替这个中心仓库，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。 由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置： 第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key： 1ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。 如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有==id_rsa==和==id_rsa.pub==两个文件，这两个就是SSH Key的秘钥，==id_rsa==是私钥，不能泄露出去，==id_rsa.pub==是公钥，可以放心地告诉任何人。 第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面： 然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴==id_rsa.pub==文件的内容： 为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。 当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。 推送本地代码到github你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。 首先，登陆GitHub，然后，在右上角找到“Create a new project”按钮，创建一个新的仓库： 在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库： 目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。 现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令： 1git remote add origin git@github.com:michaelliao/learngit.git 注意 ==git remote add origin==后面的部分是你在上图看到的你自己的链接，每个人的都不相同。 如果你没有修改，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。 添加后，远程库的名字就是==origin==，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。 下一步，就可以把本地库的所有内容推送到远程库上： 1git push -u origin master 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的==master==分支内容推送的远程新的==master==分支，还会把本地的==master==分支和远程的==master==分支关联起来，在以后的推送或者拉取时就可以简化命令。 推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样： 从现在起，只要本地作了提交，就可以通过命令： 1git push origin master 从远程库克隆1git clone git@github.com:michaelliao/gitskills.git 注意把Git库的地址换成你自己的，然后进入gitskills目录看看，已经有README.md文件了。 如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://lisq.xyz/tags/git/"},{"name":"版本控制","slug":"版本控制","permalink":"http://lisq.xyz/tags/版本控制/"},{"name":"github","slug":"github","permalink":"http://lisq.xyz/tags/github/"}]},{"title":"git工作区和暂存区","slug":"git工作区和暂存区","date":"2017-09-09T12:56:00.000Z","updated":"2018-10-28T14:26:05.779Z","comments":true,"path":"2017/09/09/git工作区和暂存区/","link":"","permalink":"http://lisq.xyz/2017/09/09/git工作区和暂存区/","excerpt":"","text":"Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。 工作区（Working Directory） 就是你在电脑里能看到的目录，比如我的myproject文件夹就是一个工作区： 版本库（Repository） 工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 Git的版本库里存了很多东西，其中最重要的就是称为==stage==（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支==master==，以及指向==master==的一个指针叫==HEAD==。 第一步是用==git add==把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用==git commit==提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个==master==分支，所以，现在，==git commit==就是往==master==分支上提交更改。 你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 先对==readme.txt==做个修改，比如加上一行内容： 123Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage. 然后，在工作区新增一个==LICENSE==文本文件（内容随便写）。 先用==git status==查看一下状态： 1234567891011121314G:\\myproject&gt;git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txtUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) LICENSE.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) Git非常清楚地告诉我们，==readme.txt==被修改了，而==LICENSE==还从来没有被添加过，所以它的状态是==Untracked==。 现在，使用两次命令==git add==，把==readme.txt==和==LICENSE==都添加后，用==git status==再查看一下： 1234567G:\\myproject&gt;git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: LICENSE.txt modified: readme.txt 现在，暂存区的状态就变成这样了： 所以，==git add==命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行==git commit==就可以一次性把暂存区的所有修改提交到分支。 1234G:\\myproject&gt;git commit -m &quot;fourth&quot;[master 9069b76] fourth 2 files changed, 3 insertions(+), 1 deletion(-) create mode 100644 LICENSE.txt 一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的： 123G:\\myproject&gt;git statusOn branch masternothing to commit, working tree clean 现在版本库变成了这样，暂存区就没有任何内容了： 每次修改，如果不==add==到暂存区，那就不会加入到==commit==中。 所以为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://lisq.xyz/tags/git/"},{"name":"版本控制","slug":"版本控制","permalink":"http://lisq.xyz/tags/版本控制/"}]},{"title":"git基本操作","slug":"git基本操作","date":"2017-09-08T13:47:57.000Z","updated":"2018-10-26T11:43:11.244Z","comments":true,"path":"2017/09/08/git基本操作/","link":"","permalink":"http://lisq.xyz/2017/09/08/git基本操作/","excerpt":"","text":"创建版本库版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 第一步很简单，就是找到你想让git管理的项目目录或者新建一个目录。 第二步，通过git init命令把这个目录变成Git可以管理的仓库： 12G:\\myproject&gt;git initInitialized empty Git repository in G:/myproject/.git/ 瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。 如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。 上传文件到版本库我们编写一个readme.txt文件，内容如下： 12Git is a version control system.Git is free software. 一定要放到版本库目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。 第一步，用命令git add告诉Git，把文件添加到仓库： 1G:\\myproject&gt;git add readme.txt 执行上面的命令，没有任何显示，这就对了 第二步，用命令git commit告诉Git，把文件提交到仓库： 1234G:\\myproject&gt;git commit -m &quot;first time&quot;[master (root-commit) 6d5bb1a] first time 1 file changed, 2 insertions(+) create mode 100644 readme.txt 简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容,当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。 git commit命令执行成功后会告诉你，1个文件被改动（我们新添加的readme.txt文件），插入了两行内容（readme.txt有两行内容）。 为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如： 123$ git add file1.txt$ git add file2.txt file3.txt$ git commit -m &quot;add 3 files.&quot; 查看文件修改信息我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件，改成如下内容： 12Git is a distributed version control system.Git is free software. 现在，运行git status命令看看结果： 123456789G:\\myproject&gt;git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) git status命令可以让我们时刻掌握仓库当前的状态，上面的命令告诉我们，readme.txt被修改过了，但还没有准备提交的修改。 虽然Git告诉我们readme.txt被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的readme.txt，所以，需要用git diff这个命令看看： 123456789101112G:\\myproject&gt;git diffdiff --git a/readme.txt b/readme.txtindex 188e70b..013b5bc 100644--- a/readme.txt+++ b/readme.txt@@ -1,2 +1,2 @@-Git is a version control system.-Git is free software.1\\ No newline at end of file+Git is a distributed version control system.+Git is free software.\\ No newline at end of file 可以从上面的命令输出看到，我们在第一行添加了一个“distributed”单词。知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了。 版本回退现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下： 然后尝试提交： 12345G:\\myproject&gt;git add readme.txtG:\\myproject&gt;git commit -m &quot;third&quot;[master 52a89b8] third 1 file changed, 1 insertion(+), 1 deletion(-) 我们可以使用 git log 命令查看我们一共有几个版本提交到git版本库中了 123456789101112131415161718G:\\myproject&gt;git logcommit 52a89b86b2b54f223e17a84801ae6f78d01f3057Author: admin &lt;admin@qq.com&gt;Date: Sat Sep 9 09:26:06 2017 +0800 thirdcommit 95c55bfa753a2827e499b5ab2f58b442fedc8a4fAuthor: admin &lt;admin@qq.com&gt;Date: Fri Sep 8 22:10:53 2017 +0800 secondcommit 6d5bb1a4018c70bd01e4927c4c5af8449ef8aad5Author: admin &lt;admin@qq.com&gt;Date: Fri Sep 8 21:05:49 2017 +0800 first time git log命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是third，上一次是second，最早的一次是first time。如果嫌输出信息太多，看得眼花缭乱的，可以试试加上–pretty=oneline参数： 1234G:\\myproject&gt;git log --pretty=oneline52a89b86b2b54f223e17a84801ae6f78d01f3057 third95c55bfa753a2827e499b5ab2f58b442fedc8a4f second6d5bb1a4018c70bd01e4927c4c5af8449ef8aad5 first time 你看到的一大串类似3628164…882e1e0的是commit id（版本号） 好了，现在我们启动时光穿梭机，准备把readme.txt回退到上一个版本，也就是“second”的那个版本，怎么做呢？ Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交3628164…882e1e0（注意我的提交ID和你的肯定不一样）， 上一个版本就是1HEAD^ 上上一个版本就是1HEAD^^ 当然往上100个版本写1100个^ 比较容易数不过来，所以写成1HEAD~100 12git reset --hard HEAD~1HEAD is now at 95c55bf second 这样我们就回退到了第二个版本,此时HEAD也指向了second版本 12Git is a distributed version control system.Git is free software. 在使用git log命令查看版本情况 123456789101112G:\\myproject&gt;git logcommit 95c55bfa753a2827e499b5ab2f58b442fedc8a4fAuthor: admin &lt;admin@qq.com&gt;Date: Fri Sep 8 22:10:53 2017 +0800 secondcommit 6d5bb1a4018c70bd01e4927c4c5af8449ef8aad5Author: admin &lt;admin@qq.com&gt;Date: Fri Sep 8 21:05:49 2017 +0800 first time 如果你现在又想回到third版本怎么办？只需要找到third版本的版本号，版本号没必要写全，前几位就可以了，Git会自动去找。 可以使用git reflog命令查看以前每次版本的版本号（这个命令用于查看你的每一次操作） 12345G:\\myproject&gt;git reflog95c55bf HEAD@&#123;0&#125;: reset: moving to HEAD~152a89b8 HEAD@&#123;1&#125;: commit: third95c55bf HEAD@&#123;2&#125;: commit: second6d5bb1a HEAD@&#123;3&#125;: commit (initial): first time 我们看到thid版本的版本号前几位是52a89b8，输入如下命令： 12git reset --hard 52a89bHEAD is now at 52a89b third 这是readme的内容又回到了third版本。 撤销修改凌晨两点，你正在赶一份工作报告，你在readme.txt中添加了一行： 12345Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.My stupid boss still prefers SVN. 在你准备提交前，一杯咖啡起了作用，你猛然发现了“stupid boss”可能会让你丢掉这个月的奖金！ 既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用git status查看一下： 123456789G:\\myproject&gt;git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 你可以发现，Git会告诉你，git checkout – file可以丢弃工作区的修改： 1git checkout -- readme.txt 命令git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 git checkout – file命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://lisq.xyz/tags/git/"},{"name":"版本控制","slug":"版本控制","permalink":"http://lisq.xyz/tags/版本控制/"}]},{"title":"git命令大全","slug":"git命令大全","date":"2017-09-08T05:10:01.000Z","updated":"2018-10-26T11:43:11.246Z","comments":true,"path":"2017/09/08/git命令大全/","link":"","permalink":"http://lisq.xyz/2017/09/08/git命令大全/","excerpt":"","text":"指令 作用 git init 创建版本库 git add 将工作区文件放到暂存区,可反复多次使用，添加多个文件 git commit 将暂存区文件放到分支 git statu 查看仓库当前状况（有多少文件修改，在什么位置） git diff 查看文件具体做了什么修改 git log 查看提交历史，以便确定要回退到哪个版本 git reset 重新设定版本 HEAD HEAD代表当前版本，HEAD~100代表回退一百个版本 git reflog 查看命令历史，以便确定要回到未来的哪个版本 git remote add origin 后面跟远程版本库的唯一url，表示本地版本库和远程版本库建立连接 git push -u origin master 将本地版本库commit过的内容提交到远程版本库的marster分支 git clone 从远程版本库克隆代码 git add . 提交所有修改到暂存区 git rebase 用于把一个分支的修改合并到当前分支","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://lisq.xyz/tags/git/"},{"name":"版本控制","slug":"版本控制","permalink":"http://lisq.xyz/tags/版本控制/"}]},{"title":"一款非常好用的全景生成，全景标记编辑插件","slug":"一款非常好用的全景生成，全景标记编辑插件","date":"2017-08-24T14:56:47.000Z","updated":"2018-10-28T14:28:07.284Z","comments":true,"path":"2017/08/24/一款非常好用的全景生成，全景标记编辑插件/","link":"","permalink":"http://lisq.xyz/2017/08/24/一款非常好用的全景生成，全景标记编辑插件/","excerpt":"","text":"最近一直在研究全景功能，于是封装成一个方便小巧的插件以便大家使用！ 插件包括两部分：全景展示部分，全景标记编辑部分，二者结合使用非常方便！ 使用插件首先需要引用 three.js 1.全景展示1.1 参数说明 参数名称 类型 说明 container string 存放全景的容器id url string 存放全景图片的路径 lables array {position:{lon:经度,lat:纬度},logoUrl:’logo路径’,text:’内容’} widthSegments num 水平切段数 heightSegments num 垂直切段数（值小粗糙速度快，值大精细速度慢） pRadius num 全景球的半径，影响视觉效果，推荐使用默认值 minFocalLength num 镜头最小拉近距离 maxFocalLength num 镜头最大拉近距离 showlable ‘show’/‘click’ 显示标记的方式，分为直接显示和点击显示 1.2 公用方法 方法名称 说明 config 给全景对象设置配置信息 init 初始化全景对象 clean 清除全景对象 1.3 使用初始化：（参数不设置则采用默认参数） 123456789101112131415161718var opt,tp;window.onload = function () &#123; opt = &#123; container:'panoramaConianer',//容器 url:'img/p1.png', lables:[ &#123;position:&#123;lon:180,lat:0&#125;,logoUrl:'',text:'我是一个标记'&#125; ], widthSegments: 60,//水平切段数 heightSegments: 40,//垂直切段数（值小粗糙速度快，值大精细速度慢） pRadius: 1000,//全景球的半径，推荐使用默认值 minFocalLength: 6,//镜头最a小拉近距离 maxFocalLength: 100,//镜头最大拉近距离 showlable: 'show' // show,click &#125; tp = new tpanorama(opt); tp.init();&#125; 修改某些参数 123456opt.showlable = 'click';opt.lables = [&#123;position:&#123;lon:180,lat:0&#125;,logoUrl:'img/logo.png',text:'点击了这个标记'&#125;];opt.url = 'img/p1.png';tp.clean();tp.config(opt);tp.init(); 2.添加全景标记工具在展示全景的时候，你或许会对标记的位置产生了疑问，如何确定标记的位置？ 我们可以使用类似经纬度的参数来表达它，注意这里使用的经纬度并不是真正的经纬度，是我们根据地球的经纬度模拟出来的一个参数。 下面这个工具就是用于获取我们想标记位置的 ‘经纬度’的一种方法，有了这个工具就可以完美结合上面的全景展示工具来使用了。 2.1 参数说明 参数名称 类型 说明 container string 存放全景设置的容器id imgUrl string 全景图路径 width string 指定宽度（这里图片必须严格按比例放置），高度自适应 showGrid bool 是否显示全景图的网格 showPosition bool 是否显示经纬度信息框 lableColor string 标记在图上的颜色 gridColor string 绘制格网的颜色 lables array 以前标记过的标记 {lon:114,lat:38,text:’标记一’} addLable bool 是否开启双击添加标记(必须开启经纬度提示) getLable bool 是否开启右键查询标记 (必须开启经纬度提示) deleteLbale bool 开启默认中键删除 （必须开启经纬度提示） 2.2 公共方法 方法名称 说明 config 给全景对象重新设置配置信息 init 初始化全景设置对象 getAllLables 获取所有已经添加的标记 addLable 用于手动设置添加标记 getLable 用于手动设置获取标记 delete 用于手动删除标记 listen 对全景对象监听事件 2.3 使用2.3.1 默认参数使用使用默认参数，对标记的增删查改已封装好，所有标记设置完成时可使用getAll方法与数据库进行交互 初始化（参数不设置则采用默认参数） 1234567891011121314151617181920var opt,s;window.onload = function () &#123; opt = &#123; container: 'set',//setting容器 imgUrl: 'img/p3.png', width: '1000px',//指定宽度，高度自适应 showGrid: true,//是否显示格网 showPosition: true,//是否显示经纬度提示 lableColor: '#9400D3',//标记颜色 gridColor: '#48D1CC',//格网颜色 lables: [ &#123;lon:-72.00,lat:9.00,text:'蓝窗户'&#125;,&#123;lon:114.12,lat:69.48,text:'一片云彩'&#125;,&#123;lon:132.48,lat:-12.24,text:'大海'&#125; ],//标记 &#123;lon:114,lat:38,text:'标记一'&#125; addLable: true,//开启后双击添加标记 (必须开启经纬度提示) getLable: true,//开启后右键查询标记 (必须开启经纬度提示) deleteLbale:true//开启后中键删除(必须开启经纬度提示) &#125;; s = new tpanoramaSetting(opt); s.init();&#125; 参数切换 123456789101112131415function changeImg(name) &#123; if (name == \"p1\")&#123; opt.lables = [&#123;lon:178.56,lat:-15.84,text:'神像'&#125;] &#125; if (name == \"p2\")&#123; opt.lables = [&#123;lon:-80.64,lat:-16.92,text:'蓝色'&#125;,&#123;lon:46.80,lat:10.44,text:'绿色'&#125;] &#125; if (name == \"p4\")&#123; opt.lables = [&#123;lon:48.96,lat:-20.16,text:'樱花'&#125;] &#125; opt.imgUrl = 'img/'+name+'.png'; s.clean(); s.config(opt); s.init();&#125; 2.3.2 自定义事件很多情况下默认参数不能满足我们的业务需求，这时可以自定义事件。 插件提供了listen函数用于监听各种事件。 添加标记： 1234567s.listen('dblclick',function (e) &#123; var text = prompt(\"标记名称\"); if (text!=null &amp;&amp; text!= undefined &amp;&amp; text!=\"\") &#123; s.addLable(e,text); alert(\"添加标记：\"+text+\" 后台交互\"); &#125;&#125;); 查询标记: 12345678s.listen('mousedown',function (e) &#123; if (e.button == 2) &#123; var p = s.getLable(e); if (p.lon!=null &amp;&amp;p.lon!=undefined&amp;&amp;p.lon!=\"\" ) &#123; alert(\"经度：\" + p.lon + \",纬度：\" + p.lat + \",名称：\" + p.text +\" 其他操作\"); &#125; &#125;&#125;); 删除标记: 1234567891011121314s.listen('mousedown',function (e) &#123; if (e.button == 1) &#123; var p = s.getLable(e); if (p.lon!=null &amp;&amp;p.lon!=undefined&amp;&amp;p.lon!=\"\" ) &#123; var c = confirm(\"您确认要删除该标记吗？\"); if (c) &#123; s.delete(p); s.clean(); s.init(); alert(\"删除成功！ 后台交互\") &#125; &#125; &#125;&#125;); 完整源码及DEMO地址：https://github.com/ConardLi/tpanorama","categories":[],"tags":[{"name":"三维","slug":"三维","permalink":"http://lisq.xyz/tags/三维/"},{"name":"全景","slug":"全景","permalink":"http://lisq.xyz/tags/全景/"},{"name":"three.js","slug":"three-js","permalink":"http://lisq.xyz/tags/three-js/"}]},{"title":"webgl基础","slug":"webgl基础","date":"2017-07-09T02:47:34.000Z","updated":"2018-10-28T14:27:32.242Z","comments":true,"path":"2017/07/09/webgl基础/","link":"","permalink":"http://lisq.xyz/2017/07/09/webgl基础/","excerpt":"","text":"1. canvas和webglWebGL是利用canvas来实现的 canvas和img等标签一样，是一个可以自由制定大小的矩形区域。 通过javascript可以对矩形区域进行操作，可以自由的绘制图形，文字等。而且，可以添加影子，进行涂色，另外还可以对绘制的图形进行旋转等操作。 一般使用canvas都是使用它的2d的context功能，但是也仅限于此，像它的名字一样，只能用于2d空间的绘图。 和这个相对的，WebGL是三维，可以描画3D图形，区别于之前的2dcontext，它叫做webglcontext。 2. 3D绘图基础利用WebGL可以模拟三维空间，但是最终必须输出显示在一个二维的显示器上。由深度决定的前后关系，根据远近进行放大和缩小，这些都必须提前进行运算得出结果。 这时候，坐标变换就是必须的了。坐标变换大致可以分为三种，将这些正确的组合在一起，最终决定显示器上的位置。 模型变换：第一种变换 定义参照物在三维空间的什么位置。假设，虚拟的三维空间里有一个苹果，那么为了表示这个苹果在什么位置，就需要进行相应的模型变换了。 视图变换：第二种变换 为了决定镜头的位置和角度所进行的坐标变换就叫做视图变换。即使三维空间中有一个苹果，如果镜头的方向不对着苹果的话，同样也是看不到这个苹果的。而且，如果将镜头大幅度远离苹果，那么也有可能看不到苹果了。 投影变换：这个变换，定义了三维空间的摄影区域。比如，是横向摄影，还是纵向摄影，最远拍摄多远距离等。 3. 矩阵矩阵虽然有很多种，其中的一种叫做方阵。就是行数和列数相同的矩阵。 一般的3D渲染的世界中使用的是4x4的矩阵。 实际3D渲染的时候，准备好模型坐标变换，视图坐标变换，投影坐标变换的各个矩阵。再具体一点，就是准备好各种坐标变换的矩阵，然后相乘。将最终得到的矩阵传给WebGL的顶点着色器。 矩阵可以将上面提到的变换保存起来，比如，如果是模型变换的矩阵，想要绘制的3D模型的位置，扩大缩小，以及旋转等信息，都可以定义在一个矩阵中。视图变换矩阵，镜头的位置，镜头的方向，以及镜头对准了哪个点（注视点）等可以定义在一个矩阵中。投影变换矩阵的话，显示的横竖比例和视角等信息可以定义在一个矩阵中。 需要注意一点，如果是普通的数学计算，相乘的时候，不需要注意相乘的顺序，比如2x3等于6，3x2也等于6。但是矩阵的话，根据相乘的顺序得出的结果是不同的。因为矩阵的这种性质，所以进行模型，视图，投影的矩阵相乘的时候，要特别注意相乘的顺序。 顶点着色器从传过来的矩阵中，获取到模型的坐标，加工到画面上显示出来。也就是说，操作坐标变换的矩阵，就可以决定模型在画面上如何绘制。 4. webgl可描述的东西要说在WebGL的世界里能够描画什么，其实任何东西都可以描画。而描画的最基本的东西就是下面几种。 点 线段 三角形 WebGL就是使用三角形在画面上绘制一些东西。这个三角形就是一个多边形，一个多边形至少是将三个顶点连接画出来的三角形，所以一个绘制一个多边形，最少需要三个顶点。 顶点，就是三维空间上存在的一个点。当然，这个点需要有坐标位置。顶点的横坐标是x，纵坐标是y，深度是z。将包含这些信息的点连接起来就形成了一个多边形。 非常逼真的3D游戏用了你想像不到的大量的三角形，制作出了无比精美的人物和场景。 想要绘制复杂构造的模型的话，需要准备大量的非常小的多边形。用的多边形越少，绘制的模型的棱角就越明显。 想要绘制精美的模型，就需要更多的多边形，当然，这些多边形的数量增加的话，定点数量也会成倍成倍的增加，坐标计算的负荷就越大。 顶点链接顺序和遮挡剔除3D渲染的世界里，看不到的东西不绘制的是减轻负担的最普通的方法。这就叫做遮挡剔除，如果设定了遮挡剔除，就只会绘制外侧看得见的多边形，内侧的所有多边形就都不再进行绘制了。 顺时针连接顶点的多边形是在外侧，而逆时针连接的多边形在内侧。所以，在定义顶点情报的时候，要特别注意。如果设定了遮挡剔除，本来应该在某个位置有个多边形，但是根本就不会进行绘制。 5.context初始化12345678window.onload = function () &#123; var c = document.getElementById('canvas'); c.width = 500; c.height = 300; var gl = c.getContext('webgl') || c.getContext('experimental-webgl'); gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.clear(gl.COLOR_BUFFER_BIT);&#125; 1gl.clear(gl.COLOR_BUFFER_BIT); 这个函数将画面清空，回到一个全新的状态。参数是要清空的对象，或者是WebGL中定义的常量。这一次，只是清空一下画面上的颜色，所以使用COLOR_BUFFER_BIT这个常量，这个常量是为了使用canvas里面指定的颜色来清空画面而定义的。 1gl.clearColor(0.0, 0.0, 0.0, 1.0); 如果要清空画面所使用的颜色的话，就必须得另外定义了。这个函数是clearColor。clearColor函数的参数有四个，就是单纯的RGBA，很直观吧，使用方法如下。 6.着色器WebGL中，所谓的固定渲染管线是不存在的。 固定渲染管线，简单来说，就是3d渲染所进行的一连串的计算流程，就像流水线一样。如果有了固定渲染管线，编写程序就比较容易了，因为所有的变换都是由固定渲染管线来完成的，但是缺点就是自由度低。固定渲染管线只能完成一些最基本的操作，如果想要做一些特殊的处理，就比较麻烦了。 WebGL中不存在固定渲染管线。也就是说，坐标变换必须全部由自己来做。而且，这个记述了坐标变换的机制就叫做着色器(Shader)。 这样可以由程序员控制的机制叫做可编辑渲染管线。而着色器又有 处理几何图形顶点的顶点着色器和处理像素的片段着色器两种类型。由于WebGL中没有固定管线，所以必须准备好顶点着色器和片段着色器。 着色器的添加可以有多种做法。着色器是由程序员自己编写的，而且着色器的代码就是简单的字符串而已。所以，不管用什么方法，只要把这个着色器字符串传给程序就可以了。 最简单的方法，就是把着色器记录在HTML中。使用这种方法的话，是利用HTML的script标签来做的。下面是一个简单的例子。 1234567&lt;script id=\"vshader\" type=\"x-shader/x-vertex\"&gt; ※顶点着色器 &lt;/script&gt; &lt;script id=\"fshader\" type=\"x-shader/x-fragment\"&gt; ※片段着色器 &lt;/script&gt; 指定type属性的理由:type属性指定了［x-shader/x-vertex］和［x-shader/x-fragment］，这并不是HTML中定义的正式的写法。但是一般的浏览器如果遇到不识别的标签的话会无视掉的，浏览器不会认为这是javascript代码的。浏览器只会把它当成无意义的字符串，而程序中则可以使用标签里面的内容。","categories":[],"tags":[{"name":"webgl","slug":"webgl","permalink":"http://lisq.xyz/tags/webgl/"},{"name":"三维","slug":"三维","permalink":"http://lisq.xyz/tags/三维/"}]}]}