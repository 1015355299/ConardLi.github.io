{"meta":{"title":"李世奇的技术专栏","subtitle":null,"description":"Fe Coder","author":"ConardLi","url":"https://www.lisq.xyz"},"pages":[{"title":"about","date":"2018-10-28T15:07:13.000Z","updated":"2018-11-03T15:46:49.634Z","comments":true,"path":"about/index.html","permalink":"https://www.lisq.xyz/about/index.html","excerpt":"","text":"关于，以后再说…….."}],"posts":[{"title":"react中key的正确使用方式","slug":"react中key的正确使用方式","date":"2018-11-26T17:50:45.000Z","updated":"2018-11-26T17:52:20.367Z","comments":true,"path":"2018/11/27/react中key的正确使用方式/","link":"","permalink":"https://www.lisq.xyz/2018/11/27/react中key的正确使用方式/","excerpt":"","text":"在开发react程序时我们经常会遇到这样的警告，然后就会想到：哦！循环子组件忘记加key了～ 出于方便，有时候会不假思索的使用循环的索引作为key，但是这样真的好吗？什么样的值才是key的最佳选择？ 为了弄明白，本文将从三个方面来分析”key”： 1.为什么要使用key 2.使用index做key存在的问题 3.正确的选择key 1.为什么要使用keyreact官方文档是这样描述key的： Keys可以在DOM中的某些元素被增加或删除的时候帮助React识别哪些元素发生了变化。因此你应当给数组中的每一个元素赋予一个确定的标识。 react的diff算法是把key当成唯一id然后比对组件的value来确定是否需要更新的，所以如果没有key，react将不会知道该如何更新组件。 你不传key也能用是因为react检测到子组件没有key后，会默认将数组的索引作为key。 react根据key来决定是销毁重新创建组件还是更新组件，原则是： key相同，组件有所变化，react会只更新组件对应变化的属性。 key不同，组件会销毁之前的组件，将整个组件重新渲染。 2.使用index做key存在的问题2.1 受控组件单纯的展示组件比如span，这些组件是受控组件，意味着他们的值将是我们给定好的。 如果子组件只是受控组件，使用index作为key，可能表面上不会有什么问题，实际上性能会受很大的影响。例如下面的代码： 123456789101112// [&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;]=&gt;&lt;ul&gt; &lt;li key=&quot;0&quot;&gt;张三&lt;/li&gt; &lt;li key=&quot;1&quot;&gt;李四&lt;/li&gt; &lt;li key=&quot;2&quot;&gt;王五&lt;/li&gt;&lt;/ul&gt;// 数组重排 -&gt; [&apos;王五&apos;,&apos;张三&apos;,&apos;李四&apos;] =&gt;&lt;ul&gt; &lt;li key=&quot;0&quot;&gt;王五&lt;/li&gt; &lt;li key=&quot;1&quot;&gt;张三&lt;/li&gt; &lt;li key=&quot;2&quot;&gt;李四&lt;/li&gt;&lt;/ul&gt; 当元素数据源的顺序发生改变时，对应的： key为0，1，2的组件都发生了变化，三个子组件都会被重新渲染。（这里的重新渲染不是销毁，因为key还在） 相反，我们使用唯一id作为key： 123456789101112// [&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;]=&gt;&lt;ul&gt; &lt;li key=&quot;000&quot;&gt;张三&lt;/li&gt; &lt;li key=&quot;111&quot;&gt;李四&lt;/li&gt; &lt;li key=&quot;222&quot;&gt;王五&lt;/li&gt;&lt;/ul&gt;// 数组重排 -&gt; [&apos;王五&apos;,&apos;张三&apos;,&apos;李四&apos;] =&gt;&lt;ul&gt; &lt;li key=&quot;222&quot;&gt;王五&lt;/li&gt; &lt;li key=&quot;000&quot;&gt;张三&lt;/li&gt; &lt;li key=&quot;111&quot;&gt;李四&lt;/li&gt;&lt;/ul&gt; 根据上面的更新原则，子组件的值和key均未发生变化，只是顺序发生改变，因此react只是将他们做了移动，并未重新渲染。 2.2 非受控组件像input这样可以由用户任意改变值，不受我们控制的组件，在使用了index作为key时可能会发生问题，看如下的栗子： 子组件： 123456789 render() &#123; return ( &lt;div&gt; &lt;p &gt;值：&#123;this.props.value&#125;&lt;/p&gt; &lt;input /&gt; &lt;/div&gt; ); &#125;&#125; 父组件12345&#123;this.state.data.map((element, index) =&gt; &#123; return &lt;Child value=&#123;element&#125; key=&#123;index&#125; /&gt; &#125;)&#125; 我们在前两个输入框分别输入对应的值： 然后在头部添加一个元素： 很明显，这个结果并不符合我们的预期，我们来分析一下发生了什么： 123456789101112&lt;div key=&quot;0&quot;&gt; &lt;p &gt;值：0&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=&quot;1&quot;&gt; &lt;p &gt;值：1&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=&quot;2&quot;&gt; &lt;p &gt;值：2&lt;/p&gt; &lt;input /&gt;&lt;/div&gt; 变化后： 12345678910111213141516&lt;div key=&quot;0&quot;&gt; &lt;p &gt;值：5&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=&quot;1&quot;&gt; &lt;p &gt;值：0&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=&quot;2&quot;&gt; &lt;p &gt;值：1&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=&quot;3&quot;&gt; &lt;p &gt;值：2&lt;/p&gt; &lt;input /&gt;&lt;/div&gt; 可以发现：key 0，1，2并没有发生改变，根据规则，不会卸载组件，只会更新改变的属性。 react只diff到了p标签内值的变化，而input框中的值并未发生改变，因此不会重新渲染，只更新的p标签的值。 当使用唯一id作为key后： 123456789101112&lt;div key=&quot;000&quot;&gt; &lt;p &gt;值：0&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=&quot;111&quot;&gt; &lt;p &gt;值：1&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=&quot;222&quot;&gt; &lt;p &gt;值：2&lt;/p&gt; &lt;input /&gt;&lt;/div&gt; 变化后： 12345678910111213141516&lt;div key=&quot;555&quot;&gt; &lt;p &gt;值：5&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=&quot;000&quot;&gt; &lt;p &gt;值：0&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=&quot;111&quot;&gt; &lt;p &gt;值：1&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=&quot;222&quot;&gt; &lt;p &gt;值：2&lt;/p&gt; &lt;input /&gt;&lt;/div&gt; 可以很明显的发现：key为 111，222，333的组件没有发生任何改变，react不会更新他们，只是新插入了子组件555，并改变了其他组件的位置。 3.正确的选择key3.1 纯展示如果组件单纯的用于展示，不会发生其他变更，那么使用index或者其他任何不相同的值作为key是没有任何问题的，因为不会发生diff，就不会用到key。 3.2 推荐使用index的情况并不是任何情况使用index作为key会有缺陷，比如如下情况： 你要分页渲染一个列表，每次点击翻页会重新渲染： 使用唯一id： 123456789101112第一页&lt;ul&gt; &lt;li key=&quot;000&quot;&gt;张三&lt;/li&gt; &lt;li key=&quot;111&quot;&gt;李四&lt;/li&gt; &lt;li key=&quot;222&quot;&gt;王五&lt;/li&gt;&lt;/ul&gt;第二页&lt;ul&gt; &lt;li key=&quot;333&quot;&gt;张三三&lt;/li&gt; &lt;li key=&quot;444&quot;&gt;李四四&lt;/li&gt; &lt;li key=&quot;555&quot;&gt;王五五&lt;/li&gt;&lt;/ul&gt; 翻页后，三条记录的key和组件都发生了改变，因此三个子组件都会被卸载然后重新渲染。 使用index： 123456789101112第一页&lt;ul&gt; &lt;li key=&quot;0&quot;&gt;张三&lt;/li&gt; &lt;li key=&quot;1&quot;&gt;李四&lt;/li&gt; &lt;li key=&quot;2&quot;&gt;王五&lt;/li&gt;&lt;/ul&gt;第二页&lt;ul&gt; &lt;li key=&quot;0&quot;&gt;张三三&lt;/li&gt; &lt;li key=&quot;1&quot;&gt;李四四&lt;/li&gt; &lt;li key=&quot;2&quot;&gt;王五五&lt;/li&gt;&lt;/ul&gt; 翻页后，key不变，子组件值发生改变，组件并不会被卸载，只发生更新。 3.3 子组件可能发生变更/使用了非受控组件大多数情况下，使用唯一id作为子组件的key是不会有任何问题的。 这个id一定要是唯一，并且稳定的，意思是这条记录对应的id一定是独一无二的，并且永远不会发生改变。 不推荐使用math.random或者其他的第三方库来生成唯一值作为key。 因为当数据变更后，相同的数据的key也有可能会发生变化，从而重新渲染，引起不必要的性能浪费。 如果数据源不满足我们这样的需求，我们可以在渲染之前为数据源手动添加唯一id，而不是在渲染时添加。","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://www.lisq.xyz/tags/react/"},{"name":"原理","slug":"原理","permalink":"https://www.lisq.xyz/tags/原理/"}]},{"title":"electron程序保护措施（崩溃监控，开机自启，托盘关闭）","slug":"electron程序保护措施（崩溃监控，开机自启，托盘关闭）","date":"2018-11-07T12:11:41.000Z","updated":"2018-11-07T12:12:13.617Z","comments":true,"path":"2018/11/07/electron程序保护措施（崩溃监控，开机自启，托盘关闭）/","link":"","permalink":"https://www.lisq.xyz/2018/11/07/electron程序保护措施（崩溃监控，开机自启，托盘关闭）/","excerpt":"","text":"在某种情况下，我们可能希望我们的客户端程序尽可能连续不断的运行在我们的系统中，并保持稳定。 以下几种方式可以帮助我们做到这一点： 1.崩溃监控electron为我们提供了监听程序崩溃的事件： 123456Event: &apos;crashed&apos;返回:event Eventkilled Boolean当渲染进程崩溃或被结束时触发 此事件是用来家庭渲染进程崩溃的，但是当主进程意外崩溃时也会触发该事件。 在监测到程序崩溃后，我们要让程序重新启动，此时我们要首先判断window对象是否被销毁，也就是主进程是否被杀死，还是渲染进程崩溃，同时作出不同的处理。 当mainWin被销毁时我们直接重启整个应用，使用如下api： 12345678910app.relaunch([options])options Object (可选)args StringexecPath String (可选)从当前实例退出，重启应用。默认情况下，新的实例会和当前实例使用相同的工作目录以及命令行参数。 当设置了 args 参数时， args 将作为命令行参数传递。 当设置了 execPath ，execPath 将被执行以重新启动，而不是当前的应用程序。请注意, 此方法在执行时不会退出当前的应用程序, 你需要在调用 app.relaunch 方法后再执行 app. quit 或者 app.exit 来让应用重启。 只是渲染进程崩溃，我们只需将其他窗体销毁，然后重新load我们的主窗口。 崩溃重启逻辑： 123456789if (mainWin.isDestroyed()) &#123; app.relaunch(); app.exit(0);&#125; else &#123; BrowserWindow.getAllWindows().forEach((w) =&gt; &#123; if (w.id !== mainWin.id) w.destroy(); &#125;); mainWin.reload();&#125; 当然，我们还要记录一下程序的崩溃日志，我们要确保日志接口发出成功后再重启我们的程序： 下面是程序崩溃后的完整逻辑： 123456789101112131415161718192021222324252627282930313233343536373839import &#123; BrowserWindow, app, dialog&#125; from &apos;electron&apos;; const mainWindow = BrowserWindow.fromId(global.mainId);mainWindow.webContents.on(&apos;crashed&apos;, () =&gt; &#123; const options = &#123; type: &apos;error&apos;, title: &apos;进程崩溃了&apos;, message: &apos;这个进程已经崩溃.&apos;, buttons: [&apos;重载&apos;, &apos;退出&apos;], &#125;; recordCrash().then(() =&gt; &#123; dialog.showMessageBox(options, (index) =&gt; &#123; if (index === 0) reloadWindow(mainWindow); else app.quit(); &#125;); &#125;).catch((e) =&gt; &#123; console.log(&apos;err&apos;, e); &#125;);&#125;)function recordCrash() &#123; return new Promise(resolve =&gt; &#123; // 崩溃日志请求成功.... resolve(); &#125;)&#125; function reloadWindow(mainWin) &#123; if (mainWin.isDestroyed()) &#123; app.relaunch(); app.exit(0); &#125; else &#123; BrowserWindow.getAllWindows().forEach((w) =&gt; &#123; if (w.id !== mainWin.id) w.destroy(); &#125;); mainWin.reload(); &#125;&#125; 写好代码之后，我们可以直接在控制台输入 123456789101112# 2.开机自启开机自启是保证我们的程序能长时间在机器上运行很重要的一点。电脑上有很多程序都设置了开机自启动，比如qq，微信，迅雷等，他们都是通过修改注册表来实现的，我们可以看一下注册表``` \\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run```:![image](https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/zhucebiao1.bmp)所以我们也要将我们程序的路径写到这里。发现了一个非常好的写注册表的模块，```winreg 注意mac不能使用这个模块，所以首先要判断是否为window再引用这个模块。 借助这个模块我们可以非常简单的修改注册表： 1234567891011121314151617181920212223242526272829303132333435363738394041const WinReg = require(&apos;winreg&apos;);const startOnBoot = &#123; enableAutoStart: function (name, file, callback) &#123; var key = getKey(); key.set(name, WinReg.REG_SZ, file, callback || noop); &#125;, disableAutoStart: function (name, callback) &#123; var key = getKey(); key.remove(name, callback || noop); &#125;, getAutoStartValue: function (name, callback) &#123; var key = getKey(); key.get(name, function (error, result) &#123; if (result) &#123; callback(result.value); &#125; else &#123; callback(null, error); &#125; &#125;); &#125;&#125;;function noop() &#123; &#125;const RUN_LOCATION = &apos;\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run&apos;;function getKey() &#123; return new WinReg(&#123; hive: WinReg.HKCU, //CurrentUser, key: RUN_LOCATION &#125;);&#125;export default function autoStart() &#123; startOnBoot.getAutoStartValue(&apos;MY_CLIENT_AUTOSTART&apos;, function (value) &#123; if (!value) &#123; startOnBoot.enableAutoStart(&apos;MY_CLIENT_AUTOSTART&apos;, process.execPath, function () &#123; console.log(&apos;开机自动启设置&apos;); &#125;); &#125; &#125;);&#125; 执行完程序之后，再看注册表，发现我们程序的路径已经写进去了： 然后电脑重启后你的程序就自动启动了。 3.托盘关闭向qq和微信一样，有的时候我们并不想让用户通过点关闭按钮的时候就关闭程序，而是把程序最小化到托盘，在托盘上做真正的退出操作。 首先要监听窗口的关闭事件，阻止用户关闭操作的默认行为。 1234mainWindow.on(&apos;close&apos;, (event) =&gt; &#123; mainWindow.hide(); event.preventDefault();&#125;); 然而这时你发现，这只是最小化了程序，任务栏里程序依然存在，我们需要让程序在任务栏里也消失： 12345mainWindow.on(&apos;close&apos;, (event) =&gt; &#123; mainWindow.hide(); mainWindow.setSkipTaskbar(true); event.preventDefault();&#125;); 这时程序就再也找不到了，任务托盘中也没有我们的程序，所以我们要先创建好任务托盘，并做好事件监听： 123456789101112131415161718function createTray() &#123; const mainWindow = BrowserWindow.fromId(global.mainId); tray = new Tray(path.join(global.__dirname, &apos;icon.ico&apos;)); const contextMenu = Menu.buildFromTemplate([ &#123; label: &apos;退出&apos;, click: () =&gt; &#123; mainWindow.destroy(); app.quit(); &#125; &#125;, ]) tray.setToolTip(&apos;我的客户端&apos;) tray.setContextMenu(contextMenu) tray.on(&apos;click&apos;, () =&gt; &#123; if (mainWindow.isVisible()) &#123; mainWindow.hide(); mainWindow.setSkipTaskbar(false); &#125; else &#123; mainWindow.show(); mainWindow.setSkipTaskbar(true); &#125; &#125;) &#125; 以上这些操作为我们的程序又增加了好几层的防护措施，我们的程序就不会那么轻而易举的挂掉啦！","categories":[],"tags":[{"name":"electron","slug":"electron","permalink":"https://www.lisq.xyz/tags/electron/"},{"name":"崩溃监控","slug":"崩溃监控","permalink":"https://www.lisq.xyz/tags/崩溃监控/"}]},{"title":"使用electron静默打印","slug":"使用electron静默打印","date":"2018-11-01T10:30:14.000Z","updated":"2018-11-07T12:13:02.582Z","comments":true,"path":"2018/11/01/使用electron静默打印/","link":"","permalink":"https://www.lisq.xyz/2018/11/01/使用electron静默打印/","excerpt":"","text":"1.使用electron打印的理由很多情况下程序中使用的打印都是用户无感知的。并且想要灵活的控制打印内容，往往需要借助打印机给我们提供的api再进行开发，这种开发方式非常繁琐，并且开发难度较大。 electron提供的打印api可以非常灵活的控制打印设置的显示，并且可以通过html来书写打印内容。 2.apielectron提供了两种方式进行打印，一种是直接调用打印机打印，一种是打印到pdf。 并且有两种对象可以调用打印： 第一是通过window的webcontent对象，使用此种方式需要单独开出一个打印的窗口，可以将该窗口隐藏，但是通信调用相对复杂。 另一种是使用页面的webview元素调用打印，可以将webview隐藏在调用的页面中，通信方式比较简单。 两个对象调用打印方法的使用方式都一样。 2.1 print官网api如下 123456789contents.print([options], [callback])选项 Object (可选)silent Boolean (可选) - 不询问用户打印信息，默认为 false。printBackground Boolean (optional) - Also prints the background color and image of the web page. Default is false.deviceName String (optional) - Set the printer device name to use. Default is &apos;&apos;.callback Function (可选)success Boolean - Indicates success of the print call. 打印配置(options)中只有简单的三个配置： silent：打印时是否不展示打印配置（是否静默打印） printBackground：是否打印背景 deviceName：打印机设备名称 首先要将我们使用的打印机名称配置好，并且要在调用打印前首先要判断打印机是否可用。 使用getPrinters方法可获取当前设备已经配置的打印机列表，注意配置过不是可用，只是在此设备上安装过驱动。 通过getprinter获取到的打印机对象：https://electronjs.org/docs/api/structures/printer-info 我们这里只管关心两个，name和status，status为0时表示打印机可用。 这里的status必须经历一次打印失败才能返回非0值，也就是说第一次获取打印机状态一定是0。但是这一次的打印虽然不能判断出错误，打印的任务已经预存在队列中了，当下一次打印机状态变为可用时，将会打印暂存的任务。 当打印机纸张用完时也是这种情况，剩余任务会暂存起来，下次打印机可用时即可以打印了。 print的第二个参数callback是用于判断打印任务是否发出的回调，而不是打印任务完成后的回调。所以一般打印任务发出，回调函数即会调用并返回参数true。这个回调并不能判断打印是否真的成功了。 2.2 printToPdf123456789101112contents.printToPDF(options, callback)选项 ObjectmarginsType Integer (optional) - Specifies the type of margins to use. Uses 0 for default margin, 1 for no margin, and 2 for minimum margin.pageSize String (optional) - Specify page size of the generated PDF. Can be A3, A4, A5, Legal, Letter, Tabloid or an Object containing height and width in microns.printBackground Boolean (optional) - Whether to print CSS backgrounds.printSelectionOnly Boolean (optional) - Whether to print selection only.landscape Boolean (optional) - true for landscape, false for portrait.callback Function - 回调函数error Errordata Buffer printToPdf的用法基本和print相同，但是由于print是native code提供的方法，配置项非常少，而printToPdf则扩展了很多属性。 包括可以对打印的margin，打印页眉页脚等进行配置。 配置项很多，翻了一下源码发现还有很多没有被贴进api的： 123456789101112131415161718192021222324252627const defaultPrintingSetting = &#123; pageRage: [], mediaSize: &#123;&#125;, landscape: false, color: 2, headerFooterEnabled: false, marginsType: 0, isFirstRequest: false, requestID: getNextId(), previewModifiable: true, printToPDF: true, printWithCloudPrint: false, printWithPrivet: false, printWithExtension: false, deviceName: &apos;Save as PDF&apos;, generateDraftData: true, fitToPageEnabled: false, scaleFactor: 1, dpiHorizontal: 72, dpiVertical: 72, rasterizePDF: false, duplex: 0, copies: 1, collate: true, shouldPrintBackgrounds: false, shouldPrintSelectionOnly: false&#125; 3.打印边距问题打印的时候打印机会给纸张留一个默认边距，如果是A4这样的纸张几乎可以忽略不计了，但是打印小规格纸张如50mm*50mm，这个边距就十分明显了，严重影响了整体布局。 printToPdf方法提供了非常多的配置项，其中包括了配置打印边距的参数，但是print方法却没有该配置项。 我们可以通过一项css配置来解决这个问题,即12 @page { margin: 0px; } 12345678910111213141516171819通过此配置可灵活配置打印边距。还有一个css属性``` @media print &#123;&#125;``` 此配置是只有在打印时才生效的css，控制的是打印边距以内的css，并不能控制打印边距。# 4.打印方案使用webcontent打印，首先要有一个打印窗口，这个窗口不能随时打印随时创建，比较耗费性能。可以将它在程序运行时启动好，并做好事件监听。此过程需和调用打印的进行做好通信：大致过程如下：![image](http://on-img.com/chart_image/5badf135e4b0fe81b64ad7b9.png)可见通信非常繁琐使用webview进行打印可实现同样的效果但是通信方式会变得简单，因为渲染进程和webview通信不需要经过主进程，通过如下方式即可： // In embedder page. const webview = document.querySelector(‘webview’) webview.addEventListener(‘ipc-message’, (event) =&gt; { console.log(event.channel) // Prints “pong” }) webview.send(‘ping’)Copy123456```// 在访客页。 const &#123;ipcRenderer&#125; = require(&apos;electron&apos;) ipcRenderer.on(&apos;ping&apos;, () =&gt; &#123; ipcRenderer.sendToHost(&apos;pong&apos;) &#125;) 5.示例程序示例demo：https://github.com/ConardLi/electron-print-demo","categories":[],"tags":[{"name":"electron","slug":"electron","permalink":"https://www.lisq.xyz/tags/electron/"},{"name":"打印","slug":"打印","permalink":"https://www.lisq.xyz/tags/打印/"}]},{"title":"【前端面试】ajax","slug":"【前端面试】ajax","date":"2018-03-18T08:49:06.000Z","updated":"2018-11-26T08:52:38.541Z","comments":true,"path":"2018/03/18/【前端面试】ajax/","link":"","permalink":"https://www.lisq.xyz/2018/03/18/【前端面试】ajax/","excerpt":"","text":"1.题目 手动编写一个ajax，不依赖第三方库 jquery 几种ajax的区别 跨域的几种实现方式 http://blog.csdn.net/zqjflash/article/details/50179235 2.知识点2.1 原生jaxa写法及参数说明123456789101112131415161718var xhr = new XMLHttpRequest();xhr.open('get',url,true)xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4 )&#123; if(xhr.status === 200)&#123; console.log(xhr.responseText); console.log(JSON.parse(xhr.responseText)) &#125; &#125;&#125;xhr.send();//oAjax.readyState //浏览器和服务器，进行到哪一步了。//0-&gt;（未初始化）：还没有调用 open() 方法。//1-&gt;（载入）：已调用 send() 方法，正在发送请求。//2-&gt;载入完成）：send() 方法完成，已收到全部响应内容。//3-&gt;（解析）：正在解析响应内容。//4-&gt;（完成）：响应内容解析完成，可以在客户端调用。 post写法 1234567891011121314//post提交的数据postData = &#123;\"name1\":\"value1\",\"name2\":\"value2\"&#125;;//这里需要将json数据转成post能够进行提交的字符串 name1=value1&amp;name2=value2格式postData = (function(value)&#123; for(var key in value)&#123; oStr += key+\"=\"+value[key]+\"&amp;\"; &#125;; return oStr;&#125;(postData));//post相比get方式提交多了个这个oAjax.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");//post发送数据oAjax.send(postData); IE低版本 ActiveObject 2.3 跨域https://juejin.im/post/5815f4abbf22ec006893b431 浏览器有同源策略，不允许ajax访问其他域的接口 跨域条件：协议，域名，端口，有一个不同就算跨域 可以跨域的三个标签： 123&lt;img src=xxx&gt;&lt;link href=xxx&gt;&lt;script src=xxx&gt; 1.服务端解决跨域(增加请求头) 12345678app.all('*', function (req, res, next) &#123; res.header(\"Access-Control-Allow-Origin\", \"*\"); res.header(\"Access-Control-Allow-Headers\", \"X-Requested-With\"); res.header(\"Access-Control-Allow-Methods\", \"PUT,POST,GET,DELETE,OPTIONS\"); res.header(\"X-Powered-By\", ' 3.2.1'); res.header(\"Content-Type\", \"application/json;charset=utf-8\"); next();&#125;); 2.4 jsonp 原理浏览器有同源策略，不允许从一个源加载的文件或脚本与另一个源加载的文件或脚本进行交互。 包括：cookie localstorage dom ajax 跨域条件：协议，域名，端口，有一个不同就算跨域 ajax请求受同源策略影响，不允许进行跨域请求，而script标签src属性中的链接却可以访问跨域的js脚本，利用这个特性，服务端不再返回JSON格式的数据，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。 原生jsonp实现： 服务：123var r = JSON.stringify( &#123; a: &#123; id: 1, name: \"test\" &#125;, b: &#123; id: 2, name: \"test\" &#125; &#125;);r = `doo($&#123;r&#125;)`res.send(r) 调用：12345678function doo (data)&#123; console.log(data);&#125;document.addEventListener('DOMContentLoaded', function () &#123; var script = document.createElement('script'); script.setAttribute('src', 'http://127.0.0.1:3001/devices'); document.body.appendChild(script);&#125;); 1234567891011121314151617181920212223242526272829303132333435(function (window,document) &#123; \"use strict\"; var jsonp = function (url,data,callback) &#123; // 1.将传入的data数据转化为url字符串形式 // &#123;id:1,name:'zhangsan'&#125; =&gt; id=1&amp;name=zhangsan var dataString = url.indexof('?') == -1? '?': '&amp;'; for(var key in data)&#123; dataString += key + '=' + data[key] + '&amp;'; &#125;; // 2 处理url中的回调函数 // cbFuncName回调函数的名字 ：my_json_cb_名字的前缀 + 随机数（把小数点去掉） var cbFuncName = 'my_json_cb_' + Math.random().toString().replace('.',''); dataString += 'callback=' + cbFuncName; // 3.创建一个script标签并插入到页面中 var scriptEle = document.createElement('script'); scriptEle.src = url + dataString; // 4.挂载回调函数 window[cbFuncName] = function (data) &#123; callback(data); // 处理完回调函数的数据之后，删除jsonp的script标签 document.body.removeChild(scriptEle); &#125; // 5.append到页面中 document.body.appendChild(scriptEle); &#125; // 因为jsonp是一个私有函数外部不能调用，所有jsonp函数作文window对象的一个方法，供外部调用 window.$jsonp = jsonp;&#125;)(window,document) jquery jsonp实现： 123456789101112 $.ajax(&#123; type : \"get\", async: false, url : \"http://127.0.0.1:3001/devices?t=\"+new Date(), dataType: \"jsonp\", jsonp:\"callback\", //请求php的参数名 jsonpCallback: \"doo\",//要执行的回调函数 success : function(data) &#123; console.log(data); &#125; &#125;);5 2.5 postMessage跨域1234567891011//捕获iframevar domain = 'http://scriptandstyle.com';var iframe = document.getElementById('myIFrame').contentWindow;//发送消息setInterval(function()&#123; var message = 'Hello! The time is: ' + (new Date().getTime()); console.log('blog.local: sending message: ' + message); //send the message and target URI iframe.postMessage(message,domain); &#125;,6000); 123456//响应事件window.addEventListener('message',function(event) &#123; if(event.origin !== 'http://davidwalsh.name') return; console.log('message received: ' + event.data,event); event.source.postMessage('holla back youngin!',event.origin);&#125;,false); 2.6 WebSocket1234567891011121314151617181920212223242526272829303132333435function WebSocketTest()&#123; if (\"WebSocket\" in window) &#123; alert(\"您的浏览器支持 WebSocket!\"); // 打开一个 web socket var ws = new WebSocket(\"ws://localhost:9998/echo\"); ws.onopen = function() &#123; // Web Socket 已连接上，使用 send() 方法发送数据 ws.send(\"发送数据\"); alert(\"数据发送中...\"); &#125;; ws.onmessage = function (evt) &#123; var received_msg = evt.data; alert(\"数据已接收...\"); &#125;; ws.onclose = function() &#123; // 关闭 websocket alert(\"连接已关闭...\"); &#125;; &#125; else &#123; // 浏览器不支持 WebSocket alert(\"您的浏览器不支持 WebSocket!\"); &#125;&#125; 2.7 hash跨域3 题目解答3.1 jquery对ajxax封装3.1.1 $.ajax1jQuery.ajax([settings]) 重要参数： url 类型：String 默认值: 当前页地址。发送请求的地址。 type 类型：String 默认值: “GET”)。请求方式 (“POST” 或 “GET”)， 默认为 “GET”。注意：其它 HTTP 请求方法，如 PUT 和 DELETE 也可以使用，但仅部分浏览器支持。 timeout 类型：Number 设置请求超时时间（毫秒）。此设置将覆盖全局设置。 success 类型：Function 请求成功后的回调函数。 jsonp，jsonpCallback error 类型：Function 默认值: 自动判断 (xml 或 html)。请求失败时调用此函数。 dataType 类型：String 123456&quot;xml&quot;: 返回 XML 文档，可用 jQuery 处理。&quot;html&quot;: 返回纯文本 HTML 信息；包含的 script 标签会在插入 dom 时执行。&quot;script&quot;: 返回纯文本 JavaScript 代码。不会自动缓存结果。除非设置了 &quot;cache&quot; 参数。注意：在远程请求时(不在同一个域下)，所有 POST 请求都将转为 GET 请求。（因为将使用 DOM 的 script标签来加载）&quot;json&quot;: 返回 JSON 数据 。&quot;jsonp&quot;: JSONP 格式。使用 JSONP 形式调用函数时，如 &quot;myurl?callback=?&quot; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。&quot;text&quot;: 返回纯文本字符串 data 类型：String 使用JSON.stringify转码 complete(XHR, TS) 类型：Function 请求完成后回调函数 (请求成功或失败之后均调用)。 async 类型：Boolean 默认值: true。默认设置下，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为 false。 contentType 类型：String 默认值: “application/x-www-form-urlencoded”。发送信息至服务器时内容编码类型。 键值对这样组织在一般的情况下是没有什么问题的，这里说的一般是，不带嵌套类型JSON，也就是 简单的JSON，形如这样： 12345&#123; a: 1, b: 2, c: 3&#125; 但是在一些复杂的情况下就有问题了。 例如在 ajax 中你要传一个复杂的 json 对像，也就说是对象嵌数组，数组中包括对象，你这样传： application/x-www-form-urlencoded 这种形式是没有办法将复杂的 JSON 组织成键值对形式 1234567&#123; data: &#123; a: [&#123; x: 2 &#125;] &#125;&#125; 可以用如下方式传递复杂的json对象 12345$.ajax(&#123; dataType: 'json', contentType: 'application/json', data: JSON.stringify(&#123;a: [&#123;b:1, a:1&#125;]&#125;)&#125;) 3.1.2 $.get和$.post12$(selector).get(url,data,success(response,status,xhr),dataType)jQuery.post(url,data,success(data, textStatus, jqXHR),dataType) url 必需。规定将请求发送的哪个 URL。 data 可选。规定连同请求发送到服务器的数据。 success(response,status,xhr) 可选。规定当请求成功时运行的函数。额外的参数：response - 包含来自请求的结果数据status - 包含请求的状态xhr - 包含 XMLHttpRequest 对象 dataType 可选。规定预计的服务器响应的数据类型。 请求数据和返回数据都可以直接使用JS对象。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.lisq.xyz/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://www.lisq.xyz/tags/基础/"},{"name":"面试","slug":"面试","permalink":"https://www.lisq.xyz/tags/面试/"},{"name":"ajax","slug":"ajax","permalink":"https://www.lisq.xyz/tags/ajax/"}]},{"title":"【前端面试】事件绑定","slug":"【前端面试】事件绑定","date":"2018-03-14T15:26:44.000Z","updated":"2018-11-23T08:54:33.696Z","comments":true,"path":"2018/03/14/【前端面试】事件绑定/","link":"","permalink":"https://www.lisq.xyz/2018/03/14/【前端面试】事件绑定/","excerpt":"","text":"1. 题目编写一个通用的事件监听函数 描述事件冒泡流程 对于一个无限下拉加载图片的页面，如何给每个图片加载页面 2. 知识点2.1 事件绑定1e.preventDefault() //阻止默认事件 ie低版本使用attachEvent,和W3C标准不一样 2.2 事件冒泡向上冒泡 p–div–body 123456789101112&lt;body&gt; &lt;div id=\"div1\"&gt; &lt;p id=\"p1\"&gt;激活&lt;/p&gt; &lt;p id=\"p2\"&gt;取消&lt;/p&gt; &lt;p id=\"p3\"&gt;取消&lt;/p&gt; &lt;p id=\"p4\"&gt;取消&lt;/p&gt; &lt;/div&gt; &lt;div id=\"div2\"&gt; &lt;p id=\"p5\"&gt;取消&lt;/p&gt; &lt;p id=\"p6\"&gt;取消&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 实现：点击激活弹出激活，点击取消弹出取消 1234567891011document.addEventListener('DOMContentLoaded', function () &#123; var p1 = document.getElementById('p1'); var body = document.body; p1.onclick = function (e) &#123; e.stopPropagation() alert('激活') &#125; body.onclick = function () &#123; alert('取消') &#125;&#125;); e.stopPropagation() : 阻止事件冒泡 2.3 事件代理会随时新增p标签，如何绑定事件 1234&lt;div id=\"div1\"&gt; &lt;p id=\"p1\" class=\"p1\"&gt;激活&lt;/p&gt; &lt;p id=\"p1\" class=\"p1\"&gt;激活&lt;/p&gt;&lt;/div&gt; 将事件代理给上一层，然后再判断 123456789101112131415document.addEventListener('DOMContentLoaded', function () &#123; var div1 = document.getElementById('div1'); div1.onclick = function(e)&#123; var p = document.createElement('p'); p.setAttribute('class','p1'); p.innerText = '激活'; div1.appendChild(p); // if(e.target.nodeName === 'P')&#123; // alert('事件绑定成功'); // &#125; if(e.target.getAttribute('class') === 'p1')&#123; alert('事件绑定成功'); &#125; &#125;&#125;); 2.4 dom事件级别1234567dom0 element.onclick = function()&#123;&#125;dom1标准没有跟事件相关的东西dom2 element.addEventListener('click',function()&#123;&#125;)dom3 element.addEventListener('keyup',function()&#123;&#125;) //增加了事件类型 2.5 dom事件模型是什么冒泡型事件处理模型（Bubbling） 如上图所示，冒泡型事件处理模型在事件发生时，首先在最精确的元素上触发，然后向上传播，直到根节点。反映到DOM树上就是事件从叶子节点传播到根节点。 捕获型事件处理模型（Captrue） 相反地，捕获型在事件发生时首先在最顶级的元素上触发，传播到最低级的元素上。在DOM树上的表现就是由根节点传播到叶子节点。 12document.getElementById(\"myBtn\").addEventListener(\"click\", myFunction,true);//第三个参数设置是否冒泡，默认冒泡值为true，捕获值为false 2.6 dom事件流 “DOM2级事件”规定的事件流包括三个阶段： ① 事件捕获阶段； ② 处于目标阶段； ③ 事件冒泡阶段； 2.7 描述dom事件捕获的具体流程 上图的最上级还有一级window 123456789101112131415161718192021222324252627282930313233window.onload = function()&#123; var oBtn = document.getElementById('btn'); oBtn.addEventListener('click',function()&#123; console.log('btn处于事件捕获阶段'); &#125;, true); oBtn.addEventListener('click',function()&#123; console.log('btn处于事件冒泡阶段'); &#125;, false); document.addEventListener('click',function()&#123; console.log('document处于事件捕获阶段'); &#125;, true); document.addEventListener('click',function()&#123; console.log('document处于事件冒泡阶段'); &#125;, false); document.documentElement.addEventListener('click',function()&#123; console.log('html处于事件捕获阶段'); &#125;, true); document.documentElement.addEventListener('click',function()&#123; console.log('html处于事件冒泡阶段'); &#125;, false); document.body.addEventListener('click',function()&#123; console.log('body处于事件捕获阶段'); &#125;, true); document.body.addEventListener('click',function()&#123; console.log('body处于事件冒泡阶段'); &#125;, false); &#125;; document、documentElement和document.body三者之间的关系： document代表的是整个html页面； document.documentElement代表的是标签； document.body代表的是标签； 2.8 event对象的常见应用123456event.preventDefault();//阻止默认行为 （阻止a标签跳转）event.stopPropagation();//阻止事件冒泡event.stopImmediatePropagation();//一个按钮绑定两个事件，阻止其他同级事件event.currentTarget;//当前绑定事件的元素event.target;//当前点击元素event.keyCode;//获取键盘值 2.9 自定义事件12345678//1、创建事件var clickElem = new Event(\"clickElem\");//2、注册事件监听器elem.addEventListener(\"clickElem\",function(e)&#123; //干点事&#125;)//3、触发事件elem.dispatchEvent(clickElem); 实际应用： 比如自己封装个ajax用法是这样的:1234567Ajax.open(…)Ajax.on(\"success\",function()&#123;//do&#125;)Ajax.on(\"error\",function()&#123;//do&#125;) 对于这样的用法在node异步编程中很多的，比如fs模块，http模块等。这个用法叫做事件发布/订阅，这是一种异步编程方法。 3.题目解答3.1 编写一个通用的事件监听函数123456789101112131415161718192021222324252627function addEvent(elem, type, selector, fn) &#123; if (!fn) &#123; fn = selector; selector = null; &#125; elem.addEventListener(type, function (e) &#123; if (selector) &#123; if (e.target.matches(selector)) &#123; fn.call(e.target, e); &#125; &#125; else &#123; fn(e); &#125; &#125;);&#125;$(function () &#123; var div1 = document.getElementById('div1'); var p1 = document.getElementById('p1'); //使用事件代理 addEvent(div1, 'click', '.p1', function () &#123; console.log(this); &#125;); //普通绑定 addEvent(p1, 'click', function (e) &#123; alert('普通绑定'); &#125;);&#125;) 1let result = element.matches(selectorString); result 的值为 true 或 false. selectorString 是个css选择器字符串. 1234document.getElementById('p1').addEventListener('click', function (e) &#123; console.log(this.matches('#p1')); console.log(e.target.matches('#p1'));&#125;) 3.2 描述事件冒泡流程按照dom树形结构往上一级冒泡。 触发元素事件 —》 触发元素父级事件 —》 再上级事件 阻止冒泡，不触发父级事件。1e.stopPropagation(); 3.3 无限下拉加载图片如何绑定事件使用事件代理 优点： 代码简介 减轻浏览器压力，提高性能","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.lisq.xyz/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://www.lisq.xyz/tags/基础/"},{"name":"面试","slug":"面试","permalink":"https://www.lisq.xyz/tags/面试/"},{"name":"事件","slug":"事件","permalink":"https://www.lisq.xyz/tags/事件/"}]},{"title":"【前端面试】dom和bom","slug":"【前端面试】dom和bom","date":"2018-03-02T08:18:10.000Z","updated":"2018-11-17T08:20:04.483Z","comments":true,"path":"2018/03/02/【前端面试】dom和bom/","link":"","permalink":"https://www.lisq.xyz/2018/03/02/【前端面试】dom和bom/","excerpt":"","text":"JavaScript语言 = ECMAScript标准（基础语法）+ W3C 标准（webapi） 1.题目1.dom是哪种基本的数据结构 2.dom操作的常用api 3.dom节点的attr和property的区别 4.如何检测浏览器类型 5.拆解url的各部分 2.知识点2.1 dom本质document object model dom可以理解为：浏览器把拿到的html代码，结构化一个浏览器能识别并且js可操作的一个模型。 2.2 获取dom节点123456var div1 = document.getElementById('div1');//元素var divList = document.getElementsByTagName('div'); //集合var divList2 = document.getElementsByClassName('d1'); //集合divList.length;divList[0];document.querySelectorAll('#div1'); //集合 2.3 querySelectorAllquerySelector 当用Document类型调用querySelector()方法时，会在文档元素范围内查找匹配的元素；而当用Element类型调用querySelector()方法时，只会在这个元素的后代元素中去查找匹配的元素。若不存在匹配的元素，则这两种类型调用该方法时，均返回null。 只返回一个dom节点 和querySelectorAll 当用Element类型调用querySelectorAll()方法时，只会在这个元素的后代中去查找匹配的Element对象。若不存在匹配的对象，则这Document和Element这两种类型调用该方法时，均返回一个空的NodeList对象。 返回一个dom节点集合 2.4 attribute和propertyattribute：只是dom节点的属性(html标签的属性)1234var o1 = document.getElementById('test'); console.log(o1.getAttribute('id')) o1.setAttribute('class','test2'); console.log(o1.getAttribute('class')) property：获取后JS对象的属性12var o1 = document.getElementById('test'); console.log(o1.innerText); 2.5 dom结构操作新增节点 1div1.appendChild(div2) 父节点子节点123var parent = div1.parentElementvar child = div1.childNodesdiv1.removeChild(child[0]) 2.6 bombrowser object model navigator 存浏览器的一些属性 123var ua = navigator.userAgent; var isChrome = ua.indexOf('Chrome'); console.log(isChrome); screen 12screen.availHeight //浏览器可用高度screen.height //屏幕高度 location 123456location.protocol//协议 http: location.host //域名 www.baidu.com location.pathname //pathnamel /search location.search //参数 ？cid=99 location.hash // #mid=100 location.href history 12history.back();history.forward(); 2.7 浏览器高度123456789101112131415161718网页可见区域宽： document.body.clientWidth; 网页可见区域高： document.body.clientHeight; (实际取值是整个浏览器的)网页可见区域宽： document.body.offsetWidth (包括边线的宽); 网页可见区域高： document.body.offsetHeight (包括边线的宽); (实际取值是整个浏览器的)网页正文全文宽： document.body.scrollWidth; 网页正文全文高： document.body.scrollHeight; 网页被卷去的高： document.body.scrollTop; 网页被卷去的左： document.body.scrollLeft; 屏幕分辨率的高： window.screen.height; 屏幕分辨率的宽： window.screen.width; 实际使用的文本可见高度：window.innerHeightdocument.documentElement.clientHeight 当浏览器滚动条拉到最底部时： 12网页正文全文高 = 网页被卷去的高 + 浏览器可用高度 document.body.scrollHeight = document.body.scrollTop + window.innerHeight 判断元素是否可视：1clientHeight - (element.offsetTop - getScrollTop()) &gt; 0 123456789101112131415什么是document.body？返回html dom中的body节点 即&lt;body&gt;什么是 document.documentElement？返回html dom中的root 节点 即&lt;html&gt;在HTML 中, body 是整个DOM 的根, 而在XHTML 中, document 才是根, body 不再是根, 所以取body 的属性时, 不能再取到整个页面的值.使用document.documentElement来取代document.body,兼容性写法例：var top = document.documentElement.scrollTop || document.body.scrollTop;在javascript里||是个好东西，除了能用在if等条件判断里，还能用在变量赋值上。那么上例等同于下例。 例：var top = document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop;这么写可以得到很好的兼容性。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.lisq.xyz/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://www.lisq.xyz/tags/基础/"},{"name":"面试","slug":"面试","permalink":"https://www.lisq.xyz/tags/面试/"},{"name":"dom","slug":"dom","permalink":"https://www.lisq.xyz/tags/dom/"}]},{"title":"【前端面试】数组和对象","slug":"【前端面试】数组和对象","date":"2018-02-26T10:43:23.000Z","updated":"2018-11-15T10:45:30.158Z","comments":true,"path":"2018/02/26/【前端面试】数组和对象/","link":"","permalink":"https://www.lisq.xyz/2018/02/26/【前端面试】数组和对象/","excerpt":"","text":"1. 题目获取 2017-06-10 格式的日期 获取随机数，要求是长度一致的字符串 写一个能便利对象和数组的通用forEach函数 2.知识点2.1 日期123456789var dt = new Date();console.log(dt);console.log(dt.getTime());log(dt.getFullYear());log(dt.getMonth()); //月份从0开始log(dt.getDate());log(dt.getHours());log(dt.getMinutes());log(dt.getSeconds()); 2.2 数组1var arr = [2,4,1,5,2,1,3]; 2.2.1.遍历所有123arr.forEach((item,index)=&gt;&#123; console.log(index,item);&#125;); 2.2.2.判断是否所有元素都复合条件every()当内部return false时跳出整个循环 判断数组中元素是否全小于2123456789var bool = arr.every((item)=&gt;&#123; if(item&gt;=2)&#123; return false; &#125;else&#123; return true; &#125;&#125;);console.log(bool); 2.2.3.是否至少一个元素复合条件some()当内部return true时跳出整个循环 判断数组中元素是否只要有一个大于等于8 12345678var bool = arr.some((item)=&gt;&#123; if(item&gt;=8)&#123; return true; &#125;&#125;);console.log(bool); 2.2.4.排序123456var arr2 = arr.sort((a,b)=&gt;&#123; // return a-b; //从小到大 return b-a; //从大到小&#125;); console.log(arr2); 2.2.5.对元素重新组装，生成新数组12345var arr2 = arr.map((item,index)=&gt;&#123; return item + index +'&lt;/br&gt;';&#125;); console.log(arr2); 2.2.6 api1234pop() 删除并返回数组的最后一个元素shift() 删除并返回数组的第一个元素push() 向数组的末尾添加一个或更多元素，并返回新的长度。unshift() 向数组的开头添加一个或更多元素，并返回新的长度。 6.过滤符合条件的元素12345var arr2 = arr.filter((item,index)=&gt;&#123; return item&gt;1;&#125;); console.log(arr2); 2.3 对象hasOwnProperty() 过滤原型链上的属性（高版本浏览器已经不需要使用它了） 3. 题目解答3.1 获取 2017-06-10 格式的日期123456789101112131415function formatDate(dt = new Date(),format = '-')&#123; var year = dt.getFullYear() var month = dt.getMonth() +1; var date = dt.getDate(); if(month&lt;10)&#123; month = '0' + month; &#125; if(date &lt; 10)&#123; date = '0' + date; &#125; return year + format + month + format + date;&#125;var dt = formatDate(new Date(),'/');console.log(dt); 3.2 获取随机数，要求是长度一致的字符串1234var r = Math.random();r = r + '0000000000';r = r.slice(0,11);console.log(r); 3.3 写一个能便利对象和数组的通用forEach函数1234567891011121314151617181920212223function forEach(obj,fn)&#123; var key; if(obj instanceof Array)&#123; obj.forEach(function(item,index)&#123; fn(index,item); &#125;) &#125;else&#123; for(key in obj)&#123; fn(key,obj[key]); &#125; &#125;&#125;var arr = [1,23,3];forEach(arr,function(index,item)&#123; console.log(index,item)&#125;);var obj = &#123;x:100,y:200&#125;forEach(obj,function(key,value)&#123; console.log(key,obj[key]);&#125;); 3.4 slice和splice的区别slice定义和用法 slice() 方法可从已有的数组中返回选定的元素。123arrayObject.slice(start,end)start 必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。end 可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。 返回值返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。请注意，该方法并不会修改数组，而是返回一个子数组。如果想删除数组中的一段元素，应该使用方法 Array.splice()。 1234var arr=[1,2,3,4,5,6];var arr2=arr.slice(2,4);console.log(\"arr2=\",arr2,\",arr=\",arr);//arr2= [3, 4] ,arr= [1, 2, 3, 4, 5, 6] splice定义和用法 splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。该方法会改变原始数组。1234arrayObject.splice(index,howmany,item1,.....,itemX)index 必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。howmany 必需。要删除的项目数量。如果设置为 0，则不会删除项目。item1, ..., itemX 可选。向数组添加的新项目。 返回值Array 包含被删除项目的新数组，如果有的话。 splice() 方法可删除从 index处开始的零个或多个元素，并且用参数列表中声明的一个或多个值来替换那些被删除的元素。如果从 arrayObject 中删除了元素，则返回的是含有被删除的元素的数组。提示和注释 请注意，splice() 方法与 slice() 方法的作用是不同的，splice() 方法会直接对数组进行修改。 1234567891011121314var arr = new Array(6)arr[0] = \"George\"arr[1] = \"John\"arr[2] = \"Thomas\"arr[3] = \"James\"arr[4] = \"Adrew\"arr[5] = \"Martin\"document.write(arr + \"&lt;br /&gt;\")document.write(arr.splice(2, 3, \"William\")+ \"&lt;br /&gt;\")document.write(arr)//George,John,Thomas,James,Adrew,Martin//Thomas,James,Adrew//George,John,William,Martin 3.5 深拷贝和浅拷贝浅复制：浅复制是复制引用，复制后的引用都是指向同一个对象的实例，彼此之间的操作会互相影响 深复制：深复制不是简单的复制引用，而是在堆中重新分配内存，并且把源对象实例的所有属性都进行新建复制，以保证深复制的对象的引用图不包含任何原有对象或对象图上的任何对象，复制后的对象与原来的对象是完全隔离的 方法11var target = JSON.parse(JSON.stringify(source)); 方法2 Array的slice和concat方法都会返回一个新的数组实例，但是这两个方法对于数组中的对象元素却没有执行深复制，而只是复制了引用了，因此这两个方法并不是真正的深复制，通过以下代码进行理解： 12345678var array = [1,2,3]; var array_shallow = array; var array_concat = array.concat(); var array_slice = array.slice(0); console.log(array === array_shallow); //true console.log(array === array_slice); //false console.log(array === array_concat); //false 手动实现：递归 12345678910111213141516171819function copy(obj,deep)&#123; //如果obj不是对象，那么直接返回值就可以了 if(obj === null typeof obj !== \"object\")&#123; return obj; &#125; //定义需要的局部变脸，根据obj的类型来调整target的类型 var i, target = util.isType(obj,\"array\") ? [] : &#123;&#125;,value,valueType; for(i in obj)&#123; value = obj[i]; valueType = util.getType(value); //只有在明确执行深复制，并且当前的value是数组或对象的情况下才执行递归复制 if(deep &amp;&amp; (valueType === \"array\" valueType === \"object\"))&#123; target[i] = copy(value); &#125;else&#123; target[i] = value; &#125; &#125; return target;&#125; sort方法底层原理V8 引擎 sort 函数只给出了两种排序 InsertionSort 和 QuickSort，数量小于10的数组使用 InsertionSort，比10大的数组则使用 QuickSort。 通过判断comparefn(a,b)来决定顺序; 快排：该值大于0左侧放小数右侧放大数 插入排序：该值大于0左侧有序数列按从小到大排列。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.lisq.xyz/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://www.lisq.xyz/tags/基础/"},{"name":"面试","slug":"面试","permalink":"https://www.lisq.xyz/tags/面试/"}]},{"title":"webworker","slug":"webworker","date":"2018-02-07T15:38:55.000Z","updated":"2018-11-15T10:46:48.576Z","comments":true,"path":"2018/02/07/webworker/","link":"","permalink":"https://www.lisq.xyz/2018/02/07/webworker/","excerpt":"","text":"假异步上面的文章得出，js使用event loop在单线程状态下实现了一个”假”异步。 即等同步代码执行完在执行异步代码，可模拟不阻塞的效果。 比如使用settimeout或者promise同时执行两个耗时任务： 12345678910setTimeout(() =&gt; &#123; for (let index = 0; index &lt; 100; index++) &#123; console.log(index); &#125;&#125;, 0);setTimeout(() =&gt; &#123; for (let index = 0; index &lt; 100; index++) &#123; console.log(index); &#125;&#125;, 0); 123456789101112131415new Promise(resolve =&gt; &#123; resolve();&#125;).then((val) =&gt; &#123; for (let index = 0; index &lt; 100; index++) &#123; console.log(index); &#125;&#125;)new Promise(resolve =&gt; &#123; resolve();&#125;).then((val) =&gt; &#123; for (let index = 0; index &lt; 100; index++) &#123; console.log(index); &#125;&#125;) 两者的效果是相同的，两次1-100的打印不能并发进行。 webworkerWeb Worker 是HTML5标准的一部分，这一规范定义了一套 API，它允许一段JavaScript程序运行在主线程之外的另外一个线程中。工作线程允许开发人员编写能够长时间运行而不被用户所中断的后台程序， 去执行事务或者逻辑，并同时保证页面对用户的及时响应，可以将一些大量计算的代码交给web worker运行而不冻结用户界面 12345//webworker.jsfor (let index = 0; index &lt; 100000; index++) &#123; console.log(index);&#125; 12var worker = new Worker(\"webworker.js\");var worker2 = new Worker(\"webworker.js\"); 耗时任务可以同时进行。 终止1234567// 方式一 main.js 在主线程停止方式 var worker = new Worker('./worker.js');...worker.terminate();// 方式二、worker.jsself.close() 通信12345678910111213141516171819//主线程 main.jsvar worker = new Worker(\"worker.js\");worker.onmessage = function(event)&#123; // 主线程收到子线程的消息&#125;;// 主线程向子线程发送消息worker.postMessage(&#123; type: \"start\", value: 12345&#125;);//web worker.jsonmessage = function(event)&#123; // 收到&#125;;postMessage(&#123; type: \"debug\", message: \"Starting processing...\"&#125;);","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.lisq.xyz/tags/javascript/"},{"name":"异步","slug":"异步","permalink":"https://www.lisq.xyz/tags/异步/"},{"name":"html5","slug":"html5","permalink":"https://www.lisq.xyz/tags/html5/"}]},{"title":"async-await","slug":"async-await","date":"2018-02-06T12:31:09.000Z","updated":"2018-11-12T12:34:05.115Z","comments":true,"path":"2018/02/06/async-await/","link":"","permalink":"https://www.lisq.xyz/2018/02/06/async-await/","excerpt":"","text":"基本用法async 表示这是一个async函数，await只能用在这个函数里面。 await 表示在这里等待promise返回结果了，再继续执行。 await 后面跟着的应该是一个promise对象（当然，其他返回值也没关系，只是会立即执行，不过那样就没有意义了…） 这里我们要实现一个暂停功能，输入N毫秒，则停顿N毫秒后才继续往下执行。 12345678910111213141516var sleep = function (time) &#123; return new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; resolve(); &#125;, time); &#125;)&#125;;var start = async function () &#123; // 在这里使用起来就像同步代码那样直观 console.log('start'); await sleep(3000); console.log('end');&#125;;start(); 返回值await等待的虽然是promise对象，但不必写.then(..)，直接可以得到返回值。 12345678910111213var sleep = function (time) &#123; return new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; // 返回 ‘ok’ resolve('ok'); &#125;, time); &#125;)&#125;;var start = async function () &#123; let result = await sleep(3000); console.log(result); // 收到 ‘ok’&#125;; 捕捉错误既然.then(..)不用写了，那么.catch(..)也不用写，可以直接用标准的try catch语法捕捉错误。 1234567891011121314151617181920var sleep = function (time) &#123; return new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; // 模拟出错了，返回 ‘error’ reject('error'); &#125;, time); &#125;)&#125;;var start = async function () &#123; try &#123; console.log('start'); await sleep(3000); // 这里得到了一个返回错误 // 所以以下代码不会被执行了 console.log('end'); &#125; catch (err) &#123; console.log(err); // 这里捕捉到错误 `error` &#125;&#125;; 这样做的好处是也可以捕获其他同步代码。 循环多个awaitawait看起来就像是同步代码，所以可以理所当然的写在for循环里，不必担心以往需要闭包才能解决的问题。12345678910111213141516171819202122232425..省略以上代码var start = async function () &#123; for (var i = 1; i &lt;= 10; i++) &#123; console.log(`当前是第$&#123;i&#125;次等待..`); await sleep(1000); &#125;&#125;;值得注意的是，await必须在async函数的上下文中的。..省略以上代码let 一到十 = [1,2,3,4,5,6,7,8,9,10];// 错误示范一到十.forEach(function (v) &#123; console.log(`当前是第$&#123;v&#125;次等待..`); await sleep(1000); // 错误!! await只能在async函数中运行&#125;);// 正确示范for(var v of 一到十) &#123; console.log(`当前是第$&#123;v&#125;次等待..`); await sleep(1000); // 正确, for循环的上下文还在async函数中&#125; 第二个例子这个例子是一个小应用，根据电影文件名，自动下载对应的海报。 直接贴出代码，就不说明了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import fs from 'fs';import path from 'path';import request from 'request';var movieDir = __dirname + '/movies', exts = ['.mkv', '.avi', '.mp4', '.rm', '.rmvb', '.wmv'];// 读取文件列表var readFiles = function () &#123; return new Promise(function (resolve, reject) &#123; fs.readdir(movieDir, function (err, files) &#123; resolve(files.filter((v) =&gt; exts.includes(path.parse(v).ext))); &#125;); &#125;);&#125;;// 获取海报var getPoster = function (movieName) &#123; let url = `https://api.douban.com/v2/movie/search?q=$&#123;encodeURI(movieName)&#125;`; return new Promise(function (resolve, reject) &#123; request(&#123;url: url, json: true&#125;, function (error, response, body) &#123; if (error) return reject(error); resolve(body.subjects[0].images.large); &#125;) &#125;);&#125;;// 保存海报var savePoster = function (movieName, url) &#123; request.get(url).pipe(fs.createWriteStream(path.join(movieDir, movieName + '.jpg')));&#125;;(async () =&gt; &#123; let files = await readFiles(); // await只能使用在原生语法 for (var file of files) &#123; let name = path.parse(file).name; console.log(`正在获取【$&#123;name&#125;】的海报`); savePoster(name, await getPoster(name)); &#125; console.log('=== 获取海报完成 ===');&#125;)();","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.lisq.xyz/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://www.lisq.xyz/tags/基础/"},{"name":"面试","slug":"面试","permalink":"https://www.lisq.xyz/tags/面试/"},{"name":"async","slug":"async","permalink":"https://www.lisq.xyz/tags/async/"},{"name":"es7","slug":"es7","permalink":"https://www.lisq.xyz/tags/es7/"},{"name":"异步","slug":"异步","permalink":"https://www.lisq.xyz/tags/异步/"}]},{"title":"promise","slug":"promise","date":"2018-01-29T09:18:05.000Z","updated":"2018-11-11T09:21:13.641Z","comments":true,"path":"2018/01/29/promise/","link":"","permalink":"https://www.lisq.xyz/2018/01/29/promise/","excerpt":"","text":"概念主要用于异步计算 可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果。 promise是一个代理对象，他和原先要进行的操作并无关系。 他通过引入一个回调，避免其他回调。 三个状态： pending【待定】初始状态 fulfilled【实现】操作成功 rejected【被否决】操作失败 promise状态改变，就会出发.then里的响应函数处理后续步骤 promise状态改变以后不会再改变。 回调的问题嵌套层次很深，难以维护 无法使用return 多个回调之间难以建立联系 简单实例1234567891011121314new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve('第一次输出'); &#125;, 1500);&#125;).then(value =&gt; &#123; console.log(value); return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve('第二次输出'); &#125;, 1500); &#125;)&#125;).then(value =&gt;&#123; console.log(value);&#125;) 在任何一个地方声明promise 在后面可以追寻任意多的then，会按照队列的顺序执行，如果promise已经完成再then那么还会得到结果。 在then函数中不直接返回promise123456789101112131415161718192021new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve('hello'); &#125;, 2000);&#125;) .then(value =&gt; &#123; console.log(value); console.log('everyone'); (function () &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log('Mr.Laurence'); resolve('Merry Xmas'); &#125;, 2000); &#125;); &#125;()); return false; &#125;) .then(value =&gt; &#123; console.log(value + ' world'); &#125;); 如果不直接返回promise实例，他就会默认去执行下一个环节。 then函数then接受两个函数作为函数，分别代表fulfilled和rejected then返回一个新的peomise实例，所以它可以链式调用 当前面的peomise状态改变，then根据其最终状态，选择特定的状态响应函数执行。 状态相应函数可以返回新的promise或者其他值。 如果返回新的promise，那么下一级.then会在新promise状态改变后执行 如果返回其他任何值，则会立即执行下一级then then嵌套当then函数中嵌套了then，会先将嵌套里面的then执行完毕，再去执行外面的then。 1234567891011121314151617181920212223242526new Promise( resolve =&gt; &#123; console.log('Step 1'); setTimeout(() =&gt; &#123; resolve(100); &#125;, 1000);&#125;) .then( value =&gt; &#123; return new Promise(resolve =&gt; &#123; console.log('Step 1-1'); setTimeout(() =&gt; &#123; resolve(110); &#125;, 1000); &#125;) .then( value =&gt; &#123; console.log('Step 1-2'); return value; &#125;) .then( value =&gt; &#123; console.log('Step 1-3'); return value; &#125;); &#125;) .then(value =&gt; &#123; console.log(value); console.log('Step 2'); &#125;); 错误处理promise会自动捕获内部异常，并交给rejected函数处理 错误处理的两种做法： 123456789101112new Promise( resolve =&gt; &#123; setTimeout( () =&gt; &#123; throw new Error('bye'); &#125;, 2000);&#125;) .then( value =&gt; &#123; console.log( value + ' world'); &#125;) .catch( error =&gt; &#123; console.log( 'Error：', error.message); &#125;); catch可以捕获之前所有then的错误。 12345678910new Promise( (resolve, reject) =&gt; &#123; setTimeout( () =&gt; &#123; reject('bye'); &#125;, 2000);&#125;) .then( value =&gt; &#123; console.log( value + ' world'); &#125;, value =&gt; &#123; console.log( 'Error：', value); &#125;); rejected只能捕获当前then的错误。 当catch函数后面再跟then时，后面还会执行。 强烈建议所有队列最后都加上catch，以便避免漏掉错误处理， promise.all参数为Promise对象数组，如果有不是Promise的对象，将会先通过上面的Promise.resolve()方法转换123456var promise = Promise.all( [p1, p2, p3] )promise.then( ...).catch( ...) 当p1、p2、p3的状态都变成resolved时，promise才会变成resolved，并调用then()的已完成回调，但只要有一个变成rejected状态，promise就会立刻变成rejected状态 promise.resolve返回一个fulfilled的promise实例，或原始promise实例 promise.reject返回一个rejected的实例 promise.race类似于promise.all ，区别在于他有一个实例完成就算完成。 回调包装成promise可读性好，返回结果可加入任意promise。 包装12345678910111213141516171819202122module.exports = &#123; readDir: function (path, options) &#123; return new Promise( resolve =&gt; &#123; fs.readdir(path, options, (err, files) =&gt; &#123; if (err) &#123; throw err; &#125; resolve(files); &#125;); &#125;); &#125;, readFile: function (path, options) &#123; return new Promise( resolve =&gt; &#123; fs.readFile(path, options, (err, content) =&gt; &#123; if (err) &#123; throw err; &#125; resolve(content); &#125;); &#125;); &#125;&#125;; 使用1234fs.readFile('../README.md', 'utf-8') .then(content =&gt; &#123; console.log(content); &#125;); 和map连用找到最大文件 异步读取文件列表，当所有文件列表读取完成执行then函数。12345678910111213141516171819202122232425262728function findLargest(dir) &#123; return FileSystem.readDir(dir, 'utf-8') .then( files =&gt; &#123; return Promise.all( files.map( file =&gt; &#123; return new Promise (resolve =&gt; &#123; fs.stat(path.join(dir, file), (err, stat) =&gt; &#123; if (err) throw err; if (stat.isDirectory()) &#123; return resolve(&#123; size: 0 &#125;); &#125; stat.file = file; resolve(stat); &#125;); &#125;); &#125;)); &#125;) .then( stats =&gt; &#123; let biggest = stats.reduce( (memo, stat) =&gt; &#123; if(memo.size &lt; stat.size) &#123; return stat; &#125; return memo; &#125;); return biggest.file; &#125;)&#125; ajax回调代替12345678910111213//例1function getUserId() &#123; return new Promise(function(resolve) &#123; //异步请求 http.get(url, function(results) &#123; resolve(results.id) &#125;) &#125;)&#125;getUserId().then(function(id) &#123; //一些处理&#125;) promise原理https://segmentfault.com/a/1190000009478377(1)12345678910111213141516function Promise(fn) &#123; var value = null, callbacks = []; //callbacks为数组，因为可能同时有很多个回调 this.then = function (onFulfilled) &#123; callbacks.push(onFulfilled); &#125;; function resolve(value) &#123; callbacks.forEach(function (callback) &#123; callback(value); &#125;); &#125; fn(resolve);&#125; (2) then resolve 回调 状态1234567891011121314151617181920212223242526function Promise(fn) &#123; var state = 'pending', value = null, callbacks = []; this.then = function (onFulfilled) &#123; if (state === 'pending') &#123; callbacks.push(onFulfilled); return this; &#125; onFulfilled(value); return this; &#125;; function resolve(newValue) &#123; value = newValue; state = 'fulfilled'; setTimeout(function () &#123; callbacks.forEach(function (callback) &#123; callback(value); &#125;); &#125;, 0); &#125; fn(resolve);&#125; (3)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function Promise(fn) &#123; var state = 'pending', value = null, callbacks = []; this.then = function (onFulfilled) &#123; return new Promise(function (resolve) &#123; handle(&#123; onFulfilled: onFulfilled || null, resolve: resolve &#125;); &#125;); &#125;; function handle(callback) &#123; if (state === 'pending') &#123; callbacks.push(callback); return; &#125; //如果then中没有传递任何东西 if(!callback.onFulfilled) &#123; callback.resolve(value); return; &#125; var ret = callback.onFulfilled(value); callback.resolve(ret); &#125; function resolve(newValue) &#123; if (newValue &amp;&amp; (typeof newValue === 'object' || typeof newValue === 'function')) &#123; var then = newValue.then; if (typeof then === 'function') &#123; then.call(newValue, resolve); return; &#125; &#125; state = 'fulfilled'; value = newValue; setTimeout(function () &#123; callbacks.forEach(function (callback) &#123; handle(callback); &#125;); &#125;, 0); &#125; fn(resolve);&#125;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.lisq.xyz/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://www.lisq.xyz/tags/基础/"},{"name":"面试","slug":"面试","permalink":"https://www.lisq.xyz/tags/面试/"},{"name":"异步","slug":"异步","permalink":"https://www.lisq.xyz/tags/异步/"},{"name":"promise","slug":"promise","permalink":"https://www.lisq.xyz/tags/promise/"},{"name":"es6","slug":"es6","permalink":"https://www.lisq.xyz/tags/es6/"}]},{"title":"【前端面试】异步和单线程","slug":"【前端面试】异步和单线程","date":"2018-01-22T12:56:02.000Z","updated":"2018-11-11T09:21:03.385Z","comments":true,"path":"2018/01/22/【前端面试】异步和单线程/","link":"","permalink":"https://www.lisq.xyz/2018/01/22/【前端面试】异步和单线程/","excerpt":"","text":"1.问题异步和同步的区别，分别举一个例子 一个关于settimeoit的比笔试题 前端使用异步的场景 2.知识点2.1 异步何时使用异步： 在可能发生等待的情况 使用异步的场景： 定时任务： settimeout 网络请求： ajax 动态img加载 事件绑定 2.2 单线程所有异步的代码都会暂存（任务队列）最后再执行。 3.问题解答3.1 异步和同步的区别，分别举一个例子同步会阻塞代码执行，异步不会 alert是同步，settimeout是异步 3.2 一个关于settimeoit的比笔试题123456789console.log(1);setTimeout(() =&gt; &#123; console.log(2);&#125;, 0);console.log(3);setTimeout(() =&gt; &#123; console.log(4);&#125;, 1000);console.log(5); 顺序 ：13524 3.3 前端使用异步的场景 定时任务： settimeout 网络请求： ajax 动态img加载 时间绑定 3.4 Event loop同步任务 –》 运行栈 –》 遇到异步任务 –》 暂存到临时队列中 –》 异步任务达到可以运行的时间 –》 放到任务队列中–》 运行栈中的任务执行完毕–》 在任务队列中取出可执行任务存入运行栈 –》 执行运行栈中的任务 –》 执行完毕…去任务队列查找任务… 3.5 事件队列高级1234567891011setTimeout(function()&#123;console.log(4)&#125;,0);new Promise(function(resolve)&#123; console.log(1) for( var i=0 ; i&lt;10000 ; i++ )&#123; i==9999 &amp;&amp; resolve() &#125; console.log(2)&#125;).then(function()&#123; console.log(5)&#125;);console.log(3); 执行顺序 11,2,3,5,4 由于整个 script 也属于一个 macrotask, 由于会先执行 macrotask 中的第一个任务，再加上promise 构造函数因为是同步的，所以会先打印出 1和2然后继续同步执行末尾的 console.log(3) 打印出3 此时 setTimeout 被推进到 macrotask 队列中， promise.then 回调被推进到 microtask 队列中 由于在第一步中已经执行完了第一个 macrotask , 所以接下来会顺序执行所有的 microtask, 也就是 promise.then 的回调函数，从而打印出5 microtask 队列中的任务已经执行完毕，继续执行剩下的 macrotask 队列中的任务，也就是 setTimeout, 所以打印出 4","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.lisq.xyz/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://www.lisq.xyz/tags/基础/"},{"name":"面试","slug":"面试","permalink":"https://www.lisq.xyz/tags/面试/"},{"name":"异步","slug":"异步","permalink":"https://www.lisq.xyz/tags/异步/"}]},{"title":"【前端面试】作用域和闭包","slug":"【前端面试】作用域和闭包","date":"2018-01-20T14:24:59.000Z","updated":"2018-11-09T14:34:46.555Z","comments":true,"path":"2018/01/20/【前端面试】作用域和闭包/","link":"","permalink":"https://www.lisq.xyz/2018/01/20/【前端面试】作用域和闭包/","excerpt":"","text":"1. 题目说一下对变量提升的理解 说明this的几种不同使用场景 创建10个a标签，点击的时候弹出来相应的序号 如何理解作用域 实际开发中闭包的应用 2. 知识点2.1 执行上下文范围：一段script或者一个函数 全局：变量定义、函数声明 script 函数：变量定义、函数声明、this、arguments （执行之前） 函数声明和函数表达式的区别： 12345a(); //报错 函数表达式 变量声明 会提前。var a = function()&#123;&#125;b(); // 不报错 函数声明function b()&#123;&#125; 变量定义时会默认把他的变量声明提升：(仅限于他的执行上下文，比如一段script和一个函数中) 12console.log(a);var a = 0; 实际上是 123var a;console.log(a);a = 0; 2.2 thisthis要在执行时才能确认，定义时无法确认。 1234567891011var a = &#123; name:'a', fn:function()&#123; console.log(this.name); &#125;&#125;a.fn(); // aa.fn.apply(&#123;name:'b'&#125;); // b a.fn.call(&#123;name:'b'&#125;);var fn1 = a.fn();fn1(); // undefined this的使用场景 构造函数中（指向构造的对象） 12345function Fun(name)&#123; this.name = name;&#125;var f = new Fun('a');console.log(f.name); 对象属性中（指向该对象） 普通函数中（指向window） call apply bind 12345var fun = function (name)&#123; console.log(this); console.log(name);&#125;.bind(&#123;a:1&#125;);fun(\"name\"); arguments中的this：12345678910var length = 10;function fn()&#123; alert(this.length)&#125;var obj = &#123; length: 5, method: function(fn) &#123; arguments[0]() &#125;&#125; obj.method(fn)//输出1这里没有输出5，也没有输出10，反而输出了1，有趣。这里arguments是javascript的一个内置对象（可以参见mdn：arguments - JavaScript），是一个类数组（就是长的比较像数组，但是欠缺一些数组的方法，可以用slice.call转换，具体参见上面的链接），其存储的是函数的参数。也就是说，这里arguments[0]指代的就是你method函数的第一个参数：fn，所以arguments0的意思就是：fn()。 不过这里有个疑问，为何这里没有输出5呢？我method里面用this，不应该指向obj么，至少也会输出10呀，这个1是闹哪样？ 实际上，这个1就是arguments.length，也就是本函数参数的个数。为啥这里的this指向了arguments呢？因为在Javascript里，数组只不过使用数字做属性名的方法，也就是说：arguments0的意思，和arguments.0()的意思差不多（当然这么写是不允许的），你更可以这么理解：1234567arguments = &#123; 0: fn, //也就是 functon() &#123;alert(this.length)&#125; 1: 第二个参数, //没有 2: 第三个参数, //没有 ..., length: 1 //只有一个参数&#125; 所以这里alert出来的结果是1。 如果要输出5应该咋写呢？直接 method: fn 就行了。 2.3 作用域没有块级作用域 1234if(true)&#123; var name = \"test\"&#125;console.log(name); 尽量不要在块中声明变量。 只有函数级作用域 2.4 作用域链自由变量 当前作用域没有定义的变量 即为自由变量。 自由变量会去其父级作用域找。是定义时的父级作用域，而不是执行。 123456789101112var a = 100;function f1()&#123; var b = 200; function f2()&#123; var c = 300; console.log(a); //自由变量 console.log(b); //自由变量 console.log(c); &#125; f2();&#125;;f1(); 2.5 闭包 一个函数中嵌套另外一个函数，并且将这个函数return出去，然后将这个return出来的函数保存到了一个变量中，那么就创建了一个闭包。 闭包的两个使用场景 1.函数作为返回值 12345678910function fun()&#123; var a = 0; return function()&#123; console.log(a); //自由变量，去定义时的父级作用域找 &#125;&#125;var f1 = fun();a = 1000;f1(); 2.函数作为参数 123456789101112131415function fun()&#123; var a = 0; return function()&#123; console.log(a); //自由变量，去定义时的父级作用域找 &#125;&#125;function fun2(f2)&#123; a = 10000 f2();&#125;var f1 = fun();fun2(f1); 具体解释看 高级-闭包中的说明 闭包的两个作用： 能够读取其他函数内部变量的函数 可以让函数内部的变量一直保存在内存中 实际应用场景1： 闭包可以将一些不希望暴露在全局的变量封装成“私有变量”。 假如有一个计算乘积的函数，mult函数接收一些number类型的参数，并返回乘积结果。为了提高函数性能，我们增加缓存机制，将之前计算过的结果缓存起来，下次遇到同样的参数，就可以直接返回结果，而不需要参与运算。这里，存放缓存结果的变量不需要暴露给外界，并且需要在函数运行结束后，仍然保存，所以可以采用闭包。 上代码：123456789101112function calculate(param)&#123; var cache = &#123;&#125;; return function()&#123; if(!cache.parame)&#123; return cache.param; &#125;else&#123; //缓存计算.... //cache.param = result //下次访问直接取 &#125; &#125;&#125; 实际应用场景2 延续局部变量的寿命 img 对象经常用于进行数据上报，如下所示：12345var report = function( src )&#123; var img = new Image(); img.src = src;&#125;;report( 'http://xxx.com/getUserInfo' ); 但是通过查询后台的记录我们得知，因为一些低版本浏览器的实现存在 bug，在这些浏览器下使用 report 函数进行数据上报会丢失 30%左右的数据，也就是说， report 函数并不是每一次都成功发起了 HTTP 请求。 丢失数据的原因是 img 是 report 函数中的局部变量，当 report 函数的调用结束后， img 局部变量随即被销毁，而此时或许还没来得及发出 HTTP 请求，所以此次请求就会丢失掉。 现在我们把 img 变量用闭包封闭起来，便能解决请求丢失的问题：12345678var report = (function()&#123; var imgs = []; return function( src )&#123; var img = new Image(); imgs.push( img ); img.src = src; &#125;&#125;)(); 闭包缺点：浪费资源！ 3. 题目解答3.1 说一下对变量提升的理解变量定义和函数声明 注意函数声明和函数表达式的区别 变量定义时会默认把他的变量声明提升：(仅限于他的执行上下文，比如一段script和一个函数中) 12console.log(a);var a = 0; 实际上是 123var a;console.log(a);a = 0; 3.2 说明this的几种不同使用场景 构造函数中（指向构造的对象） 对象属性中（指向该对象） 普通函数中（指向window） call apply bind 3.3 创建10个a标签，点击的时候弹出来相应的序号实现方法1：用let声明i 12345678910var body = document.body;console.log(body);for (let i = 0; i &lt; 10; i++) &#123; let obj = document.createElement('i'); obj.innerHTML = i + '&lt;br&gt;'; body.appendChild(obj); obj.addEventListener('click',function()&#123; alert(i); &#125;)&#125; 实现方法2 包装作用域 123456789101112var body = document.body;console.log(body);for (var i = 0; i &lt; 10; i++) &#123; (function (i) &#123; var obj = document.createElement('i'); obj.innerHTML = i + '&lt;br&gt;'; body.appendChild(obj); obj.addEventListener('click', function () &#123; alert(i); &#125;) &#125;)(i)&#125; 3.4 实际开发中闭包的应用能够读取其他函数内部变量的函数 可以让函数内部的变量一直保存在内存中 封装变量，权限收敛 应用1 12345678var report = (function()&#123; var imgs = []; return function( src )&#123; var img = new Image(); imgs.push( img ); img.src = src; &#125;&#125;)(); 用于防止变量销毁。 应用2 123456789101112131415function isFirstLoad() &#123; var arr = []; return function (str) &#123; if (arr.indexOf(str) &gt;= 0) &#123; console.log(false); &#125; else &#123; arr.push(str); console.log(true); &#125; &#125;&#125;var fun = isFirstLoad();fun(10);fun(10); 将arr封装在函数内部，禁止随意修改，防止变量销毁。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.lisq.xyz/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://www.lisq.xyz/tags/基础/"},{"name":"面试","slug":"面试","permalink":"https://www.lisq.xyz/tags/面试/"},{"name":"作用域","slug":"作用域","permalink":"https://www.lisq.xyz/tags/作用域/"}]},{"title":"【前端面试】原型和原型链","slug":"【前端面试】原型和原型链","date":"2018-01-17T04:23:59.000Z","updated":"2018-11-09T14:34:29.954Z","comments":true,"path":"2018/01/17/【前端面试】原型和原型链/","link":"","permalink":"https://www.lisq.xyz/2018/01/17/【前端面试】原型和原型链/","excerpt":"","text":"1.题目 如何准确判断一个变量是数组 写一个原型链继承的例子 继承实现的其他方式 描述new一个对象的过程 zepto及其他源码中如何使用原型链 2.知识点2.1 构造函数特点：以大写字母开头 12345678910function Foo(name,age)&#123; //var obj = &#123;&#125; //this = &#123;&#125; this.name = name; this.age = age; this.class = 'class1' // return this&#125;var f1 = new Foo('liming',19); 扩展 var o = {} 是 var o = new Object() 的语法糖 var a = [] 是 var a = new Array() 的语法糖 function Foo(){} 相当于 var Foo = new Function(){} 2.2 原型规则五条规则： 1.所有引用类型（对象，数组，函数）都具有对象特性，即可以自由扩展属性 2.所有引用类型（对象，数组，函数）都具有一个proto（隐式原型）属性，是一个普通对象 3.所有的函数都具有prototype（显式原型）属性，也是一个普通对象 4.所有引用类型（对象，数组，函数）proto值指向它构造函数的prototype 5.当试图得到一个对象的属性时，如果变量本身没有这个属性，则会去他的proto中去找 1234567for (var key in object) &#123; //高级浏览器中已经屏蔽了来自原型的属性 //建议加上判断保证程序的健壮性 if (object.hasOwnProperty(key)) &#123; console.log(object[key]); &#125;&#125; 2.3 thisthis的几种使用场景 全局/函数 构造函数 对象 内部函数 call/apply 2.4 原型链obj. proto . proto . proto … Object.prototype === null instanceof 用于判断引用类型属于哪个构造函数 obj instanceob Foo 实际意义：判断 Foo.prototype 在不在 obj的原型链上 3.题目解答3.1 如何准确判断一个变量是数组arr instanceof Array 3.2 写一个原型链继承的例子封装dom查询 123456789101112131415161718192021222324function Elem(id)&#123; this.elem = document.getElementById(id);&#125;;Elem.prototype.html = function(val)&#123; var elem = this.elem; if (val) &#123; elem.innerHTML = val; return this; &#125;else&#123; return elem.innerHTML; &#125;&#125;Elem.prototype.on = function(type,fun)&#123; var elem = this.elem; elem.addEventListener(type,fun); return this;&#125;var div1 = new Elem('id1');div1.html(\"test\").on('click',function()&#123; console.log('点击');&#125;) 3.3 继承实现的其他方式3.3.1 原型继承1234567891011121314151617181920var obj = &#123; 0:'a', 1:'b', arr:[1]&#125;function Foo(arr2)&#123; this.arr2 = [1]&#125;Foo.prototype = obj;var foo1 = new Foo();var foo2 = new Foo();foo1.arr.push(2);foo1.arr2.push(2);console.log(foo2.arr); //[1,2]console.log(foo2.arr2); //[1] 优点：实现简单 缺点： 1.无法向父类构造函数传参 2.同时new两个对象时改变一个对象的原型中的引用类型的属性时，另一个对象的该属性也会修改。因为来自原型对象的引用属性是所有实例共享的。 3.3.2 构造继承1234567891011function Super(b)&#123; this.b = b; this.fun = function()&#123;&#125;&#125;function Foo(a,b)&#123; this.a = a; Super.call(this,b);&#125;var foo1 = new Foo(1,2);console.log(foo1.b); 优点：可以向父类传参，子类不会共享父类的引用属性 缺点：无法实现函数复用，每个子类都有新的fun，太多了就会影响性能，不能继承父类的原型对象。 3.3.3 组合继承1234567891011121314function Super()&#123; // 只在此处声明基本属性和引用属性 this.val = 1; this.arr = [1];&#125;// 在此处声明函数Super.prototype.fun1 = function()&#123;&#125;;Super.prototype.fun2 = function()&#123;&#125;;//Super.prototype.fun3...function Sub()&#123; Super.call(this); // 核心 // ...&#125;Sub.prototype = new Super(); 优点：不存在引用属性共享问题，可传参，函数可复用 缺点：父类的属性会被实例化两次，获取不到真正实例父类（无法区分实例是父类创建还是父类创建的） 优化： 12345678910111213141516 function Super(b)&#123; this.b = b; this.fun = function()&#123;&#125;&#125;Super.prototype.c = function()&#123;console.log(1111)&#125;function Foo(a,b)&#123; this.a = a; Super.call(this,b);&#125;Foo.prototype = Super.prototype;//修复构造函数：var foo1 = new Foo(1,2); 缺点：无法区分实例是父类创建还是子类创建的 3.3.4 寄生组合继承1234567891011121314151617 function Super(b)&#123; this.b = b;&#125;Super.prototype.c = function()&#123;console.log(1111)&#125;function Foo(a,b)&#123; this.a = a; Super.call(this,b);&#125;var f = new Function();f.prototype = Super.prototype;Foo.prototype = new f();//等同于 Foo.prototype = Object.create(Super.prototype);var foo1 = new Foo(1,2); 对父类的prototype进行一次寄生，即包装成一个空对象的prototype，再把这个对象实例化出来作为子类的peototype。 缺点：无法区分实例是父类创建还是子类创建的 可以添加以下代码： 1Foo.prototype.constructor = Foo 这种解决方法不能用于上面的组合优化方法，因为子类父类引用的是同一个原型对象，修改会同时修改。 总结： 继承主要是实现子类对父类方法，属性的复用。 来自原型对象的引用属性是所有实例共享的，所以我们要避免从原型中继承属性。 在构造函数中通过call函数可以继承父类构造函数的属性和方法，但是通过这种方式实例化出来的实例会将父类方法多次存储，影响性能。 通过组合继承我们使用call继承属性，使用原型继承方法，可以解决以上两个问题，但是通过这种方式实例化出来的对象会存储两份父类构造函数中的属性。 用父类的原型构造一个新对象作为子类的原型，就解决了多次存储的问题，所以最终的寄生组合继承就是最佳继承方式，它的缺点就是书写起来比较麻烦。 3.3.6 node源码中的继承实现12345678910111213141516171819202122232425function inherits(ctor, superCtor) &#123; ctor.super_ = superCtor; ctor.prototype = Object.create(superCtor.prototype, &#123; constructor: &#123; value: ctor, enumerable: false, writable: true, configurable: true &#125; &#125;);&#125;; function Stream()&#123; //...&#125;function OutgoingMessage() &#123; Stream.call(this); //...&#125;inherits(OutgoingMessage, Stream);OutgoingMessage.prototype.setTimeout = ... 以上是寄生组合继承的一个实例。 1.在OutgoingMessage构造函数中通过call继承Stream构造中的属性。 2.调用inherits方法继承Stream原型中的属性。 3.扩展OutgoingMessage自身原型的函数。 inherits方法中使用了Object.create方法,该方法的作用是通过指定的原型对象和属性创建一个新的对象。 1ctor.prototype=Object.create(superCtor.prototype,&#123;.....&#125;); 该方法实际上就做了我们上面寄生组合继承中的工作 123var f = new Function();f.prototype =superCtor.prototype;return new f(); 后面的参数是给原型对象添加属性,可选属性(非必填),即把自身作为新创建对象的构造函数。 1234value: 表示constructor 的属性值；writable: 表示constructor 的属性值是否可写；[默认为: false]enumerable: 表示属性constructor 是否可以被枚举；[默认为: false]configurable: 表示属性constructor 是否可以被配置，例如 对obj.a做 delete操作是否允许；[默认为: false] 3.4 描述new一个对象的过程 创建一个对象 {}.proto = 构造函数.prototype this指向这个对象 执行代码即对this赋值 返回this 3.5 zepto及其他源码中如何使用原型链123456789101112131415161718192021222324252627282930313233343536373839404142434445var Zepto = (function()&#123; var $,zepto = &#123;&#125; // ...省略N行代码... $ = function(selector, context)&#123; return zepto.init(selector, context) &#125; zepto.init = function(selector, context) &#123; var dom // 针对参数情况，分别对dom赋值 // 最终调用 zepto.Z 返回的数据 return zepto.Z(dom, selector) &#125; fnction Z(dom, selector) &#123; var i, len = dom ? dom.length : 0 for (i = 0; i &lt; len; i++) this[i] = dom[i] this.length = len this.selector = selector || '' &#125; zepto.Z = function(dom, selector) &#123; return new Z(dom, selector) &#125; $.fn = &#123; // 里面有若干个工具函数 &#125; zepto.Z.prototype = Z.prototype = $.fn // ...省略N行代码... return $&#125;)()window.Zepto = Zeptowindow.$ === undefined &amp;&amp; (window.$ = Zepto)","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.lisq.xyz/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://www.lisq.xyz/tags/基础/"},{"name":"面试","slug":"面试","permalink":"https://www.lisq.xyz/tags/面试/"},{"name":"原型链","slug":"原型链","permalink":"https://www.lisq.xyz/tags/原型链/"}]},{"title":"【个人博客搭建及配置七】seo优化","slug":"【个人博客搭建及配置七】seo优化","date":"2018-01-05T09:39:37.000Z","updated":"2018-11-05T15:59:31.716Z","comments":true,"path":"2018/01/05/【个人博客搭建及配置七】seo优化/","link":"","permalink":"https://www.lisq.xyz/2018/01/05/【个人博客搭建及配置七】seo优化/","excerpt":"","text":"博客地址： https://www.lisq.xyz/ SEO是由英文Search Engine Optimization缩写而来， 中文意译为“搜索引擎优化”。SEO是指通过站内优化比如网站结构调整、网站内容建设、网站代码优化等以及站外优化。 简而言之，就是让人们更容易搜索到你的站点。 首先要做的就是让搜索引擎收录我们的站点。 1.百度1.1 提交网址在搜索引擎中输入site:&lt;域名&gt;,如果如下图所示就是说明我们的网站并没有被百度收录。我们可以直接点击下面的“网址提交”来提交我们的网站 然后点击途中的提交网址 选择站点的相关属性： 接下来进行网站验证，推荐使用第三种GNAME验证，简单快捷，只需要给你的链接增加一条解析即可: 1.2 生成网站地图接下来要让你的网站生成网站地图，及生产sitemap，将sitemap提交到百度，先安装地图生成插件： 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 注意根目录的_config.yml将url配置成你的站点1234# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://lisq.xyz/root: / 重新部署博客后就会生成两个新文件sitemap.xml和baidusitemap.xml 1.3 将sitemap提交给百度点击链接提交 使用主动推送 主动推送安装插件npm install hexo-baidu-url-submit –save然后再根目录的配置文件中新增字段12345baidu_url_submit: count: 100 host: https://lisq.xyz/ token: 8OGYpxowYnhgVsUM path: baidu_urls.txt # 文本文档的地址 在加入新的deploye12deploy: - type:baidu_url_submitter 百度收录的时间非常长，耐心等待吧。 2.谷歌点击这里添加你的网址 点击添加属性后即可添加你的博客地址。 进行验证： 谷歌收录的速度还是相当快的，而且操作比较简单。","categories":[],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.lisq.xyz/tags/博客搭建/"},{"name":"seo","slug":"seo","permalink":"https://www.lisq.xyz/tags/seo/"}]},{"title":"【个人博客搭建及配置六】评论系统","slug":"【个人博客搭建及配置六】评论系统","date":"2018-01-02T10:44:32.000Z","updated":"2018-11-05T15:39:23.193Z","comments":true,"path":"2018/01/02/【个人博客搭建及配置六】评论系统/","link":"","permalink":"https://www.lisq.xyz/2018/01/02/【个人博客搭建及配置六】评论系统/","excerpt":"","text":"博客地址： https://www.lisq.xyz/ 博客使用valine作为评论工具，原因是他使用简介，体积轻量，灵活配置，速度很快！ 1.注册LeanCloudvaline接住了LeanCloud的力量，所以需要LeanCloud的APP ID 和 APP Key 首先注册和登录LeanCloud 创建一个应用： 应用创建好以后，进入刚刚创建的应用，选择左下角的设置&gt;应用Key，然后就能看到你的APP ID和APP Key了： 代码将如下代码插入你的文章模板中 1234567891011121314151617&lt;head&gt; ... &lt;script src=&quot;//cdn1.lncld.net/static/js/3.0.4/av-min.js&quot;&gt;&lt;/script&gt; &lt;script src=&apos;//unpkg.com/valine/dist/Valine.min.js&apos;&gt;&lt;/script&gt; ...&lt;/head&gt;&lt;body&gt; ... &lt;div id=&quot;vcomments&quot;&gt;&lt;/div&gt; &lt;script&gt; new Valine(&#123; el: &apos;#vcomments&apos;, appId: &apos;&lt;API_ID&gt;&apos;, appKey: &apos;&lt;API_Key&gt;&apos; &#125;) &lt;/script&gt;&lt;/body&gt; 配置好这些，等待两分钟，就可以在文章里使用你的评论啦。 数据管理由于Valine 是无后端评论系统，所以也就没有开发评论数据管理功能。 可以在leanCloud中管理评论 1登录&gt;选择你创建的应用&gt;存储&gt;选择Class Comment 安全域名为了数据安全，在leanCloud中配置你的安全域名 配置项Valine还有一些其他的配置项 123456789new Valine(&#123; el: &apos;#vcomments&apos; , appId: &apos;&lt;APP_ID&gt;&apos;, appKey: &apos;&lt;APP_KEY&gt;&apos;, notify:false, verify:false, avatar:&apos;mm&apos;, placeholder: &apos;just go go&apos; &#125;); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788placeholder类型:String默认值:Just go go必要性:false评论框占位提示符。notify类型:Boolean默认值:false必要性:false评论回复邮件提醒，请参考配置。verify类型:Boolean默认值:false必要性:false验证码服务。path类型:String默认值:window.location.pathname必要性:false当前文章页路径，用于区分不同的文章页，以保证正确读取该文章页下的评论列表。可选值：window.location.pathname (默认值，推荐)window.location.href自定义I. 请保证每个文章页路径的唯一性，否则可能会出现不同文章页下加载相同评论列表的情况。II. 如果值为window.location.href，可能会出现随便加不同参数进入该页面，而被判断成新页面的情况。avatar类型:String默认值:mm必要性:falseGravatar 头像展示方式。可选值：&apos;&apos;(空字符串)mpidenticonmonsteridwavatarretrorobohashhide更多信息，请查看头像配置。meta类型:Array默认值:[&apos;nick&apos;,&apos;mail&apos;,&apos;link&apos;]必要性:false评论者相关属性。pageSize类型:Number默认值:10必要性:false评论列表分页，每页条数。lang类型:String默认值:zh-cn必要性:false多语言支持。可选值：zh-cnen如需自定义语言，请参考i18n。visitor类型:Boolean默认值:false必要性:false文章访问量统计。highlight类型：Boolean默认值: true必要性: false代码高亮，默认开启，若不需要，请手动关闭avatarForce类型: Boolean默认值: false必要性: false","categories":[],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.lisq.xyz/tags/博客搭建/"}]},{"title":"【个人博客搭建及配置五】阅读统计","slug":"【个人博客搭建及配置五】阅读统计","date":"2018-01-02T07:06:53.000Z","updated":"2018-11-05T15:38:07.315Z","comments":true,"path":"2018/01/02/【个人博客搭建及配置五】阅读统计/","link":"","permalink":"https://www.lisq.xyz/2018/01/02/【个人博客搭建及配置五】阅读统计/","excerpt":"","text":"博客地址： https://www.lisq.xyz/ 这里的统计是用来展示在页面上的，可以标示文章以及博客的热度。 使用不蒜子来展示文章访问统计和页面访问统计。 1.引入不蒜子将不蒜子js文件引入博客主题公共组件中。 1&lt;script async src=\"//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt; 这里我同站长统计一样放在themes/hueman/common/footer.ejs 2.文章访问统计要显示每篇文章的访问量，复制以下代码添加到你需要显示的位置。 可以在标签上自定义一些样式。 算法：pv的方式，单个用户点击1篇文章，本篇文章记录1次阅读量。 123&lt;span id=\"busuanzi_container_page_pv\"&gt; 本文总阅读量&lt;span id=\"busuanzi_value_page_pv\"&gt;&lt;/span&gt;次&lt;/span&gt; 3.整站访问统计算法a：pv的方式，单个用户连续点击n篇文章，记录n次访问量。 123&lt;span id=\"busuanzi_container_site_pv\"&gt; 本站总访问量&lt;span id=\"busuanzi_value_site_pv\"&gt;&lt;/span&gt;次&lt;/span&gt; 算法b：uv的方式，单个用户连续点击n篇文章，只记录1次访客数。123&lt;span id=\"busuanzi_container_site_uv\"&gt; 本站访客数&lt;span id=\"busuanzi_value_site_uv\"&gt;&lt;/span&gt;人次&lt;/span&gt;","categories":[],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.lisq.xyz/tags/博客搭建/"}]},{"title":"【个人博客搭建及配置四】站长统计","slug":"【个人博客搭建及配置四】站长统计","date":"2018-01-02T03:15:50.000Z","updated":"2018-11-05T15:37:10.070Z","comments":true,"path":"2018/01/02/【个人博客搭建及配置四】站长统计/","link":"","permalink":"https://www.lisq.xyz/2018/01/02/【个人博客搭建及配置四】站长统计/","excerpt":"","text":"博客地址： https://www.lisq.xyz/ 使用一个站长统计工具，可以为博客添加一个如上面似的详细的访问报表。 站长统计工具有很多，每个工具大同小异，这里我选择了CNZZ。 CNZZ配置1.注册一个账号。 2.添加网站。 按照如下要求添加网站 3.选择统计代码 添加完网站后就可以选择一段代码插入你的博客里了，CNZZ提供了几种样式，你可以选择展示真实的统计数量，一个cnzz图标或者什么都不显示。 代码配置将上面复制的代码插入到你主题代码的公共区域中。 每个主题的代码都不一样，但是大体结构是相同的，都会将通用的组件抽取出来。 这里我找到了每个页面都使用的footer组件，我使用的是hueman主题，代码在themes/hueman/common/footer.ejs 在此文件中找到合适的位置插入你的统计代码。 比如我的（script内的部分）：","categories":[],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.lisq.xyz/tags/博客搭建/"}]},{"title":"【个人博客搭建及配置三】同时托管到github和coding上","slug":"【个人博客搭建及配置三】同时托管到github和coding上","date":"2018-01-02T02:34:06.000Z","updated":"2018-11-08T04:01:31.309Z","comments":true,"path":"2018/01/02/【个人博客搭建及配置三】同时托管到github和coding上/","link":"","permalink":"https://www.lisq.xyz/2018/01/02/【个人博客搭建及配置三】同时托管到github和coding上/","excerpt":"","text":"博客地址： https://www.lisq.xyz/ github page毕竟是国外站点，访问速度相对来说比较慢，但是同时你又想在gihub上保存一下代码，可以尝试同时托管两个仓库。 做解析的时候海外的ip 指向到github，国内的或者说百度的直接指向coding。 1.在coding上提交代码首先做的操作和github是一样的，就是创建一个ssh。 这里要注意的是，你的电脑上已经有了gihub的ssh，如果还像github一样一路回车会把gihub的ssh给覆盖掉。 所以这里在执行 1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 时要注意，给生成的文件配置一个新路径： 然后配置生成的ssh 在coding中创建一个仓库，这里注意仓库的名字可以随意取，不像gihub一样可以随意给定。 将创建仓库的git地址添加到_config.yml中： 123456deploy: type: git repo: github: https://github.com/ConardLi/ConardLi.github.io.git coding: https://git.dev.tencent.com/ConardLi/lisqBlog.git branch: master 然后重新部署并上传博客，去仓库查看代码证明上传成功： 2.开启coding page点击coding的pages服务，直接点击一键开启即可。 开启后即可通过给定域名直接访问了： http://conardli.coding.me/ 3.域名解析将新生成的coding域名进行解析，这样国内就默认访问coding的页面，比github要快不少。 另外还可以将github的ip进行国外站点配置。 在coding page中将自己的域名进行绑定。 配置完成后发现速度快了不少，有木有… https://www.lisq.xyz/","categories":[],"tags":[{"name":"版本控制","slug":"版本控制","permalink":"https://www.lisq.xyz/tags/版本控制/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.lisq.xyz/tags/博客搭建/"},{"name":"github","slug":"github","permalink":"https://www.lisq.xyz/tags/github/"}]},{"title":"【个人博客搭建及配置二】绑定个人域名","slug":"【个人博客搭建及配置二】绑定个人域名","date":"2018-01-01T15:28:31.000Z","updated":"2018-11-05T15:35:02.609Z","comments":true,"path":"2018/01/01/【个人博客搭建及配置二】绑定个人域名/","link":"","permalink":"https://www.lisq.xyz/2018/01/01/【个人博客搭建及配置二】绑定个人域名/","excerpt":"","text":"博客地址： https://www.lisq.xyz/ 1.购买一个域名这里我选择的是阿里云，挑选一个自己喜欢的域名购买。 2.域名解析进入控制台添加域名解析。 按照如下规则添加两条记录。 这时去访问解析好的域名会出现如下页面。 这说明域名解析没有问题，接下来进入github进行配置 3.hexo配置在本地的博客目录中找到source文件夹。 新建一个没有后缀名的文件GNAME 在文件中添加你的域名，如： 1lisq.xyz 保存后重新生成，并提交你的博客。 4.github配置在github中找到你的博客仓库。 点击12找到```Custom domain 输入你的域名点击save 然后你就可以在浏览器用你的域名愉快的访问啦！","categories":[],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.lisq.xyz/tags/博客搭建/"}]},{"title":"【个人博客搭建及配置一】基础配置","slug":"【个人博客搭建及配置一】基础配置","date":"2018-01-01T12:13:20.000Z","updated":"2018-11-05T15:27:04.665Z","comments":true,"path":"2018/01/01/【个人博客搭建及配置一】基础配置/","link":"","permalink":"https://www.lisq.xyz/2018/01/01/【个人博客搭建及配置一】基础配置/","excerpt":"","text":"博客地址： https://www.lisq.xyz/ 1.本地安装hexo首先保证你电脑上有node环境，这个不懂的可以自定百度。 控制台输入node -v出现版本号说明安装成功。 有了node就可以安装hexo了，控制台输入如下命令 1npm i -g hexo 同样控制台输入hexo -v出现版本号说明安装成功。 然后开始初始化项目，控制台输入： 1hexo init 得到如下项目目录： 12345678node_modules：是依赖包public：存放的是生成的页面scaffolds：命令生成文章等的模板source：用命令创建的各种文章themes：主题_config.yml：整个博客的配置db.json：source解析所得到的package.json：项目所需模块项目的配置信息 2.本地运行首先在本地跑起来你的代码 控制台安装hexo-server 1npm i hexo-server 然后运行 hexo-server 在浏览器中访问：http://localhost:4000就可以看到你本定运行的页面了 这时你可以在本地调试一下你的blog。 3.github配置首先要创建一个github账号 并配置好ssh 这些不懂的可以自行百度。 创建一个repo，名称为yourname.github.io, 其中yourname是你的github名称，按照这个规则创建github page才会生效。 修改_config.yml中的git配置 1234deploy: type: git repo: https://github.com/xxxx.git branch: master 4.部署上传在本地安装上传工具 1npm install hexo-deployer-git --save 依次执行如下命令 123hexo clean //删除上次打包hexo generate //打包hexo deploy /上传 这里我单独写了sh执行这三段脚本，这样每次只需要执行这个sh即可。 在浏览器中输入http://yourgithubname.github.io就可以看到你的个人博客了！ 一些其他配置搜索功能使用搜索功能首先需要： 1npm install -S hexo-generator-json-content 然后： 12search: insight: true readme1.首先在source文件夹下建立一个README.md 2.修改_config.yml 1skip_render: README.md","categories":[],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.lisq.xyz/tags/博客搭建/"},{"name":"github","slug":"github","permalink":"https://www.lisq.xyz/tags/github/"}]},{"title":"【前端面试】变量和类型计算","slug":"【前端面试】变量和类型计算","date":"2017-12-27T14:28:48.000Z","updated":"2018-11-08T14:54:37.877Z","comments":true,"path":"2017/12/27/【前端面试】变量和类型计算/","link":"","permalink":"https://www.lisq.xyz/2017/12/27/【前端面试】变量和类型计算/","excerpt":"","text":"1.题目 1.JS使用typeof能得到哪些类型 === 和 == 的选择 JS中有哪些内置函数 JS变量按存储方式分为哪些类型，并描述其特点 如何理解JSON 2.知识点2.1 值类型和引用类型值类型（boolean,string,number,null,undefined） 1234var a = 10;var b = a;a = 20;console.log(b); //10 引用类型（对象，数组，函数） 1234var a = &#123;x:10&#125;var b = a;a.x = 20;console.log(b); //20 值类型直接把值存储在堆中，把a赋值给b在内存中是又给b开辟了一块新的空间，存储了同样的值。 引用类型分两块存储，先在堆中存储一个实际的值，再在栈中存储一个堆中值的引用地址，指向堆中的对象。把a赋值给b是在栈中重新开辟一块空间存储的还是相同对象的引用地址，a和b存储的地址相同，指向的对象也相同。当对象值发生改变时，两者会同时改变。 引用类型的值一般都比较大，采用此种存储方式可以节省内存空间。 2.2 typeof运算符12345678typeof 'abc' //stringtypeof 123 //numbertypeof true //booleantypeof undefined //undefinedtypeof null //objecttypeof &#123;a:10&#125; //objecttypeof [1,2,3] //objecttypeof console.log() //function 2.3 类型转换强类型转换：通过String（），Number（），Boolean（），parseInt（）函数强制转换 可能发生隐式类型转换的场景 字符串拼接 使用== if语句 逻辑循环 一、首先看双等号前后有没有NaN，如果存在NaN，一律返回false。 二、再看双等号前后有没有布尔，有布尔就将布尔转换为数字。（false是0，true是1） 三、接着看双等号前后有没有字符串, 有三种情况： 1、对方是对象，对象使用toString()或者valueOf()进行转换；2、对方是数字，字符串转数字；（前面已经举例）3、对方是字符串，直接比较；4、其他返回false四、如果是数字，对方是对象，对象取valueOf()或者toString()进行比较, 其他一律返回false 五、null, undefined不会进行类型转换, 但它们俩相等 上面的转换顺序一定要牢记，面试的时候，经常会出现类型的问题。 12345678910'100'==100 //转换成字符串''==0 //转换成falseundefined == null; // true1 == true; // true2 == true; // false0 == false; // true0 == ' '; // trueNaN == NaN; // false[] == false; // true[] == ![]; // true 1234567//在if中转换成false的：nullundefined''NaN0false 12310 &amp;&amp; 0 //0 10转换成true'' || 'abc' //abc ''转换成false!window.abc //true 2.4 null和undefined的区别null：是被赋值过的对象，刻意把一个对象赋值为null，故意表示其为空，不应有值，所以对象为null是正常的，typeof null 返回 ‘object’ ，null可以转换为0 undefined 表示“缺少值”，即此处应有一个值，但还没有定义；转为数值时为NaN(非数字值的特殊值) typeof undefined 返回 ‘undefined’ 3.题目解答3.1 JS使用typeof能得到哪些类型12345678typeof 'abc' //stringtypeof 123 //numbertypeof true //booleantypeof undefined //undefinedtypeof null //objecttypeof &#123;a:10&#125; //objecttypeof [1,2,3] //objecttypeof console.log() //function 3.2 === 和 == 的选择jquery源码中的写法： 除了以下方式其他全部使用 === 123if(obj.a == null)&#123; //相当于 obj.a === undefined || obj.a === null&#125; 3.3 JS中有哪些内置函数单纯作为语言来说，不考虑node和浏览器web Object Array Boolean Number String Function Date RegExp Error 内置对象：Math,JSON 3.4 JS变量按存储方式分为哪些类型，并描述其特点值类型何引用类型 3.5 如何理解JSONJSON是JS中的一个内置对象 区别 JS对象 {x:10} JSON对象 {‘x’:10} JSON串 “{‘x’:10}” 1234//将JS对象转换成json串JSON.stringify(&#123;x:10&#125;);//将json字符串转换成json对象JSON.parse(\"&#123;'x':10&#125;\"); 3.6 严格模式目的 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的Javascript做好铺垫。 特性 1 \"use strict\"; 可以选择放在一个函数中或自定义作用域中。 禁止this指向全局对象 123456789 function f()&#123; return !this; &#125; // 返回false，因为\"this\"指向全局对象，\"!this\"就是false function f()&#123; \"use strict\"; return !this; &#125; // 返回true，因为严格模式下，this的值为undefined，所以\"!this\"为true。 创设eval作用域 正常模式下，Javascript语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：eval作用域。正常模式下，eval语句的作用域，取决于它处于全局作用域，还是处于函数作用域。严格模式下，eval语句本身就是一个作用域，不再能够生成全局变量了，它所生成的变量只能用于eval内部。 1234 \"use strict\"; var x = 2; console.info(eval(\"var x = 5; x\")); // 5 console.info(x); // 2 全局变量显式声明 123 v = 1; // 报错，v未声明 for(i = 0; i &lt; 2; i++) &#123; // 报错，i未声明 &#125; 禁止删除变量 严格模式下无法删除变量。只有configurable设置为true的对象属性，才能被删除。 12345678 \"use strict\"; var x; delete x; // 语法错误 var o = Object.create(null, &#123;'x': &#123; value: 1, configurable: true &#125;&#125;); delete o.x; // 删除成功 函数不能有重名的参数 保留字 为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。使用这些词作为变量名将会报错。1234 function package(protected) &#123; // 语法错误 \"use strict\"; var implements; // 语法错误 &#125; 3.7 eval1.没有必须使用的应用场景 2.不容易调试，可读性不好 3.在旧的浏览器中如果你使用了eval，性能会下降10倍。 4.容易xss","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.lisq.xyz/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://www.lisq.xyz/tags/基础/"},{"name":"面试","slug":"面试","permalink":"https://www.lisq.xyz/tags/面试/"}]},{"title":"vue问题记录","slug":"vue问题记录","date":"2017-12-24T05:26:55.000Z","updated":"2018-10-28T14:34:34.670Z","comments":true,"path":"2017/12/24/vue问题记录/","link":"","permalink":"https://www.lisq.xyz/2017/12/24/vue问题记录/","excerpt":"","text":"vue生命周期https://segmentfault.com/a/1190000008010666 v-show和v-if指令的共同点和不同点?v-show指令是通过修改元素的displayCSS属性让其显示或者隐藏 v-if指令是直接销毁和重建DOM达到让元素显示和隐藏的效果 如何让CSS只在当前组件中起作用?将当前组件的12修改为```&lt;style scoped&gt; 的作用是什么?大白话: 比如有一个列表和一个详情，那么用户就会经常执行打开详情=&gt;返回列表=&gt;打开详情…这样的话列表和详情都是一个频率很高的页面，那么就可以对列表组件使用进行缓存，这样用户每次返回列表的时候，都能从缓存中快速渲染，而不是重新渲染 vue中使用组件1.采用ES6的import … from …语法或CommonJS的require()方法引入组件 2.对组件进行注册,代码如下1234// 注册Vue.component('my-component', &#123; template: '&lt;div&gt;A custom component!&lt;/div&gt;'&#125;) 3.使用组件 使用插件采用ES6的import … from …语法或CommonJSd的require()方法引入插件 使用全局方法Vue.use( plugin )使用插件,可以传入一个选项对象Vue.use(MyPlugin, { someOption: true }) 如使用vue-router，vue-resource插件 组件通信父组件向子组件先定义一个子组件，在组件中注册props 12345678910111213&lt;template&gt; &lt;div&gt; &lt;div&gt;&#123;&#123;message&#125;&#125;(子组件)&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; message: String //定义传值的类型&lt;br&gt; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 在父组件中，引入子组件，并传入子组件内需要的值 1234567891011121314151617181920212223&lt;template&gt; &lt;div&gt; &lt;div&gt;父组件&lt;/div&gt; &lt;child :message=\"parentMsg\"&gt;&lt;/child&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt; import child from './child' //引入child组件export default &#123; data() &#123; return &#123; parentMsg: 'a message from parent' //在data中定义需要传入的值 &#125; &#125;, components: &#123; child &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 子组件向父组件12345678910子组件:&lt;template&gt; &lt;div @click=\"up\"&gt;&lt;/div&gt;&lt;/template&gt;methods: &#123; up() &#123; this.$emit('upup','hehe'); //主动触发upup方法，'hehe'为向父组件传递的数据 &#125;&#125; 12345678&lt;div&gt; &lt;child @upup=\"change\" :msg=\"msg\"&gt;&lt;/child&gt; //监听子组件触发的upup事件,然后调用change方法&lt;/div&gt;methods: &#123; change(msg) &#123; this.msg = msg; &#125;&#125; 兄弟组件通信组件1触发：123456&lt;div @click=\"eve\"&gt;&lt;/div&gt;methods: &#123; eve() &#123; Hub.$emit('change','hehe'); //Hub触发事件 &#125;&#125; 组件2接收:123456&lt;div&gt;&lt;/div&gt;created() &#123; Hub.$on('change', () =&gt; &#123; //Hub接收事件 this.msg = 'hehe'; &#125;);&#125; 这样就实现了非父子组件之间的通信了.原理就是把Hub当作一个中转站！ computed 和 watch12345678910111213141516 new Vue(&#123; el: '#myDiv', data: &#123; firstName: 'Foo', lastName: 'Bar', fullName: 'Foo Bar' &#125;, watch: &#123; firstName: function (val) &#123; this.fullName = val + ' ' + this.lastName &#125;, lastName: function (val) &#123; this.fullName = this.firstName + ' ' + val &#125; &#125;&#125;) 12345678910111213new Vue(&#123; el:\"#myDiv\", data:&#123; firstName:\"Den\", lastName:\"wang\", &#125;, computed:&#123; fullName:function()&#123; return this.firstName + \" \" +this.lastName; &#125; &#125; &#125;) 12345678910111213computed:&#123; fullName:&#123; //这里用了es6书写方法 set()&#123; alert(\"set\"); &#125;, get()&#123; alert(\"get\"); return this.firstName + \" \" +this.lastName; &#125;, &#125; &#125; 1.从属性名上，computed是计算属性，也就是依赖其它的属性计算所得出最后的值。watch是去监听一个值的变化，然后执行相对应的函数。 2.从实现上，computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时才会重新调用对应的getter来计算。watch在每次监听的值变化时，都会执行回调。其实从这一点来看，都是在依赖的值变化之后，去执行回调。很多功能本来就很多属性都可以用，只不过有更适合的。如果一个值依赖多个属性（多对一），用computed肯定是更加方便的。如果一个值变化后会引起一系列操作，或者一个值变化会引起一系列值的变化（一对多），用watch更加方便一些。 3.watch的回调里面会传入监听属性的新旧值，通过这两个值可以做一些特定的操作。computed通常就是简单的计算。 4.watch和computed并没有哪个更底层，watch内部调用的是vm.$watch，它们的共同之处就是每个定义的属性都单独建立了一个Watcher对象。","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.lisq.xyz/tags/vue/"}]},{"title":"webpack使用小结","slug":"webpack小结","date":"2017-12-06T12:10:06.000Z","updated":"2018-10-29T12:12:03.505Z","comments":true,"path":"2017/12/06/webpack小结/","link":"","permalink":"https://www.lisq.xyz/2017/12/06/webpack小结/","excerpt":"","text":"1.将图片输出成base64，减少http请求2.loadercss-loader,style-loader:两个建议配合使用，用来解析css文件，能够解释@import,url()如果需要解析less就在后面加一个less-loader babel-loader： 让下一代的js文件转换成现代浏览器能够支持的JS文件 pluginExtractTextWebpackPlugin: 它会将入口中引用css文件，都打包都独立的css文件中，而不是内嵌在js打包文件中。 123456789101112131415161718192021var ExtractTextPlugin = require('extract-text-webpack-plugin') var lessRules = &#123; use: [ &#123;loader: 'css-loader'&#125;, &#123;loader: 'less-loader'&#125; ] &#125; var baseConfig = &#123; // ... module: &#123; rules: [ // ... &#123;test: /\\.less$/, use: ExtractTextPlugin.extract(lessRules)&#125; ] &#125;, plugins: [ new ExtractTextPlugin('main.css') ] &#125; entryoutput: 即使入口文件有多个，但是只有一个输出配置1234567891011var path = require('path') var baseConfig = &#123; entry: &#123; main: './src/index.js' &#125;, output: &#123; filename: 'main.js', path: path.resolve('./build') &#125; &#125; module.exports = baseConfig 1234output: &#123; filename: '[name].js', path: path.resolve('./build') &#125; 开发环境和生产环境在开发时，不可避免会产生大量debug又或是测试的代码，这些代码不应出现在生产环境中（也即不应提供给用户）。 在把页面部署到服务器时，为了追求极致的技术指标，我们会对代码进行各种各样的优化，比如说混淆、压缩，这些手段往往会彻底破坏代码本身的可读性，不利于我们进行debug等工作。 数据源的差异化，比如说在本地开发时，读取的往往是本地mock出来的数据，而正式上线后读取的自然是API提供的数据了。 把原来开发用的的webpack.config.js改成webpack.dev.config.js，并备份一份命名为webpack.prod.config.js。修改package.json和server中对配置文件的引用。 然后针对生成环境的配置文件做一些修改，主要涉及导出目录、代码混淆、去除冗余代码等相关配置。用到了以下插件：1234DefinePlugin：定义环境变量webpack.LoaderOptionsPlugin：去除调试代码，压缩代码webpack.optimize.UglifyJsPlugin：针对JS的混淆配置CopyWebpackPlugin：复制手动引入的资源文件到指定目录 原理Webpack的核心原理Webpack的两个最核心的原理分别是： 一切皆模块 正如js文件可以是一个“模块（module）”一样，其他的（如css、image或html）文件也可视作模 块。因此，你可以require(‘myJSfile.js’)亦可以require(‘myCSSfile.css’)。这意味着我们可以将事物（业务）分割成更小的易于管理的片段，从而达到重复利用等的目的。 按需加载 传统的模块打包工具（module bundlers）最终将所有的模块编译生成一个庞大的bundle.js文件。但是在真实的app里边，“bundle.js”文件可能有10M到15M之大可能会导致应用一直处于加载中状态。因此Webpack使用许多特性来分割代码然后生成多个“bundle”文件，而且异步加载部分代码以实现按需加载。 打包原理每个文件都是一个资源，可以用require/import导入js 每个入口文件会把自己所依赖(即require)的资源全部打包在一起，一个资源多次引用的话，只会打包一份 对于多个入口的情况，其实就是分别独立的执行单个入口情况，每个入口文件不相干 把所有依赖打包成一个bundle.js文件，通过代码分割成单元片段并按需加载。 如图，entry.js是入口文件，调用了util1.js和util2.js，而util1.js又调用了util2.js。 打包后的bundle.js例子 1234567891011121314151617181920212223242526/******/ ([/* 0 */ //模块id/***/ function(module, exports, __webpack_require__) &#123; __webpack_require__(1); //require资源文件id __webpack_require__(2);/***/ &#125;,/* 1 *//***/ function(module, exports, __webpack_require__) &#123; //util1.js文件 __webpack_require__(2); var util1=1; exports.util1=util1;/***/ &#125;,/* 2 *//***/ function(module, exports) &#123; //util2.js文件 var util2=1; exports.util2=util2;/***/ &#125;....../******/ ]); 1.bundle.js是以模块 id 为记号，通过函数把各个文件依赖封装达到分割效果，如上代码 id 为 0 表示 entry 模块需要的依赖， 1 表示 util1模块需要的依赖 2.require资源文件 id 表示该文件需要加载的各个模块，如上代码_webpack_require__(1) 表示 util1.js 模块，webpack_require(2) 表示 util2.js 模块 3.exports.util1=util1 模块化的体现，输出该模块","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://www.lisq.xyz/tags/webpack/"},{"name":"打包工具","slug":"打包工具","permalink":"https://www.lisq.xyz/tags/打包工具/"}]},{"title":"vue双向绑定浅析","slug":"vue双向绑定浅析","date":"2017-12-02T13:53:09.000Z","updated":"2018-10-28T14:26:22.821Z","comments":true,"path":"2017/12/02/vue双向绑定浅析/","link":"","permalink":"https://www.lisq.xyz/2017/12/02/vue双向绑定浅析/","excerpt":"","text":"原理数据劫持: vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 实现流程1、实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者 2、实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数 3、实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图 4、mvvm入口函数，整合以上三者 实现Observer可以利用Obeject.defineProperty()来监听属性变动那么将需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。。相关代码可以是这样： 12345678910111213141516171819202122232425262728var data = &#123;name: 'kindeng'&#125;;observe(data);data.name = 'dmq'; // 哈哈哈，监听到值变化了 kindeng --&gt; dmqfunction observe(data) &#123; if (!data || typeof data !== 'object') &#123; return; &#125; // 取出所有属性遍历 Object.keys(data).forEach(function(key) &#123; defineReactive(data, key, data[key]); &#125;);&#125;;function defineReactive(data, key, val) &#123; observe(val); // 监听子属性 Object.defineProperty(data, key, &#123; enumerable: true, // 可枚举 configurable: false, // 不能再define get: function() &#123; return val; &#125;, set: function(newVal) &#123; console.log('哈哈哈，监听到值变化了 ', val, ' --&gt; ', newVal); val = newVal; &#125; &#125;);&#125; depdep的作用是消息订阅器，很简单，维护一个数组，用来收集订阅者，数据变动触发notify，再调用订阅者的update方法 compliecompile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图 因为遍历解析的过程有多次操作dom节点，为提高性能和效率，会先将跟节点el转换成文档碎片fragment进行解析编译操作，解析完成，再将fragment添加回原来的真实dom节点中。 12345678910111213141516171819function Compile(el) &#123; this.$el = this.isElementNode(el) ? el : document.querySelector(el); if (this.$el) &#123; this.$fragment = this.node2Fragment(this.$el); this.init(); this.$el.appendChild(this.$fragment); &#125;&#125;Compile.prototype = &#123; init: function() &#123; this.compileElement(this.$fragment); &#125;, node2Fragment: function(el) &#123; var fragment = document.createDocumentFragment(), child; // 将原生节点拷贝到fragment while (child = el.firstChild) &#123; fragment.appendChild(child); &#125; return fragment; &#125;&#125;; compileElement方法将遍历所有节点及其子节点，进行扫描解析编译，调用对应的指令渲染函数进行数据渲染，并调用对应的指令更新函数进行绑定。遍历后将自己每一个元素作为一个订阅者添加到dep的数组中。 在compileElement中做监听，值改变了再去改变MVVM的值。 watcher1、在自身实例化时往属性订阅器(dep)里面添加自己 2、自身必须有一个update()方法 3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调 主要作用是将元素封装成一个订阅对象，内含有updae函数，从而把自身加入到订阅器列表中作为订阅者。","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.lisq.xyz/tags/vue/"},{"name":"双向绑定","slug":"双向绑定","permalink":"https://www.lisq.xyz/tags/双向绑定/"},{"name":"数据流","slug":"数据流","permalink":"https://www.lisq.xyz/tags/数据流/"}]},{"title":"前端常见算法","slug":"前端常见算法","date":"2017-11-09T05:44:18.000Z","updated":"2018-10-28T14:28:26.377Z","comments":true,"path":"2017/11/09/前端常见算法/","link":"","permalink":"https://www.lisq.xyz/2017/11/09/前端常见算法/","excerpt":"","text":"判断回文123function checkPalindrom(str) &#123; return str == str.split('').reverse().join('');&#125; 去掉一组整型数组重复的值123比如输入: [1,13,24,11,11,14,1,2] 输出: [1,13,24,11,14,2]需要去掉重复的11 和 1 这两个元素。 方法1：使用object 考察个人对Object的使用，利用key来进行筛选。 1234567891011function unique(arr)&#123; var hasTable = &#123;&#125;; var result = []; for (let i = 0; i &lt; arr.length; i++) &#123; if(!hasTable[arr[i]])&#123; result.push(arr[i]); hasTable[arr[i]] = true; &#125; &#125; return result;&#125; 方法2：使用indexOf(IE8以下不支持)1234567function unique1(array) &#123; var n = []; for (var i = 0; i &lt; array.length; i++) &#123; if (n.indexOf(array[i]) == -1) n.push(array[i]); &#125; return n;&#125; 方法3：利用filter方法 判断数据元素是不是第一次出现 123var r = arr.filter(function (element, index, self) &#123; return self.indexOf(element) === index;&#125;); 统计一个字符串出现最多的字母123输入 ： afjghdfraaaasdenas 输出 ： a 1234567891011121314151617181920212223function findMaxChar(str) &#123; var arr = str.split(''); var countObj = &#123;&#125;; for (let i = 0; i &lt; arr.length; i++) &#123; const element = arr[i]; if (countObj[element]) &#123; countObj[element]++; &#125; else &#123; countObj[element] = 1; &#125; &#125; let maxNum = 0, maxValue = ''; for (const key in countObj) &#123; if (countObj.hasOwnProperty(key)) &#123; const element = countObj[key]; if(element&gt;maxNum)&#123; maxNum = element; maxValue = key; &#125; &#125; &#125; return maxValue;&#125; 获取数组中的最大差12Math.max()Math.min() 最快捷的数组求最大值12var arr = [ 1,5,1,7,5,9]; Math.max(...arr) // 9 随机生成指定长度的字符串123Math.floor() 向下取整Math.round() 四舍五入Math.Ceil() 向上取整 123456789function randomString(n)&#123; var base = 'abcdefghijklmnopqrstuvwxyz0123456789'; var l = base.length; var m =''; for (let i = 0; i &lt; n; i++) &#123; m = m + base.charAt(Math.floor(Math.random()*l)); &#125; return m;&#125; 寻找第k大的数使用快速排序思想 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function getk(arr, left, right, k) &#123; var temp = arr[left];//基准数 var i = left;//副本可改变 var j = right;//副本可改变 var t;//临时交换值 if (i &gt;= j) &#123; return arr[i]; &#125; while (i != j) &#123; //从右侧找基准数大的放左边 while (arr[j] &lt;= temp &amp;&amp; i &lt; j) &#123; j--; &#125; //从左侧找基准数小的放右边 while (arr[i] &gt;= temp &amp;&amp; i &lt; j) &#123; i++; &#125; //交换i和j if (i != j) &#123; t = arr[i]; arr[i] = arr[j]; arr[j] = t; &#125; &#125; if (i == k) &#123; return temp; &#125; arr[left] = arr[i]; arr[i] = temp; if (k &lt; i) &#123; return getk(arr, left, i - 1, k); &#125; else if (k &gt; i) &#123; return getk(arr, i + 1, right, k); &#125;&#125;var arr = [1, 4, 2, 4, 5, 6, 3, 2, 1, 4, 22];console.log(getk(arr, 0, arr.length - 1, 5));//注意这里的k参数为下标值 数组乱序12345678var a = [1, 2, 3, 4, 5, 6, 7, 8, 9];var random = function(array) &#123; return array.sort(function()&#123;return Math.random() &gt; 0.5&#125;);&#125;;console.log(random(a)); 如果要某一定值不变就先将其用splice取出来，乱序完成在加进去。","categories":[],"tags":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"https://www.lisq.xyz/tags/算法和数据结构/"}]},{"title":"排序总结","slug":"排序总结","date":"2017-11-05T13:21:04.000Z","updated":"2018-10-28T14:29:27.902Z","comments":true,"path":"2017/11/05/排序总结/","link":"","permalink":"https://www.lisq.xyz/2017/11/05/排序总结/","excerpt":"","text":"冒泡排序基本思路： 从第一个数开始，和右侧的数比较，如果右侧比左侧小，交换左右位置。 这样第一轮比较后，最大的数排到最后。 第二轮比较，不用比较最后一个数。 优化算法 直接使用普通的冒泡排序，无论排序是否完成，都会执行数组的总个数次，实际情况下排序成功所需次数可能非常少。 所以优化思路就是在已经完成排序后跳出循环。 12345678910111213141516171819function bubling(arr) &#123; var isComplete; var temp; for (let i = 0; i &lt; arr.length - 1; i++) &#123; isComplete = true; for (let j = 0; j &lt; arr.length - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; a = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = a; isComplete = false; &#125; &#125; if (isComplete) &#123; break; &#125; &#125; return arr;&#125; 测试排序10000个数花费1113毫秒 插入排序思路对于给定的一组记录，初始时假设第一个记录自成一个有序序列，其余记录为无序序列。 从第二个记录开始，按照记录的大小依次将当期处理的记录插入到其之前的有序序列中，直至最后一个记录插入到有序序列为止。 思路： 取出第二个数，将它插入到由开头1个数组成的有序序列中。 取出第三个数，插入到开头2个数组成的有序序列中。 取出第n个数，插入到开头n-1个数组成的有序序列中。 直到n为最后一个数。 关键找到插入的节点m 让arr[m] - arr[i-1] 整体后移一位 1234567891011121314151617181920212223function insert(arr) &#123; //最大插入次数 n-1次 var temp; for (let i = 1; i &lt; arr.length; i++) &#123; var m = -1; for (let j = 0; j &lt; i; j++) &#123; if(arr[i]&lt;arr[j])&#123; m = j; break; &#125; &#125; if(m != -1)&#123; //将arr[i] 插入 arr[m] //即将arr[m] - arr[i-1]整体后移一位 temp = arr[i]; for (let j = i; j &gt; m; j--) &#123; arr[j] = arr[j-1]; &#125; arr[m] = temp; &#125; &#125; return arr;&#125; 一万个数花费700毫秒 上述实现可以改进： 不去先找m的位置，而是直接进行插入。 让i和有序序列从右到左开始比较，如果比较的值比i大，交换两个数的位置。 1234567891011121314function insert(arr) &#123; //最大插入次数 n-1次 var temp,j; for (let i = 1; i &lt; arr.length; i++) &#123; temp = arr[i]; j = i - 1; while( j&gt;=0 &amp;&amp; temp &lt; arr[j] )&#123; arr[j+1] = arr[j]; j--; &#125; arr[j+1] = temp; &#125; return arr;&#125; 快速排序思路 找出一个基准数 从右侧找比基准数小的 从左侧找比基准数大的 交换值直到没有可以交换的。 将基准数复位 将基准数左侧的数进行快排 将基准数右侧的数进行快排 关键退出快排的条件：left == right 先找基准数小的数 大于等于和小于等于（避免找到相同的数） 123456789101112131415161718192021222324252627282930313233343536function quick(arr,left,right) &#123; var temp = arr[left];//基准数 var i = left;//副本可改变 var j = right;//副本可改变 var t;//临时交换值 if(i&gt;=j)&#123; return; &#125; while(i!=j)&#123; //找到比基准数小的数 （如果没有比基准数小的数，那么i=j=left 不用做交换） while(arr[j]&gt;=temp &amp;&amp; i&lt;j )&#123; j--; &#125; //找到比基准数大的数 while (arr[i]&lt;=temp &amp;&amp; i&lt;j) &#123; i++; &#125; //交换i和j if(i!=j)&#123; t = arr[i]; arr[i] = arr[j]; arr[j] = t; &#125; &#125; arr[left] = arr[i]; arr[i] = temp; quick(arr,left,i-1); quick(arr,i+1,right);&#125; 一万个数花费7毫秒 优化版比temp小的数放在左数组里，比temp大的数放在右数组里，左数组+右数组+temp就是排序好的数。 12345678910111213141516function quick(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; let left = []; let right = []; let temp = arr[0]; for (let i = 1, l = arr.length; i &lt; l; i++) &#123; if (arr[i] &gt; temp) &#123; right.push(arr[i]); &#125; else &#123; left.push(arr[i]); &#125; &#125; return [].concat(quick(left), [temp], quick(right));&#125; 选择排序将每个数与开头数作比较，比它小则交换位置。重复比较n-1轮 12345678910111213function select(arr) &#123; var temp; for (let i = 0; i &lt; arr.length - 1; i++) &#123; for (let j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[i]) &#123; temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125; 希尔排序把记录按步长 gap 分组，对每组记录采用直接插入排序方法进行排序。随着步长逐渐减小，所分成的组包含的记录越来越多，当步长的值减小到 1 时，整个数据合成为一组，构成一组有序记录，则完成排序。 例子：9 1 2 5 7 4 8 6 3 5 gap是步长，也就是两个数之间的间隔。 gap=length/2 gap=gap/2 跳出循环的条件为gap&gt;0 插入排序 1234567891011121314function insert(arr) &#123; //最大插入次数 n-1次 var temp,j; for (let i = 1; i &lt; arr.length; i++) &#123; temp = arr[i]; j = i - 1; while( j&gt;=0 &amp;&amp; temp &lt; arr[j] )&#123; arr[j+1] = arr[j]; j--; &#125; arr[j+1] = temp; &#125; return arr; &#125; 给定增量值 123456789101112function shellSort(arr, gap) &#123; var temp, j; for (let i = gap; i &lt; arr.length; i++) &#123; temp = arr[i]; j = i - gap; while (j &gt; 0 &amp;&amp; temp &lt; arr[i]) &#123; arr[j + gap] = arr[j]; j -= gap; &#125; arr[j + 1] = temp; &#125;&#125; 增量值递减： 123456789101112131415161718function shell(arr) &#123; var gap = Math.floor(arr.length / 2); var temp, j; while (gap &gt; 0) &#123; console.log(gap); for (let i = gap; i &lt; arr.length; i++) &#123; temp = arr[i]; j = i - gap; while (j &gt;= 0 &amp;&amp; temp &lt; arr[j]) &#123; arr[j + gap] = arr[j]; j -= gap; &#125; arr[j + gap] = temp; &#125; gap = Math.floor(gap / 2); &#125; return arr;&#125;","categories":[],"tags":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"https://www.lisq.xyz/tags/算法和数据结构/"},{"name":"排序","slug":"排序","permalink":"https://www.lisq.xyz/tags/排序/"}]},{"title":"二叉树","slug":"二叉树","date":"2017-11-03T07:42:10.000Z","updated":"2018-10-28T14:28:15.200Z","comments":true,"path":"2017/11/03/二叉树/","link":"","permalink":"https://www.lisq.xyz/2017/11/03/二叉树/","excerpt":"","text":"基本结构插入，遍历，深度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293function Node(data, left, right) &#123; this.data = data; this.left = left; this.right = right;&#125;Node.prototype = &#123; show: function () &#123; console.log(this.data); &#125;&#125;function Tree() &#123; this.root = null;&#125;Tree.prototype = &#123; insert: function (data) &#123; var node = new Node(data, null, null); if (!this.root) &#123; this.root = node; return; &#125; var current = this.root; var parent = null; while (current) &#123; parent = current; if (data &lt; parent.data) &#123; current = current.left; if (!current) &#123; parent.left = node; return; &#125; &#125; else &#123; current = current.right; if (!current) &#123; parent.right = node; return; &#125; &#125; &#125; &#125;, preOrder: function (node) &#123; if (node) &#123; node.show(); this.preOrder(node.left); this.preOrder(node.right); &#125; &#125;, middleOrder: function (node) &#123; if (node) &#123; this.middleOrder(node.left); node.show(); this.middleOrder(node.right); &#125; &#125;, laterOrder: function (node) &#123; if (node) &#123; this.laterOrder(node.left); this.laterOrder(node.right); node.show(); &#125; &#125;, getMin: function () &#123; var current = this.root; while(current)&#123; if(!current.left)&#123; return current; &#125; current = current.left; &#125; &#125;, getMax: function () &#123; var current = this.root; while(current)&#123; if(!current.right)&#123; return current; &#125; current = current.right; &#125; &#125;, getDeep: function (node,deep) &#123; deep = deep || 0; if(node == null)&#123; return deep; &#125; deep++; var dleft = this.getDeep(node.left,deep); var dright = this.getDeep(node.right,deep); return Math.max(dleft,dright); &#125;&#125; 1234567891011121314var t = new Tree();t.insert(3);t.insert(8);t.insert(1);t.insert(2);t.insert(5);t.insert(7);t.insert(6);t.insert(0);console.log(t);// t.middleOrder(t.root);console.log(t.getMin(), t.getMax());console.log(t.getDeep(t.root, 0));console.log(t.getNode(5,t.root)); 树查找12345678910111213getNode: function (data, node) &#123; if (node) &#123; if (data === node.data) &#123; return node; &#125; else if (data &lt; node.data) &#123; return this.getNode(data,node.left); &#125; else &#123; return this.getNode(data,node.right); &#125; &#125; else &#123; return null; &#125;&#125; 利用二分的思想 二分查找二分查找的条件是必须是有序的线性表。 和线性表的中点值进行比较，如果小就继续在小的序列中查找，如此递归直到找到相同的值。 123456789101112131415function binarySearch(data, arr, start, end) &#123; if (start &gt; end) &#123; return -1; &#125; var mid = Math.floor((end + start) / 2); if (data == arr[mid]) &#123; return mid; &#125; else if (data &lt; arr[mid]) &#123; return binarySearch(data, arr, start, mid - 1); &#125; else &#123; return binarySearch(data, arr, mid + 1, end); &#125;&#125;var arr = [0, 1, 1, 1, 1, 1, 4, 6, 7, 8]console.log(binarySearch(1, arr, 0, arr.length-1));","categories":[],"tags":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"https://www.lisq.xyz/tags/算法和数据结构/"}]},{"title":"基本数据结构及特点","slug":"基本数据结构及特点","date":"2017-11-02T13:13:54.000Z","updated":"2018-10-28T14:28:45.117Z","comments":true,"path":"2017/11/02/基本数据结构及特点/","link":"","permalink":"https://www.lisq.xyz/2017/11/02/基本数据结构及特点/","excerpt":"","text":"什么是数据结构数据元素相互之间存在的一种和多种特定的关系集合 包括二个部分组成逻辑结构，存储结构。 逻辑结构 简单的来说 逻辑结构就是数据之间的关系,逻辑结构大概统一的可以分成两种 一种是线性结构，非线性结构 。 线性结构 是一个有序数据元素的集合。 其中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的。 常用的线性结构有: 栈，队列，链表，线性表。 非线性结构 各个数据元素不再保持在一个线性序列中，每个数据元素可能与零个或者多个其他数据元素发生联系。 常见的线性结构有 二维数组，树(二叉树等)等。 存储结构 逻辑结构指的是数据间的关系，而存储结构是逻辑结构用计算机语言的实现。 常见的存储结构有顺序存储、链式存储、索引存储以及散列存储（哈希表）。 时间复杂度一个算法的时间复杂度反映了程序运行从开始到结束所需要的时间。 把算法中基本操作重复执行的次数（频度）作为算法的时间复杂度。 没有循环语句，记作O(1)，也称为常数阶。 只有一重循环，则算法的基本操作的执行频度与问题规模n呈线性增大关系，记作O（n），也叫线性阶。 常用的还有平方阶O（n2）、立方阶O（n3）、对数阶O(log2n)等。 常见的时间复杂度有：1O(1)&lt; O(log2n)&lt; O（n）&lt; O（n2）&lt; O（ n3 ）&lt; O（ 2n ） 顺序表把线性表的结点按逻辑顺序一次存放在一组地址连续的存储单元中。 可以直接通过下标获取到数据，查询快。 插入和删除时要移动后续元素，还要考虑扩容问题，插入慢。 12345678910function List() &#123; // 列表的元素个数 this.listSize = 0; // 列表的当前位置 是第几个 this.pos = 0; // 初始化一个空数组来保存列表元素 this.dataStore = [];&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374List.prototype = (function () &#123; return &#123; clear: clear, find: find, toString: toString, insert: insert, append: append, remove: remove, front: front, end: end, prev: prev, next: next, hasNext: hasNext, hasPrev: hasPrev, length: length, currPos: currPos, moveTo: moveTo, getElement: getElement &#125;; /** * 给列表最后添加元素的时候，列表元素个数+1 * @param element */ function append(element) &#123; this.listSize++; this.dataSource.push(element); &#125; /** * @param element * @returns &#123;number&#125; 如果找到，返回位置，否则-1 */ function find(element) &#123; for (var i = 0; i &lt; this.dataSource.length; i++) &#123; if (this.dataSource[i] === element) &#123; return i; &#125; &#125; return -1; &#125; /** * 删除元素成功，元素个数-1 * @param element * @returns &#123;boolean&#125; */ function remove(element) &#123; var removeIndex = this.find(element); if (removeIndex !== -1) &#123; this.dataSource.splice(removeIndex, 1); this.listSize--; return true; &#125; return false; &#125; /** * 插入某个元素 * @param element 要插入的元素 * @param afterElement 列表中的元素之后 * @returns &#123;boolean&#125; */ function insert(element, afterElement) &#123; var insertIndex = this.find(afterElement); if (insertIndex !== -1) &#123; this.dataSource.splice(insertIndex + 1, 0, element); this.listSize++; return true; &#125; return false; &#125; &#125;()); 链表用一组任意存储的单元来存储线性表的数据元素。 一个对象存储着本身的值和下一个元素的地址。 需要遍历才能查询到元素，查询慢。 插入元素只需断开连接重新赋值，插入快。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function LinkList()&#123; function node(element)&#123; this.value = element; this.next = null; &#125; let length = 0; let head = null;&#125;LinkList.prototype = &#123; append:function(element)&#123; var node = new node(element); var temp = this.head; if(this.head)&#123; //遍历找到链表的终点 while(temp.next)&#123; temp = temp.next; &#125; temp.next = node; &#125;else&#123; this.head = node; &#125; this.length++; &#125;, insert:function(element,index)&#123; if(index &lt;= this.length &amp;&amp; index&gt;0)&#123; var node = new node(element); var currentIndex = 0; var currentNode = this.head; var preNode = null; if (currentIndex === 0) &#123; node.next = currentNode; this.head = node; return; &#125; while(currentIndex&lt;index)&#123; preNode = currentNode; currentNode = currentNode.next; currentIndex++; &#125; preNode.next = node; node.next = currentNode; this.length++; &#125; &#125;&#125; 链表翻转12345678910reverse: function (node) &#123; //把初始链表头当做基准点，移动下一个元素到头部，直到下一个元素为空 var currentNode = node.next; node.next = node.next.next; currentNode.next = this.head; this.head = currentNode; if(node.next)&#123; this.reverse(node); &#125; &#125;z 栈先进后出 进栈：push (在尾部插入元素) 出栈：pop（在尾部删除元素并返回此元素） 队列先进先出 进队列：unshift（在头部插入元素） 出队列：pop(在尾部删除元素并返回) 哈希表哈希的基本原理是将给定的键值转换为偏移地址来检索记录。 键转换为地址是通过一种关系（公式）来完成的，这就是哈希（散列）函数。 虽然哈希表是一种有效的搜索技术，但是它还有些缺点。两个不同的关键字，由于哈希函数值相同，因而被映射到同一表位置上。该现象称为冲突(Collision)或碰撞。发生冲突的两个关键字称为该哈希函数的同义词(Synonym)。 好的哈希函数的选择有两条标准： 1)简单并且能够快速计算 2)能够在址空间中获取键的均匀人分布 除余法是最为简单常用的一种方法。它是以表长m来除关键字，取其余数作为散列地址，即 h(key)=key％m 解决hash冲突：链表法 链表法解决冲突的做法是：将所有关键字为同义词的结点链接在同一个单链表中。 具体的关键字列表为（19,14,23,01,68,20,84,27,55,11,10,79），则哈希函数为H（key）=key MOD 13。则采用除留余数法和链地址法后得到的预想结果应该为： 哈希造表完成后，进行查找时，首先是根据哈希函数找到关键字的位置链，然后在该链中进行搜索，如果存在和关键字值相同的值，则查找成功，否则若到链表尾部仍未找到，则该关键字不存在。 插入元素：直接按地址插入到链表末尾。 综合了链表和数组的优点，查询插入都很快。 构造hash表 12345678function linklist()&#123; ...&#125;funtion hashtable&#123; length 0 data [] &#125;","categories":[],"tags":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"https://www.lisq.xyz/tags/算法和数据结构/"}]},{"title":"老版本浏览器兼容问题总结","slug":"老版本浏览器兼容问题总结","date":"2017-10-28T15:43:12.000Z","updated":"2018-10-28T14:30:06.650Z","comments":true,"path":"2017/10/28/老版本浏览器兼容问题总结/","link":"","permalink":"https://www.lisq.xyz/2017/10/28/老版本浏览器兼容问题总结/","excerpt":"","text":"1.ajax12345try&#123; xhr = new XMLHttpRequest();&#125;catch(e)&#123; xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);&#125;; 2.事件12345678var addEvent = function(element,type,callback)&#123; if(element.addEventListener)&#123; element.addEventListener(type,callback,false); &#125;else if(element.attachEvent)&#123; element.attachEvent(&apos;on&apos; + type,callback) &#125; &#125; 3.innerText123function getInnerText(element) &#123; return (typeof element.textContent == &quot;string&quot;) ? element.textContent : element.innerText;&#125; 4.indexof()IE8以下不兼容indexof()方法, 添加indexof的原型方法即可；12345if (!Array.prototype.indexOf)&#123; Array.prototype.indexOf = function(elt)&#123; ... &#125;;&#125; 5.父节点parentElement1234ele.parentElement//firebox不支持ele.parentNode//通用 6.setattribute1234object.setAttribute(&quot;class&quot;,&quot;style&quot;);//在IE8、Chrome、火狐、Opera10中都能设置成功；但是在IE7下无法设置。object.setAttribute(&quot;className&quot;,&quot;className&quot;);//只有IE7能设置成功，但是其他浏览器均无法设置。 7.IE6 高度无法小于10px12添加overflow的属性设置font-size的属性为高度的大小 8.双倍float123456.divBox&#123; float:left; width:100px; margin:0 0 0 100px; //这种情况之下IE会产生200px的距离 display:inline; //使浮动忽略&#125;","categories":[],"tags":[{"name":"浏览器兼容","slug":"浏览器兼容","permalink":"https://www.lisq.xyz/tags/浏览器兼容/"}]},{"title":"git分支操作","slug":"git分支操作","date":"2017-10-21T13:02:18.000Z","updated":"2018-10-31T15:30:16.136Z","comments":true,"path":"2017/10/21/git分支操作/","link":"","permalink":"https://www.lisq.xyz/2017/10/21/git分支操作/","excerpt":"","text":"应用场景，代码运行过程中一部分要上线，新修改的代码不能影响上线代码，上线代码和正在修改的代码就要使用两个分支。 开发分支，线上分支 查看本地分支：1git branch 查看远程分支1git branch -a 创建分支：1git branch dev 创建并切换分支1git checkout -b dev 切换分支1git checkout master 提交到远程分支1git push origin dev 与另一个分支代码合并（切换到master后）1git merge dev 流程： 创建本地dev分支 提交代码到本地dev分支 提交本地dev分支到远程dev分支 合并本地master分支和本地dev分支 提交本地master分支到远程master分支","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://www.lisq.xyz/tags/git/"},{"name":"版本控制","slug":"版本控制","permalink":"https://www.lisq.xyz/tags/版本控制/"}]},{"title":"本地git链接到github","slug":"本地git链接到github","date":"2017-09-20T15:07:36.000Z","updated":"2018-10-28T14:29:37.134Z","comments":true,"path":"2017/09/20/本地git链接到github/","link":"","permalink":"https://www.lisq.xyz/2017/09/20/本地git链接到github/","excerpt":"","text":"本地git服务器与github建立链接Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。 我们使用GitHub完全可以代替这个中心仓库，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。 由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置： 第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key： 1ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。 如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有==id_rsa==和==id_rsa.pub==两个文件，这两个就是SSH Key的秘钥，==id_rsa==是私钥，不能泄露出去，==id_rsa.pub==是公钥，可以放心地告诉任何人。 第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面： 然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴==id_rsa.pub==文件的内容： 为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。 当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。 推送本地代码到github你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。 首先，登陆GitHub，然后，在右上角找到“Create a new project”按钮，创建一个新的仓库： 在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库： 目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。 现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令： 1git remote add origin git@github.com:michaelliao/learngit.git 注意 ==git remote add origin==后面的部分是你在上图看到的你自己的链接，每个人的都不相同。 如果你没有修改，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。 添加后，远程库的名字就是==origin==，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。 下一步，就可以把本地库的所有内容推送到远程库上： 1git push -u origin master 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的==master==分支内容推送的远程新的==master==分支，还会把本地的==master==分支和远程的==master==分支关联起来，在以后的推送或者拉取时就可以简化命令。 推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样： 从现在起，只要本地作了提交，就可以通过命令： 1git push origin master 从远程库克隆1git clone git@github.com:michaelliao/gitskills.git 注意把Git库的地址换成你自己的，然后进入gitskills目录看看，已经有README.md文件了。 如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://www.lisq.xyz/tags/git/"},{"name":"版本控制","slug":"版本控制","permalink":"https://www.lisq.xyz/tags/版本控制/"},{"name":"github","slug":"github","permalink":"https://www.lisq.xyz/tags/github/"}]},{"title":"git工作区和暂存区","slug":"git工作区和暂存区","date":"2017-09-09T12:56:00.000Z","updated":"2018-10-28T14:26:05.779Z","comments":true,"path":"2017/09/09/git工作区和暂存区/","link":"","permalink":"https://www.lisq.xyz/2017/09/09/git工作区和暂存区/","excerpt":"","text":"Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。 工作区（Working Directory） 就是你在电脑里能看到的目录，比如我的myproject文件夹就是一个工作区： 版本库（Repository） 工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 Git的版本库里存了很多东西，其中最重要的就是称为==stage==（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支==master==，以及指向==master==的一个指针叫==HEAD==。 第一步是用==git add==把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用==git commit==提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个==master==分支，所以，现在，==git commit==就是往==master==分支上提交更改。 你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 先对==readme.txt==做个修改，比如加上一行内容： 123Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage. 然后，在工作区新增一个==LICENSE==文本文件（内容随便写）。 先用==git status==查看一下状态： 1234567891011121314G:\\myproject&gt;git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txtUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) LICENSE.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) Git非常清楚地告诉我们，==readme.txt==被修改了，而==LICENSE==还从来没有被添加过，所以它的状态是==Untracked==。 现在，使用两次命令==git add==，把==readme.txt==和==LICENSE==都添加后，用==git status==再查看一下： 1234567G:\\myproject&gt;git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: LICENSE.txt modified: readme.txt 现在，暂存区的状态就变成这样了： 所以，==git add==命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行==git commit==就可以一次性把暂存区的所有修改提交到分支。 1234G:\\myproject&gt;git commit -m &quot;fourth&quot;[master 9069b76] fourth 2 files changed, 3 insertions(+), 1 deletion(-) create mode 100644 LICENSE.txt 一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的： 123G:\\myproject&gt;git statusOn branch masternothing to commit, working tree clean 现在版本库变成了这样，暂存区就没有任何内容了： 每次修改，如果不==add==到暂存区，那就不会加入到==commit==中。 所以为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://www.lisq.xyz/tags/git/"},{"name":"版本控制","slug":"版本控制","permalink":"https://www.lisq.xyz/tags/版本控制/"}]},{"title":"git基本操作","slug":"git基本操作","date":"2017-09-08T13:47:57.000Z","updated":"2018-10-26T11:43:11.244Z","comments":true,"path":"2017/09/08/git基本操作/","link":"","permalink":"https://www.lisq.xyz/2017/09/08/git基本操作/","excerpt":"","text":"创建版本库版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 第一步很简单，就是找到你想让git管理的项目目录或者新建一个目录。 第二步，通过git init命令把这个目录变成Git可以管理的仓库： 12G:\\myproject&gt;git initInitialized empty Git repository in G:/myproject/.git/ 瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。 如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。 上传文件到版本库我们编写一个readme.txt文件，内容如下： 12Git is a version control system.Git is free software. 一定要放到版本库目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。 第一步，用命令git add告诉Git，把文件添加到仓库： 1G:\\myproject&gt;git add readme.txt 执行上面的命令，没有任何显示，这就对了 第二步，用命令git commit告诉Git，把文件提交到仓库： 1234G:\\myproject&gt;git commit -m &quot;first time&quot;[master (root-commit) 6d5bb1a] first time 1 file changed, 2 insertions(+) create mode 100644 readme.txt 简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容,当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。 git commit命令执行成功后会告诉你，1个文件被改动（我们新添加的readme.txt文件），插入了两行内容（readme.txt有两行内容）。 为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如： 123$ git add file1.txt$ git add file2.txt file3.txt$ git commit -m &quot;add 3 files.&quot; 查看文件修改信息我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件，改成如下内容： 12Git is a distributed version control system.Git is free software. 现在，运行git status命令看看结果： 123456789G:\\myproject&gt;git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) git status命令可以让我们时刻掌握仓库当前的状态，上面的命令告诉我们，readme.txt被修改过了，但还没有准备提交的修改。 虽然Git告诉我们readme.txt被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的readme.txt，所以，需要用git diff这个命令看看： 123456789101112G:\\myproject&gt;git diffdiff --git a/readme.txt b/readme.txtindex 188e70b..013b5bc 100644--- a/readme.txt+++ b/readme.txt@@ -1,2 +1,2 @@-Git is a version control system.-Git is free software.1\\ No newline at end of file+Git is a distributed version control system.+Git is free software.\\ No newline at end of file 可以从上面的命令输出看到，我们在第一行添加了一个“distributed”单词。知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了。 版本回退现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下： 然后尝试提交： 12345G:\\myproject&gt;git add readme.txtG:\\myproject&gt;git commit -m &quot;third&quot;[master 52a89b8] third 1 file changed, 1 insertion(+), 1 deletion(-) 我们可以使用 git log 命令查看我们一共有几个版本提交到git版本库中了 123456789101112131415161718G:\\myproject&gt;git logcommit 52a89b86b2b54f223e17a84801ae6f78d01f3057Author: admin &lt;admin@qq.com&gt;Date: Sat Sep 9 09:26:06 2017 +0800 thirdcommit 95c55bfa753a2827e499b5ab2f58b442fedc8a4fAuthor: admin &lt;admin@qq.com&gt;Date: Fri Sep 8 22:10:53 2017 +0800 secondcommit 6d5bb1a4018c70bd01e4927c4c5af8449ef8aad5Author: admin &lt;admin@qq.com&gt;Date: Fri Sep 8 21:05:49 2017 +0800 first time git log命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是third，上一次是second，最早的一次是first time。如果嫌输出信息太多，看得眼花缭乱的，可以试试加上–pretty=oneline参数： 1234G:\\myproject&gt;git log --pretty=oneline52a89b86b2b54f223e17a84801ae6f78d01f3057 third95c55bfa753a2827e499b5ab2f58b442fedc8a4f second6d5bb1a4018c70bd01e4927c4c5af8449ef8aad5 first time 你看到的一大串类似3628164…882e1e0的是commit id（版本号） 好了，现在我们启动时光穿梭机，准备把readme.txt回退到上一个版本，也就是“second”的那个版本，怎么做呢？ Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交3628164…882e1e0（注意我的提交ID和你的肯定不一样）， 上一个版本就是1HEAD^ 上上一个版本就是1HEAD^^ 当然往上100个版本写1100个^ 比较容易数不过来，所以写成1HEAD~100 12git reset --hard HEAD~1HEAD is now at 95c55bf second 这样我们就回退到了第二个版本,此时HEAD也指向了second版本 12Git is a distributed version control system.Git is free software. 在使用git log命令查看版本情况 123456789101112G:\\myproject&gt;git logcommit 95c55bfa753a2827e499b5ab2f58b442fedc8a4fAuthor: admin &lt;admin@qq.com&gt;Date: Fri Sep 8 22:10:53 2017 +0800 secondcommit 6d5bb1a4018c70bd01e4927c4c5af8449ef8aad5Author: admin &lt;admin@qq.com&gt;Date: Fri Sep 8 21:05:49 2017 +0800 first time 如果你现在又想回到third版本怎么办？只需要找到third版本的版本号，版本号没必要写全，前几位就可以了，Git会自动去找。 可以使用git reflog命令查看以前每次版本的版本号（这个命令用于查看你的每一次操作） 12345G:\\myproject&gt;git reflog95c55bf HEAD@&#123;0&#125;: reset: moving to HEAD~152a89b8 HEAD@&#123;1&#125;: commit: third95c55bf HEAD@&#123;2&#125;: commit: second6d5bb1a HEAD@&#123;3&#125;: commit (initial): first time 我们看到thid版本的版本号前几位是52a89b8，输入如下命令： 12git reset --hard 52a89bHEAD is now at 52a89b third 这是readme的内容又回到了third版本。 撤销修改凌晨两点，你正在赶一份工作报告，你在readme.txt中添加了一行： 12345Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.My stupid boss still prefers SVN. 在你准备提交前，一杯咖啡起了作用，你猛然发现了“stupid boss”可能会让你丢掉这个月的奖金！ 既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用git status查看一下： 123456789G:\\myproject&gt;git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 你可以发现，Git会告诉你，git checkout – file可以丢弃工作区的修改： 1git checkout -- readme.txt 命令git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 git checkout – file命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://www.lisq.xyz/tags/git/"},{"name":"版本控制","slug":"版本控制","permalink":"https://www.lisq.xyz/tags/版本控制/"}]},{"title":"git命令大全","slug":"git命令大全","date":"2017-09-08T05:10:01.000Z","updated":"2018-10-26T11:43:11.246Z","comments":true,"path":"2017/09/08/git命令大全/","link":"","permalink":"https://www.lisq.xyz/2017/09/08/git命令大全/","excerpt":"","text":"指令 作用 git init 创建版本库 git add 将工作区文件放到暂存区,可反复多次使用，添加多个文件 git commit 将暂存区文件放到分支 git statu 查看仓库当前状况（有多少文件修改，在什么位置） git diff 查看文件具体做了什么修改 git log 查看提交历史，以便确定要回退到哪个版本 git reset 重新设定版本 HEAD HEAD代表当前版本，HEAD~100代表回退一百个版本 git reflog 查看命令历史，以便确定要回到未来的哪个版本 git remote add origin 后面跟远程版本库的唯一url，表示本地版本库和远程版本库建立连接 git push -u origin master 将本地版本库commit过的内容提交到远程版本库的marster分支 git clone 从远程版本库克隆代码 git add . 提交所有修改到暂存区 git rebase 用于把一个分支的修改合并到当前分支","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://www.lisq.xyz/tags/git/"},{"name":"版本控制","slug":"版本控制","permalink":"https://www.lisq.xyz/tags/版本控制/"}]},{"title":"一款非常好用的全景生成，全景标记编辑插件","slug":"一款非常好用的全景生成，全景标记编辑插件","date":"2017-08-24T14:56:47.000Z","updated":"2018-10-28T14:28:07.284Z","comments":true,"path":"2017/08/24/一款非常好用的全景生成，全景标记编辑插件/","link":"","permalink":"https://www.lisq.xyz/2017/08/24/一款非常好用的全景生成，全景标记编辑插件/","excerpt":"","text":"最近一直在研究全景功能，于是封装成一个方便小巧的插件以便大家使用！ 插件包括两部分：全景展示部分，全景标记编辑部分，二者结合使用非常方便！ 使用插件首先需要引用 three.js 1.全景展示1.1 参数说明 参数名称 类型 说明 container string 存放全景的容器id url string 存放全景图片的路径 lables array {position:{lon:经度,lat:纬度},logoUrl:’logo路径’,text:’内容’} widthSegments num 水平切段数 heightSegments num 垂直切段数（值小粗糙速度快，值大精细速度慢） pRadius num 全景球的半径，影响视觉效果，推荐使用默认值 minFocalLength num 镜头最小拉近距离 maxFocalLength num 镜头最大拉近距离 showlable ‘show’/‘click’ 显示标记的方式，分为直接显示和点击显示 1.2 公用方法 方法名称 说明 config 给全景对象设置配置信息 init 初始化全景对象 clean 清除全景对象 1.3 使用初始化：（参数不设置则采用默认参数） 123456789101112131415161718var opt,tp;window.onload = function () &#123; opt = &#123; container:'panoramaConianer',//容器 url:'img/p1.png', lables:[ &#123;position:&#123;lon:180,lat:0&#125;,logoUrl:'',text:'我是一个标记'&#125; ], widthSegments: 60,//水平切段数 heightSegments: 40,//垂直切段数（值小粗糙速度快，值大精细速度慢） pRadius: 1000,//全景球的半径，推荐使用默认值 minFocalLength: 6,//镜头最a小拉近距离 maxFocalLength: 100,//镜头最大拉近距离 showlable: 'show' // show,click &#125; tp = new tpanorama(opt); tp.init();&#125; 修改某些参数 123456opt.showlable = 'click';opt.lables = [&#123;position:&#123;lon:180,lat:0&#125;,logoUrl:'img/logo.png',text:'点击了这个标记'&#125;];opt.url = 'img/p1.png';tp.clean();tp.config(opt);tp.init(); 2.添加全景标记工具在展示全景的时候，你或许会对标记的位置产生了疑问，如何确定标记的位置？ 我们可以使用类似经纬度的参数来表达它，注意这里使用的经纬度并不是真正的经纬度，是我们根据地球的经纬度模拟出来的一个参数。 下面这个工具就是用于获取我们想标记位置的 ‘经纬度’的一种方法，有了这个工具就可以完美结合上面的全景展示工具来使用了。 2.1 参数说明 参数名称 类型 说明 container string 存放全景设置的容器id imgUrl string 全景图路径 width string 指定宽度（这里图片必须严格按比例放置），高度自适应 showGrid bool 是否显示全景图的网格 showPosition bool 是否显示经纬度信息框 lableColor string 标记在图上的颜色 gridColor string 绘制格网的颜色 lables array 以前标记过的标记 {lon:114,lat:38,text:’标记一’} addLable bool 是否开启双击添加标记(必须开启经纬度提示) getLable bool 是否开启右键查询标记 (必须开启经纬度提示) deleteLbale bool 开启默认中键删除 （必须开启经纬度提示） 2.2 公共方法 方法名称 说明 config 给全景对象重新设置配置信息 init 初始化全景设置对象 getAllLables 获取所有已经添加的标记 addLable 用于手动设置添加标记 getLable 用于手动设置获取标记 delete 用于手动删除标记 listen 对全景对象监听事件 2.3 使用2.3.1 默认参数使用使用默认参数，对标记的增删查改已封装好，所有标记设置完成时可使用getAll方法与数据库进行交互 初始化（参数不设置则采用默认参数） 1234567891011121314151617181920var opt,s;window.onload = function () &#123; opt = &#123; container: 'set',//setting容器 imgUrl: 'img/p3.png', width: '1000px',//指定宽度，高度自适应 showGrid: true,//是否显示格网 showPosition: true,//是否显示经纬度提示 lableColor: '#9400D3',//标记颜色 gridColor: '#48D1CC',//格网颜色 lables: [ &#123;lon:-72.00,lat:9.00,text:'蓝窗户'&#125;,&#123;lon:114.12,lat:69.48,text:'一片云彩'&#125;,&#123;lon:132.48,lat:-12.24,text:'大海'&#125; ],//标记 &#123;lon:114,lat:38,text:'标记一'&#125; addLable: true,//开启后双击添加标记 (必须开启经纬度提示) getLable: true,//开启后右键查询标记 (必须开启经纬度提示) deleteLbale:true//开启后中键删除(必须开启经纬度提示) &#125;; s = new tpanoramaSetting(opt); s.init();&#125; 参数切换 123456789101112131415function changeImg(name) &#123; if (name == \"p1\")&#123; opt.lables = [&#123;lon:178.56,lat:-15.84,text:'神像'&#125;] &#125; if (name == \"p2\")&#123; opt.lables = [&#123;lon:-80.64,lat:-16.92,text:'蓝色'&#125;,&#123;lon:46.80,lat:10.44,text:'绿色'&#125;] &#125; if (name == \"p4\")&#123; opt.lables = [&#123;lon:48.96,lat:-20.16,text:'樱花'&#125;] &#125; opt.imgUrl = 'img/'+name+'.png'; s.clean(); s.config(opt); s.init();&#125; 2.3.2 自定义事件很多情况下默认参数不能满足我们的业务需求，这时可以自定义事件。 插件提供了listen函数用于监听各种事件。 添加标记： 1234567s.listen('dblclick',function (e) &#123; var text = prompt(\"标记名称\"); if (text!=null &amp;&amp; text!= undefined &amp;&amp; text!=\"\") &#123; s.addLable(e,text); alert(\"添加标记：\"+text+\" 后台交互\"); &#125;&#125;); 查询标记: 12345678s.listen('mousedown',function (e) &#123; if (e.button == 2) &#123; var p = s.getLable(e); if (p.lon!=null &amp;&amp;p.lon!=undefined&amp;&amp;p.lon!=\"\" ) &#123; alert(\"经度：\" + p.lon + \",纬度：\" + p.lat + \",名称：\" + p.text +\" 其他操作\"); &#125; &#125;&#125;); 删除标记: 1234567891011121314s.listen('mousedown',function (e) &#123; if (e.button == 1) &#123; var p = s.getLable(e); if (p.lon!=null &amp;&amp;p.lon!=undefined&amp;&amp;p.lon!=\"\" ) &#123; var c = confirm(\"您确认要删除该标记吗？\"); if (c) &#123; s.delete(p); s.clean(); s.init(); alert(\"删除成功！ 后台交互\") &#125; &#125; &#125;&#125;); 完整源码及DEMO地址：https://github.com/ConardLi/tpanorama","categories":[],"tags":[{"name":"三维","slug":"三维","permalink":"https://www.lisq.xyz/tags/三维/"},{"name":"全景","slug":"全景","permalink":"https://www.lisq.xyz/tags/全景/"},{"name":"three.js","slug":"three-js","permalink":"https://www.lisq.xyz/tags/three-js/"}]},{"title":"webgl基础","slug":"webgl基础","date":"2017-07-09T02:47:34.000Z","updated":"2018-10-28T14:27:32.242Z","comments":true,"path":"2017/07/09/webgl基础/","link":"","permalink":"https://www.lisq.xyz/2017/07/09/webgl基础/","excerpt":"","text":"1. canvas和webglWebGL是利用canvas来实现的 canvas和img等标签一样，是一个可以自由制定大小的矩形区域。 通过javascript可以对矩形区域进行操作，可以自由的绘制图形，文字等。而且，可以添加影子，进行涂色，另外还可以对绘制的图形进行旋转等操作。 一般使用canvas都是使用它的2d的context功能，但是也仅限于此，像它的名字一样，只能用于2d空间的绘图。 和这个相对的，WebGL是三维，可以描画3D图形，区别于之前的2dcontext，它叫做webglcontext。 2. 3D绘图基础利用WebGL可以模拟三维空间，但是最终必须输出显示在一个二维的显示器上。由深度决定的前后关系，根据远近进行放大和缩小，这些都必须提前进行运算得出结果。 这时候，坐标变换就是必须的了。坐标变换大致可以分为三种，将这些正确的组合在一起，最终决定显示器上的位置。 模型变换：第一种变换 定义参照物在三维空间的什么位置。假设，虚拟的三维空间里有一个苹果，那么为了表示这个苹果在什么位置，就需要进行相应的模型变换了。 视图变换：第二种变换 为了决定镜头的位置和角度所进行的坐标变换就叫做视图变换。即使三维空间中有一个苹果，如果镜头的方向不对着苹果的话，同样也是看不到这个苹果的。而且，如果将镜头大幅度远离苹果，那么也有可能看不到苹果了。 投影变换：这个变换，定义了三维空间的摄影区域。比如，是横向摄影，还是纵向摄影，最远拍摄多远距离等。 3. 矩阵矩阵虽然有很多种，其中的一种叫做方阵。就是行数和列数相同的矩阵。 一般的3D渲染的世界中使用的是4x4的矩阵。 实际3D渲染的时候，准备好模型坐标变换，视图坐标变换，投影坐标变换的各个矩阵。再具体一点，就是准备好各种坐标变换的矩阵，然后相乘。将最终得到的矩阵传给WebGL的顶点着色器。 矩阵可以将上面提到的变换保存起来，比如，如果是模型变换的矩阵，想要绘制的3D模型的位置，扩大缩小，以及旋转等信息，都可以定义在一个矩阵中。视图变换矩阵，镜头的位置，镜头的方向，以及镜头对准了哪个点（注视点）等可以定义在一个矩阵中。投影变换矩阵的话，显示的横竖比例和视角等信息可以定义在一个矩阵中。 需要注意一点，如果是普通的数学计算，相乘的时候，不需要注意相乘的顺序，比如2x3等于6，3x2也等于6。但是矩阵的话，根据相乘的顺序得出的结果是不同的。因为矩阵的这种性质，所以进行模型，视图，投影的矩阵相乘的时候，要特别注意相乘的顺序。 顶点着色器从传过来的矩阵中，获取到模型的坐标，加工到画面上显示出来。也就是说，操作坐标变换的矩阵，就可以决定模型在画面上如何绘制。 4. webgl可描述的东西要说在WebGL的世界里能够描画什么，其实任何东西都可以描画。而描画的最基本的东西就是下面几种。 点 线段 三角形 WebGL就是使用三角形在画面上绘制一些东西。这个三角形就是一个多边形，一个多边形至少是将三个顶点连接画出来的三角形，所以一个绘制一个多边形，最少需要三个顶点。 顶点，就是三维空间上存在的一个点。当然，这个点需要有坐标位置。顶点的横坐标是x，纵坐标是y，深度是z。将包含这些信息的点连接起来就形成了一个多边形。 非常逼真的3D游戏用了你想像不到的大量的三角形，制作出了无比精美的人物和场景。 想要绘制复杂构造的模型的话，需要准备大量的非常小的多边形。用的多边形越少，绘制的模型的棱角就越明显。 想要绘制精美的模型，就需要更多的多边形，当然，这些多边形的数量增加的话，定点数量也会成倍成倍的增加，坐标计算的负荷就越大。 顶点链接顺序和遮挡剔除3D渲染的世界里，看不到的东西不绘制的是减轻负担的最普通的方法。这就叫做遮挡剔除，如果设定了遮挡剔除，就只会绘制外侧看得见的多边形，内侧的所有多边形就都不再进行绘制了。 顺时针连接顶点的多边形是在外侧，而逆时针连接的多边形在内侧。所以，在定义顶点情报的时候，要特别注意。如果设定了遮挡剔除，本来应该在某个位置有个多边形，但是根本就不会进行绘制。 5.context初始化12345678window.onload = function () &#123; var c = document.getElementById('canvas'); c.width = 500; c.height = 300; var gl = c.getContext('webgl') || c.getContext('experimental-webgl'); gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.clear(gl.COLOR_BUFFER_BIT);&#125; 1gl.clear(gl.COLOR_BUFFER_BIT); 这个函数将画面清空，回到一个全新的状态。参数是要清空的对象，或者是WebGL中定义的常量。这一次，只是清空一下画面上的颜色，所以使用COLOR_BUFFER_BIT这个常量，这个常量是为了使用canvas里面指定的颜色来清空画面而定义的。 1gl.clearColor(0.0, 0.0, 0.0, 1.0); 如果要清空画面所使用的颜色的话，就必须得另外定义了。这个函数是clearColor。clearColor函数的参数有四个，就是单纯的RGBA，很直观吧，使用方法如下。 6.着色器WebGL中，所谓的固定渲染管线是不存在的。 固定渲染管线，简单来说，就是3d渲染所进行的一连串的计算流程，就像流水线一样。如果有了固定渲染管线，编写程序就比较容易了，因为所有的变换都是由固定渲染管线来完成的，但是缺点就是自由度低。固定渲染管线只能完成一些最基本的操作，如果想要做一些特殊的处理，就比较麻烦了。 WebGL中不存在固定渲染管线。也就是说，坐标变换必须全部由自己来做。而且，这个记述了坐标变换的机制就叫做着色器(Shader)。 这样可以由程序员控制的机制叫做可编辑渲染管线。而着色器又有 处理几何图形顶点的顶点着色器和处理像素的片段着色器两种类型。由于WebGL中没有固定管线，所以必须准备好顶点着色器和片段着色器。 着色器的添加可以有多种做法。着色器是由程序员自己编写的，而且着色器的代码就是简单的字符串而已。所以，不管用什么方法，只要把这个着色器字符串传给程序就可以了。 最简单的方法，就是把着色器记录在HTML中。使用这种方法的话，是利用HTML的script标签来做的。下面是一个简单的例子。 1234567&lt;script id=\"vshader\" type=\"x-shader/x-vertex\"&gt; ※顶点着色器 &lt;/script&gt; &lt;script id=\"fshader\" type=\"x-shader/x-fragment\"&gt; ※片段着色器 &lt;/script&gt; 指定type属性的理由:type属性指定了［x-shader/x-vertex］和［x-shader/x-fragment］，这并不是HTML中定义的正式的写法。但是一般的浏览器如果遇到不识别的标签的话会无视掉的，浏览器不会认为这是javascript代码的。浏览器只会把它当成无意义的字符串，而程序中则可以使用标签里面的内容。","categories":[],"tags":[{"name":"webgl","slug":"webgl","permalink":"https://www.lisq.xyz/tags/webgl/"},{"name":"三维","slug":"三维","permalink":"https://www.lisq.xyz/tags/三维/"}]}]}