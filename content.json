{"meta":{"title":"李世奇的技术专栏","subtitle":null,"description":"Fe Coder","author":"ConardLi","url":"https://www.lisq.xyz"},"pages":[{"title":"about","date":"2018-10-28T15:07:13.000Z","updated":"2018-11-03T15:46:49.634Z","comments":true,"path":"about/index.html","permalink":"https://www.lisq.xyz/about/index.html","excerpt":"","text":"关于，以后再说…….."}],"posts":[{"title":"【React深入】从Mixin到HOC再到Hook","slug":"【React深入】从Mixin到HOC再到Hook","date":"2019-04-09T15:27:27.000Z","updated":"2019-04-09T15:28:00.607Z","comments":true,"path":"2019/04/09/【React深入】从Mixin到HOC再到Hook/","link":"","permalink":"https://www.lisq.xyz/2019/04/09/【React深入】从Mixin到HOC再到Hook/","excerpt":"","text":"导读前端发展速度非常之快，页面和组件变得越来越复杂，如何更好的实现状态逻辑复用一直都是应用程序中重要的一部分，这直接关系着应用程序的质量以及维护的难易程度。 本文介绍了React采用的三种实现状态逻辑复用的技术，并分析了他们的实现原理、使用方法、实际应用以及如何选择使用他们。 本文略长，下面是本文的思维导图，您可以从头开始阅读，也可以选择感兴趣的部分阅读： Mixin设计模式 Mixin（混入）是一种通过扩展收集功能的方式，它本质上是将一个对象的属性拷贝到另一个对象上面去，不过你可以拷贝任意多个对象的任意个方法到一个新对象上去，这是继承所不能实现的。它的出现主要就是为了解决代码复用问题。 很多开源库提供了Mixin的实现，如Underscore的_.extend方法、JQuery的extend方法。 使用_.extend方法实现代码复用： 12345678910111213141516var LogMixin = &#123; actionLog: function() &#123; console.log('action...'); &#125;, requestLog: function() &#123; console.log('request...'); &#125;,&#125;;function User() &#123; /*..*/ &#125;function Goods() &#123; /*..*/ &#125;_.extend(User.prototype, LogMixin);_.extend(Goods.prototype, LogMixin);var user = new User();var good = new Goods();user.actionLog();good.requestLog(); 我们可以尝试手动写一个简单的Mixin方法： 12345678910111213141516function setMixin(target, mixin) &#123; if (arguments[2]) &#123; for (var i = 2, len = arguments.length; i &lt; len; i++) &#123; target.prototype[arguments[i]] = mixin.prototype[arguments[i]]; &#125; &#125; else &#123; for (var methodName in mixin.prototype) &#123; if (!Object.hasOwnProperty(target.prototype, methodName)) &#123; target.prototype[methodName] = mixin.prototype[methodName]; &#125; &#125; &#125;&#125;setMixin(User,LogMixin,'actionLog');setMixin(Goods,LogMixin,'requestLog'); 您可以使用setMixin\b方法将任意对象的任意方法扩展到目标对象上。 React中应用MixinReact也提供了Mixin的实现，如果完全不同的组件有相似的功能，我们可以引入来实现代码复用，当然只有在使用createClass来创建React组件时才可以使用，因为在React组件的es6写法中它已经被废弃掉了。 例如下面的例子，很多组件或页面都需要记录用户行为，性能指标等。如果我们在每个组件都引入写日志的逻辑，会产生大量重复代码，通过Mixin我们可以解决这一问题： 12345678910111213141516171819202122232425var LogMixin = &#123; log: function() &#123; console.log('log'); &#125;, componentDidMount: function() &#123; console.log('in'); &#125;, componentWillUnmount: function() &#123; console.log('out'); &#125;&#125;;var User = React.createClass(&#123; mixins: [LogMixin], render: function() &#123; return (&lt;div&gt;...&lt;/div&gt;) &#125;&#125;);var Goods = React.createClass(&#123; mixins: [LogMixin], render: function() &#123; return (&lt;div&gt;...&lt;/div&gt;) &#125;&#125;); Mixin带来的危害React官方文档在Mixins Considered Harmful一文中提到了Mixin带来了危害： Mixin 可能会相互依赖，相互耦合，不利于代码维护 不同的Mixin中的方法可能会相互冲突 Mixin非常多时，组件是可以感知到的，甚至还要为其做相关处理，这样会给代码造成滚雪球式的复杂性 React现在已经不再推荐使用Mixin来解决代码复用问题，因为Mixin带来的危害比他产生的价值还要巨大，并且React全面推荐使用高阶组件来替代它。另外，高阶组件还能实现更多其他更强大的功能，在学习高阶组件之前，我们先来看一个设计模式。 装饰模式 装饰者(decorator)模式能够在不改变对象自身的基础上，在程序运行期间给对像动态的添加职责。与继承相比，装饰者是一种更轻便灵活的做法。 高阶组件（HOC） 高阶组件可以看作React对装饰模式的一种实现，高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。 高阶组件（HOC）是React中的高级技术，用来重用组件逻辑。但高阶组件本身并不是React API。它只是一种模式，这种模式是由React自身的组合性质必然产生的。 123456789function visible(WrappedComponent) &#123; return class extends Component &#123; render() &#123; const &#123; visible, ...props &#125; = this.props; if (visible === false) return null; return &lt;WrappedComponent &#123;...props&#125; /&gt;; &#125; &#125;&#125; 上面的代码就是一个HOC的简单应用，函数接收一个组件作为参数，并返回一个新组件，新组建可以接收一个visible props，根据visible的值来判断是否渲染Visible。 下面我们从以下几方面来具体探索HOC。 HOC的实现方式属性代理函数返回一个我们自己定义的组件，然后在render中返回要包裹的组件，这样我们就可以代理所有传入的props，并且决定如何渲染，实际上 ，这种方式生成的高阶组件就是原组件的父组件，上面的函数visible就是一个HOC属性代理的实现方式。 1234567function proxyHOC(WrappedComponent) &#123; return class extends Component &#123; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; /&gt;; &#125; &#125;&#125; 对比原生组件增强的项： 可操作所有传入的props 可操作组件的生命周期 可操作组件的static方法 获取refs 反向继承返回一个组件，继承原组件，在render中调用原组件的render。由于继承了原组件，能通过this访问到原组件的生命周期、props、state、render等，相比属性代理它能操作更多的属性。 1234567function inheritHOC(WrappedComponent) &#123; return class extends WrappedComponent &#123; render() &#123; return super.render(); &#125; &#125;&#125; 对比原生组件增强的项： 可操作所有传入的props 可操作组件的生命周期 可操作组件的static方法 获取refs 可操作state 可以渲染劫持 HOC可以实现什么功能组合渲染可使用任何其他组件和原组件进行组合渲染，达到样式、布局复用等效果。 通过属性代理实现 12345678910function stylHOC(WrappedComponent) &#123; return class extends Component &#123; render() &#123; return (&lt;div&gt; &lt;div className=\"title\"&gt;&#123;this.props.title&#125;&lt;/div&gt; &lt;WrappedComponent &#123;...this.props&#125; /&gt; &lt;/div&gt;); &#125; &#125;&#125; 通过反向继承实现 12345678910function styleHOC(WrappedComponent) &#123; return class extends WrappedComponent &#123; render() &#123; return &lt;div&gt; &lt;div className=\"title\"&gt;&#123;this.props.title&#125;&lt;/div&gt; &#123;super.render()&#125; &lt;/div&gt; &#125; &#125;&#125; 条件渲染根据特定的属性决定原组件是否渲染 通过属性代理实现 12345678function visibleHOC(WrappedComponent) &#123; return class extends Component &#123; render() &#123; if (this.props.visible === false) return null; return &lt;WrappedComponent &#123;...props&#125; /&gt;; &#125; &#125;&#125; 通过反向继承实现 1234567891011function visibleHOC(WrappedComponent) &#123; return class extends WrappedComponent &#123; render() &#123; if (this.props.visible === false) &#123; return null &#125; else &#123; return super.render() &#125; &#125; &#125;&#125; 操作props可以对传入组件的props进行增加、修改、删除或者根据特定的props进行特殊的操作。 通过属性代理实现 1234567891011function proxyHOC(WrappedComponent) &#123; return class extends Component &#123; render() &#123; const newProps = &#123; ...this.props, user: 'ConardLi' &#125; return &lt;WrappedComponent &#123;...newProps&#125; /&gt;; &#125; &#125;&#125; 获取refs高阶组件中可获取原组件的ref，通过ref获取组件实力，如下面的代码，当程序初始化完成后调用原组件的log方法。(不知道refs怎么用，请👇Refs &amp; DOM) 通过属性代理实现 12345678910function refHOC(WrappedComponent) &#123; return class extends Component &#123; componentDidMount() &#123; this.wapperRef.log() &#125; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; ref=&#123;ref =&gt; &#123; this.wapperRef = ref &#125;&#125; /&gt;; &#125; &#125;&#125; 这里注意：调用高阶组件的时候并不能获取到原组件的真实ref，需要手动进行传递，具体请看传递refs 状态管理将原组件的状态提取到HOC中进行管理，如下面的代码，我们将Input的value提取到HOC中进行管理，使它变成受控组件，同时不影响它使用onChange方法进行一些其他操作。基于这种方式，我们可以实现一个简单的双向绑定，具体请看双向绑定。 通过属性代理实现 1234567891011121314151617181920212223242526272829303132333435function proxyHoc(WrappedComponent) &#123; return class extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: '' &#125;; &#125; onChange = (event) =&gt; &#123; const &#123; onChange &#125; = this.props; this.setState(&#123; value: event.target.value, &#125;, () =&gt; &#123; if(typeof onChange ==='function')&#123; onChange(event); &#125; &#125;) &#125; render() &#123; const newProps = &#123; value: this.state.value, onChange: this.onChange, &#125; return &lt;WrappedComponent &#123;...this.props&#125; &#123;...newProps&#125; /&gt;; &#125; &#125;&#125;class HOC extends Component &#123; render() &#123; return &lt;input &#123;...this.props&#125;&gt;&lt;/input&gt; &#125;&#125;export default proxyHoc(HOC); 操作state上面的例子通过属性代理利用HOC的state对原组件进行了一定的增强，但并不能直接控制原组件的state，而通过反向继承，我们可以直接操作原组件的state。但是并不推荐直接修改或添加原组件的state，因为这样有可能和组件内部的操作构成冲突。 通过反向继承实现 12345678910111213function debugHOC(WrappedComponent) &#123; return class extends WrappedComponent &#123; render() &#123; console.log('props', this.props); console.log('state', this.state); return ( &lt;div className=\"debuging\"&gt; &#123;super.render()&#125; &lt;/div&gt; ) &#125; &#125;&#125; 上面的HOC在render中将props和state打印出来，可以用作调试阶段，当然你可以在里面写更多的调试代码。想象一下，只需要在我们想要调试的组件上加上@debug就可以对该组件进行调试，而不需要在每次调试的时候写很多冗余代码。(如果你还不知道怎么使用HOC，请👇如何使用HOC) 渲染劫持高阶组件可以在render函数中做非常多的操作，从而控制原组件的渲染输出。只要改变了原组件的渲染，我们都将它称之为一种渲染劫持。 实际上，上面的组合渲染和条件渲染都是渲染劫持的一种，通过反向继承，不仅可以实现以上两点，还可直接增强由原组件render函数产生的React元素。 通过反向继承实现 1234567891011121314function hijackHOC(WrappedComponent) &#123; return class extends WrappedComponent &#123; render() &#123; const tree = super.render(); let newProps = &#123;&#125;; if (tree &amp;&amp; tree.type === 'input') &#123; newProps = &#123; value: '渲染被劫持了' &#125;; &#125; const props = Object.assign(&#123;&#125;, tree.props, newProps); const newTree = React.cloneElement(tree, props, tree.props.children); return newTree; &#125; &#125;&#125; 注意上面的说明我用的是增强而不是更改。render函数内实际上是调用React.creatElement产生的React元素： 虽然我们能拿到它，但是我们不能直接修改它里面的属性，我们通过getOwnPropertyDescriptors函数来打印下它的配置项： 可以发现，所有的writable属性均被配置为了false，即所有属性是不可变的。（对这些配置项有疑问，请👇defineProperty） 不能直接修改，我们可以借助cloneElement方法来在原组件的基础上增强一个新组件： React.cloneElement()克隆并返回一个新的React元素，使用element作为起点。生成的元素将会拥有原始元素props与新props的浅合并。新的子级会替换现有的子级。来自原始元素的 key 和 ref 将会保留。 React.cloneElement()几乎相当于： 1&lt;element.type &#123;...element.props&#125; &#123;...props&#125;&gt;&#123;children&#125;&lt;/element.type&gt; 如何使用HOC上面的示例代码都写的是如何声明一个HOC，HOC实际上是一个函数，所以我们将要增强的组件作为参数调用HOC函数，得到增强后的组件。 123456class myComponent extends Component &#123; render() &#123; return (&lt;span&gt;原组件&lt;/span&gt;) &#125;&#125;export default inheritHOC(myComponent); compose在实际应用中，一个组件可能被多个HOC增强，我们使用的是被所有的HOC增强后的组件，借用一张装饰模式的图来说明，可能更容易理解： 假设现在我们有logger，visible，style等多个HOC，现在要同时增强一个Input组件： 1logger(visible(style(Input))) 这种代码非常的难以阅读，我们可以手动封装一个简单的函数组合工具，将写法改写如下： 12const compose = (...fns) =&gt; fns.reduce((f, g) =&gt; (...args) =&gt; g(f(...args)));compose(logger,visible,style)(Input); compose函数返回一个所有函数组合后的函数，compose(f, g, h) 和 (...args) =&gt; f(g(h(...args)))是一样的。 很多第三方库都提供了类似compose的函数，例如lodash.flowRight，Redux提供的combineReducers函数等。 Decorators我们还可以借助ES7为我们提供的Decorators来让我们的写法变的更加优雅： 123456@logger@visible@styleclass Input extends Component &#123; // ...&#125; Decorators是ES7的一个提案，还没有被标准化，但目前Babel转码器已经支持，我们需要提前配置babel-plugin-transform-decorators-legacy： 1\"plugins\": [\"transform-decorators-legacy\"] 还可以结合上面的compose函数使用： 12345const hoc = compose(logger, visible, style);@hocclass Input extends Component &#123; // ...&#125; HOC的实际应用下面是一些我在公司项目中实际对HOC的实际应用场景，由于文章篇幅原因，代码经过很多简化，如有问题欢迎在评论区指出： 日志打点实际上这属于一类最常见的应用，多个组件拥有类似的逻辑，我们要对重复的逻辑进行复用，官方文档中CommentList的示例也是解决了代码复用问题，写的很详细，有兴趣可以👇使用高阶组件（HOC）解决横切关注点。 某些页面需要记录用户行为，性能指标等等，通过高阶组件做这些事情可以省去很多重复代码。 123456789101112131415161718function logHoc(WrappedComponent) &#123; return class extends Component &#123; componentWillMount() &#123; this.start = Date.now(); &#125; componentDidMount() &#123; this.end = Date.now(); console.log(`$&#123;WrappedComponent.dispalyName&#125; 渲染时间：$&#123;this.end - this.start&#125; ms`); console.log(`$&#123;user&#125;进入$&#123;WrappedComponent.dispalyName&#125;`); &#125; componentWillUnmount() &#123; console.log(`$&#123;user&#125;退出$&#123;WrappedComponent.dispalyName&#125;`); &#125; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; /&gt; &#125; &#125;&#125; 可用、权限控制1234567891011function auth(WrappedComponent) &#123; return class extends Component &#123; render() &#123; const &#123; visible, auth, display = null, ...props &#125; = this.props; if (visible === false || (auth &amp;&amp; authList.indexOf(auth) === -1)) &#123; return display &#125; return &lt;WrappedComponent &#123;...props&#125; /&gt;; &#125; &#125;&#125; authList是我们在进入程序时向后端请求的所有权限列表，当组件所需要的权限不列表中，或者设置的visible是false，我们将其显示为传入的组件样式，或者null。我们可以将任何需要进行权限校验的组件应用HOC： 1234567@authclass Input extends Component &#123; ... &#125;@authclass Button extends Component &#123; ... &#125;&lt;Button auth=\"user/addUser\"&gt;添加用户&lt;/Button&gt;&lt;Input auth=\"user/search\" visible=&#123;false&#125; &gt;添加用户&lt;/Input&gt; 双向绑定在vue中，绑定一个变量后可实现双向数据绑定，即表单中的值改变后绑定的变量也会自动改变。而React中没有做这样的处理，在默认情况下，表单元素都是非受控组件。给表单元素绑定一个状态后，往往需要手动书写onChange方法来将其改写为受控组件，在表单元素非常多的情况下这些重复操作是非常痛苦的。 我们可以借助高阶组件来实现一个简单的双向绑定，代码略长，可以结合下面的思维导图进行理解。 首先我们自定义一个Form组件，该组件用于包裹所有需要包裹的表单组件，通过contex向子组件暴露两个属性： model：当前Form管控的所有数据，由表单name和value组成，如{name:&#39;ConardLi&#39;,pwd:&#39;123&#39;}。model可由外部传入，也可自行管控。 changeModel：改变model中某个name的值。 12345678910111213141516171819202122232425262728293031323334353637383940class Form extends Component &#123; static childContextTypes = &#123; model: PropTypes.object, changeModel: PropTypes.func &#125; constructor(props, context) &#123; super(props, context); this.state = &#123; model: props.model || &#123;&#125; &#125;; &#125; componentWillReceiveProps(nextProps) &#123; if (nextProps.model) &#123; this.setState(&#123; model: nextProps.model &#125;) &#125; &#125; changeModel = (name, value) =&gt; &#123; this.setState(&#123; model: &#123; ...this.state.model, [name]: value &#125; &#125;) &#125; getChildContext() &#123; return &#123; changeModel: this.changeModel, model: this.props.model || this.state.model &#125;; &#125; onSubmit = () =&gt; &#123; console.log(this.state.model); &#125; render() &#123; return &lt;div&gt; &#123;this.props.children&#125; &lt;button onClick=&#123;this.onSubmit&#125;&gt;提交&lt;/button&gt; &lt;/div&gt; &#125;&#125; 下面定义用于双向绑定的HOC，其代理了表单的onChange属性和value属性： 发生onChange事件时调用上层Form的changeModel方法来改变context中的model。 在渲染时将value改为从context中取出的值。 1234567891011121314151617181920212223242526272829303132function proxyHoc(WrappedComponent) &#123; return class extends Component &#123; static contextTypes = &#123; model: PropTypes.object, changeModel: PropTypes.func &#125; onChange = (event) =&gt; &#123; const &#123; changeModel &#125; = this.context; const &#123; onChange &#125; = this.props; const &#123; v_model &#125; = this.props; changeModel(v_model, event.target.value); if(typeof onChange === 'function')&#123;onChange(event);&#125; &#125; render() &#123; const &#123; model &#125; = this.context; const &#123; v_model &#125; = this.props; return &lt;WrappedComponent &#123;...this.props&#125; value=&#123;model[v_model]&#125; onChange=&#123;this.onChange&#125; /&gt;; &#125; &#125;&#125;@proxyHocclass Input extends Component &#123; render() &#123; return &lt;input &#123;...this.props&#125;&gt;&lt;/input&gt; &#125;&#125; 上面的代码只是简略的一部分，除了input，我们还可以将HOC应用在select等其他表单组件，甚至还可以将上面的HOC兼容到span、table等展示组件，这样做可以大大简化代码，让我们省去了很多状态管理的工作，使用如下： 12345678910export default class extends Component &#123; render() &#123; return ( &lt;Form &gt; &lt;Input v_model=\"name\"&gt;&lt;/Input&gt; &lt;Input v_model=\"pwd\"&gt;&lt;/Input&gt; &lt;/Form&gt; ) &#125;&#125; 表单校验基于上面的双向绑定的例子，我们再来一个表单验证器，表单验证器可以包含验证函数以及提示信息，当验证不通过时，展示错误信息： 123456789101112131415161718192021222324function validateHoc(WrappedComponent) &#123; return class extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; error: '' &#125; &#125; onChange = (event) =&gt; &#123; const &#123; validator &#125; = this.props; if (validator &amp;&amp; typeof validator.func === 'function') &#123; if (!validator.func(event.target.value)) &#123; this.setState(&#123; error: validator.msg &#125;) &#125; else &#123; this.setState(&#123; error: '' &#125;) &#125; &#125; &#125; render() &#123; return &lt;div&gt; &lt;WrappedComponent onChange=&#123;this.onChange&#125; &#123;...this.props&#125; /&gt; &lt;div&gt;&#123;this.state.error || ''&#125;&lt;/div&gt; &lt;/div&gt; &#125; &#125;&#125; 12345678910const validatorName = &#123; func: (val) =&gt; val &amp;&amp; !isNaN(val), msg: '请输入数字'&#125;const validatorPwd = &#123; func: (val) =&gt; val &amp;&amp; val.length &gt; 6, msg: '密码必须大于6位'&#125;&lt;HOCInput validator=&#123;validatorName&#125; v_model=\"name\"&gt;&lt;/HOCInput&gt;&lt;HOCInput validator=&#123;validatorPwd&#125; v_model=\"pwd\"&gt;&lt;/HOCInput&gt; 当然，还可以在Form提交的时候判断所有验证器是否通过，验证器也可以设置为数组等等，由于文章篇幅原因，代码被简化了很多，有兴趣的同学可以自己实现。 Redux的connect redux中的connect，其实就是一个HOC，下面就是一个简化版的connect实现： 1234567891011121314151617181920212223242526272829303132333435363738export const connect = (mapStateToProps, mapDispatchToProps) =&gt; (WrappedComponent) =&gt; &#123; class Connect extends Component &#123; static contextTypes = &#123; store: PropTypes.object &#125; constructor () &#123; super() this.state = &#123; allProps: &#123;&#125; &#125; &#125; componentWillMount () &#123; const &#123; store &#125; = this.context this._updateProps() store.subscribe(() =&gt; this._updateProps()) &#125; _updateProps () &#123; const &#123; store &#125; = this.context let stateProps = mapStateToProps ? mapStateToProps(store.getState(), this.props): &#123;&#125; let dispatchProps = mapDispatchToProps? mapDispatchToProps(store.dispatch, this.props) : &#123;&#125; this.setState(&#123; allProps: &#123; ...stateProps, ...dispatchProps, ...this.props &#125; &#125;) &#125; render () &#123; return &lt;WrappedComponent &#123;...this.state.allProps&#125; /&gt; &#125; &#125; return Connect&#125; 代码非常清晰，connect函数其实就做了一件事，将mapStateToProps和mapDispatchToProps分别解构后传给原组件，这样我们在原组件内就可以直接用props获取state以及dispatch函数了。 使用HOC的注意事项告诫—静态属性拷贝当我们应用HOC去增强另一个组件时，我们实际使用的组件已经不是原组件了，所以我们拿不到原组件的任何静态属性，我们可以在HOC的结尾手动拷贝他们： 12345678910function proxyHOC(WrappedComponent) &#123; class HOCComponent extends Component &#123; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; /&gt;; &#125; &#125; HOCComponent.staticMethod = WrappedComponent.staticMethod; // ... return HOCComponent;&#125; 如果原组件有非常多的静态属性，这个过程是非常痛苦的，而且你需要去了解需要增强的所有组件的静态属性是什么，我们可以使用hoist-non-react-statics来帮助我们解决这个问题，它可以自动帮我们拷贝所有非React的静态方法，使用方式如下： 12345678910import hoistNonReactStatic from 'hoist-non-react-statics';function proxyHOC(WrappedComponent) &#123; class HOCComponent extends Component &#123; render() &#123; return &lt;WrappedComponent &#123;...this.props&#125; /&gt;; &#125; &#125; hoistNonReactStatic(HOCComponent,WrappedComponent); return HOCComponent;&#125; 告诫—传递refs使用高阶组件后，获取到的ref实际上是最外层的容器组件，而非原组件，但是很多情况下我们需要用到原组件的ref。 高阶组件并不能像透传props那样将refs透传，我们可以用一个回调函数来完成ref的传递：12345678910111213141516171819function hoc(WrappedComponent) &#123; return class extends Component &#123; getWrappedRef = () =&gt; this.wrappedRef; render() &#123; return &lt;WrappedComponent ref=&#123;ref =&gt; &#123; this.wrappedRef = ref &#125;&#125; &#123;...this.props&#125; /&gt;; &#125; &#125;&#125;@hocclass Input extends Component &#123; render() &#123; return &lt;input&gt;&lt;/input&gt; &#125;&#125;class App extends Component &#123; render() &#123; return ( &lt;Input ref=&#123;ref =&gt; &#123; this.inpitRef = ref.getWrappedRef() &#125;&#125; &gt;&lt;/Input&gt; ); &#125;&#125; React 16.3版本提供了一个forwardRef API来帮助我们进行refs传递，这样我们在高阶组件上获取的ref就是原组件的ref了，而不需要再手动传递，如果你的React版本大于16.3，可以使用下面的方式: 1234567891011function hoc(WrappedComponent) &#123; class HOC extends Component &#123; render() &#123; const &#123; forwardedRef, ...props &#125; = this.props; return &lt;WrappedComponent ref=&#123;forwardedRef&#125; &#123;...props&#125; /&gt;; &#125; &#125; return React.forwardRef((props, ref) =&gt; &#123; return &lt;HOC forwardedRef=&#123;ref&#125; &#123;...props&#125; /&gt;; &#125;);&#125; 告诫—不要在render方法内使用高阶组件React Diff算法的原则是： 使用组件标识确定是卸载还是更新组件 如果组件的和前一次渲染时标识是相同的，递归更新子组件 如果标识不同卸载组件重新挂载新组件 每次调用高阶组件生成的都是是一个全新的组件，组件的唯一标识响应的也会改变，如果在render方法调用了高阶组件，这会导致组件每次都会被卸载后重新挂载。 约定-不要改变原始组件官方文档对高阶组件的说明： 高阶组件就是一个没有副作用的纯函数。 我们再来看看纯函数的定义： 如果函数的调用参数相同，则永远返回相同的结果。它不依赖于程序执行期间函数外部任何状态或数据的变化，必须只依赖于其输入参数。该函数不会产生任何可观察的副作用，例如网络请求，输入和输出设备或数据突变。 如果我们在高阶组件对原组件进行了修改，例如下面的代码： 1InputComponent.prototype.componentWillReceiveProps = function(nextProps) &#123; ... &#125; 这样就破坏了我们对高阶组件的约定，同时也改变了使用高阶组件的初衷：我们使用高阶组件是为了增强而非改变原组件。 约定-透传不相关的props使用高阶组件，我们可以代理所有的props，但往往特定的HOC只会用到其中的一个或几个props。我们需要把其他不相关的props透传给原组件，如下面的代码： 123456789function visible(WrappedComponent) &#123; return class extends Component &#123; render() &#123; const &#123; visible, ...props &#125; = this.props; if (visible === false) return null; return &lt;WrappedComponent &#123;...props&#125; /&gt;; &#125; &#125;&#125; 我们只使用visible属性来控制组件的显示可隐藏，把其他props透传下去。 约定-displayName在使用React Developer Tools进行调试时，如果我们使用了HOC，调试界面可能变得非常难以阅读，如下面的代码： 123456789101112@visibleclass Show extends Component &#123; render() &#123; return &lt;h1&gt;我是一个标签&lt;/h1&gt; &#125;&#125;@visibleclass Title extends Component &#123; render() &#123; return &lt;h1&gt;我是一个标题&lt;/h1&gt; &#125;&#125; 为了方便调试，我们可以手动为HOC指定一个displayName，官方推荐使用HOCName(WrappedComponentName)： 1static displayName = `Visible($&#123;WrappedComponent.displayName&#125;)` 这个约定帮助确保高阶组件最大程度的灵活性和可重用性。 使用HOC的动机回顾下上文提到的 Mixin 带来的风险： Mixin 可能会相互依赖，相互耦合，不利于代码维护 不同的Mixin中的方法可能会相互冲突 Mixin非常多时，组件是可以感知到的，甚至还要为其做相关处理，这样会给代码造成滚雪球式的复杂性 而HOC的出现可以解决这些问题： 高阶组件就是一个没有副作用的纯函数，各个高阶组件不会互相依赖耦合 高阶组件也有可能造成冲突，但我们可以在遵守约定的情况下避免这些行为 高阶组件并不关心数据使用的方式和原因，而被包裹的组件也不关心数据来自何处。高阶组件的增加不会为原组件增加负担 HOC的缺陷 HOC需要在原组件上进行包裹或者嵌套，如果大量使用HOC，将会产生非常多的嵌套，这让调试变得非常困难。 HOC可以劫持props，在不遵守约定的情况下也可能造成冲突。 Hooks Hooks是React v16.7.0-alpha中加入的新特性。它可以让你在class以外使用state和其他React特性。 使用Hooks，你可以在将含有state的逻辑从组件中抽象出来，这将可以让这些逻辑容易被测试。同时，Hooks可以帮助你在不重写组件结构的情况下复用这些逻辑。所以，它也可以作为一种实现状态逻辑复用的方案。 阅读下面的章节使用Hook的动机你可以发现，它可以同时解决Mixin和HOC带来的问题。 官方提供的HooksState Hook我们要使用class组件实现一个计数器功能，我们可能会这样写： 12345678910111213141516export default class Count extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 0 &#125; &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; &#123; this.setState(&#123; count: this.state.count + 1 &#125;) &#125;&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 通过useState，我们使用函数式组件也能实现这样的功能： 1234567891011export default function HookTest() &#123; const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1); setNumber(number + 1); &#125;&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; useState是一个钩子，他可以为函数式组件增加一些状态，并且提供改变这些状态的函数，同时它接收一个参数，这个参数作为状态的默认值。 Effect Hook Effect Hook 可以让你在函数组件中执行一些具有 side effect（副作用）的操作 参数 useEffect方法接收传入两个参数： 1.回调函数：在第组件一次render和之后的每次update后运行，React保证在DOM已经更新完成之后才会运行回调。 2.状态依赖(数组)：当配置了状态依赖项后，只有检测到配置的状态变化时，才会调用回调函数。 123456useEffect(() =&gt; &#123; // 只要组件render后就会执行&#125;);useEffect(() =&gt; &#123; // 只有count改变时才会执行&#125;,[count]); 回调返回值 useEffect的第一个参数可以返回一个函数，当页面渲染了下一次更新的结果后，执行下一次useEffect之前，会调用这个函数。这个函数常常用来对上一次调用useEffect进行清理。 1234567891011121314151617export default function HookTest() &#123; const [count, setCount] = useState(0); useEffect(() =&gt; &#123; console.log('执行...', count); return () =&gt; &#123; console.log('清理...', count); &#125; &#125;, [count]); return ( &lt;div&gt; &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt; &lt;button onClick=&#123;() =&gt; &#123; setCount(count + 1); setNumber(number + 1); &#125;&#125;&gt; Click me &lt;/button&gt; &lt;/div&gt; );&#125; 执行上面的代码，并点击几次按钮，会得到下面的结果： 注意，如果加上浏览器渲染的情况，结果应该是这样的： 1234567891011页面渲染...1执行... 1页面渲染...2清理... 1执行... 2页面渲染...3清理... 2执行... 3页面渲染...4清理... 3执行... 4 那么为什么在浏览器渲染完后，再执行清理的方法还能找到上次的state呢？原因很简单，我们在useEffect中返回的是一个函数，这形成了一个闭包，这能保证我们上一次执行函数存储的变量不被销毁和污染。 你可以尝试下面的代码可能更好理解 12345678910111213141516171819202122var flag = 1;var clean;function effect(flag) &#123; return function () &#123; console.log(flag); &#125;&#125;clean = effect(flag);flag = 2;clean();clean = effect(flag);flag = 3;clean();clean = effect(flag);// 执行结果effect... 1clean... 1effect... 2clean... 2effect... 3 模拟componentDidMount componentDidMount等价于useEffect的回调仅在页面初始化完成后执行一次，当useEffect的第二个参数传入一个空数组时可以实现这个效果。 123function useDidMount(callback) &#123; useEffect(callback, []);&#125; 官方不推荐上面这种写法，因为这有可能导致一些错误。 模拟componentWillUnmount 123function useUnMount(callback) &#123; useEffect(() =&gt; callback, []);&#125; 不像 componentDidMount 或者 componentDidUpdate，useEffect 中使用的 effect 并不会阻滞浏览器渲染页面。这让你的 app 看起来更加流畅。 ref Hook使用useRef Hook，你可以轻松的获取到dom的ref。 123456789101112export default function Input() &#123; const inputEl = useRef(null); const onButtonClick = () =&gt; &#123; inputEl.current.focus(); &#125;; return ( &lt;div&gt; &lt;input ref=&#123;inputEl&#125; type=\"text\" /&gt; &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;/button&gt; &lt;/div&gt; );&#125; 注意useRef()并不仅仅可以用来当作获取ref使用，使用useRef产生的ref的current属性是可变的，这意味着你可以用它来保存一个任意值。 模拟componentDidUpdate componentDidUpdate就相当于除去第一次调用的useEffect，我们可以借助useRef生成一个标识，来记录是否为第一次执行： 12345678910function useDidUpdate(callback, prop) &#123; const init = useRef(true); useEffect(() =&gt; &#123; if (init.current) &#123; init.current = false; &#125; else &#123; return callback(); &#125; &#125;, prop);&#125; 使用Hook的注意事项使用范围 只能在React函数式组件或自定义Hook中使用Hook。 Hook的提出主要就是为了解决class组件的一系列问题，所以我们能在class组件中使用它。 声明约束 不要在循环，条件或嵌套函数中调用Hook。 Hook通过数组实现的，每次useState 都会改变下标，React需要利用调用顺序来正确更新相应的状态，如果useState 被包裹循环或条件语句中，那每就可能会引起调用顺序的错乱，从而造成意想不到的错误。 我们可以安装一个eslint插件来帮助我们避免这些问题。12345678910111213// 安装npm install eslint-plugin-react-hooks --save-dev// 配置&#123; \"plugins\": [ // ... \"react-hooks\" ], \"rules\": &#123; // ... \"react-hooks/rules-of-hooks\": \"error\" &#125;&#125; 自定义Hook像上面介绍的HOC和mixin一样，我们同样可以通过自定义的Hook将组件中类似的状态逻辑抽取出来。 自定义Hook非常简单，我们只需要定义一个函数，并且把相应需要的状态和effect封装进去，同时，Hook之间也是可以相互引用的。使用use开头命名自定义Hook，这样可以方便eslint进行检查。 下面我们看几个具体的Hook封装： 日志打点我们可以使用上面封装的生命周期Hook。 12345678910111213141516const useLogger = (componentName, ...params) =&gt; &#123; useDidMount(() =&gt; &#123; console.log(`$&#123;componentName&#125;初始化`, ...params); &#125;); useUnMount(() =&gt; &#123; console.log(`$&#123;componentName&#125;卸载`, ...params); &#125;) useDidUpdate(() =&gt; &#123; console.log(`$&#123;componentName&#125;更新`, ...params); &#125;);&#125;;function Page1(props)&#123; useLogger('Page1',props); return (&lt;div&gt;...&lt;/div&gt;)&#125; 修改title根据不同的页面名称修改页面title: 12345678910111213function useTitle(title) &#123; useEffect( () =&gt; &#123; document.title = title; return () =&gt; (document.title = \"主页\"); &#125;, [title] );&#125;function Page1(props)&#123; useTitle('Page1'); return (&lt;div&gt;...&lt;/div&gt;)&#125; 双向绑定我们将表单onChange的逻辑抽取出来封装成一个Hook，这样所有需要进行双向绑定的表单组件都可以进行复用：1234567891011121314function useBind(init) &#123; let [value, setValue] = useState(init); let onChange = useCallback(function(event) &#123; setValue(event.currentTarget.value); &#125;, []); return &#123; value, onChange &#125;;&#125;function Page1(props)&#123; let value = useBind(''); return &lt;input &#123;...value&#125; /&gt;;&#125; 当然，你可以向上面的HOC那样，结合context和form来封装一个更通用的双向绑定，有兴趣可以手动实现一下。 使用Hook的动机减少状态逻辑复用的风险Hook和Mixin在用法上有一定的相似之处，但是Mixin引入的逻辑和状态是可以相互覆盖的，而多个Hook之间互不影响，这让我们不需要在把一部分精力放在防止避免逻辑复用的冲突上。 在不遵守约定的情况下使用HOC也有可能带来一定冲突，比如props覆盖等等，使用Hook则可以避免这些问题。 避免地狱式嵌套大量使用HOC的情况下让我们的代码变得嵌套层级非常深，使用HOC，我们可以实现扁平式的状态逻辑复用，而避免了大量的组件嵌套。 让组件更容易理解在使用class组件构建我们的程序时，他们各自拥有自己的状态，业务逻辑的复杂使这些组件变得越来越庞大，各个生命周期中会调用越来越多的逻辑，越来越难以维护。使用Hook，可以让你更大限度的将公用逻辑抽离，将一个组件分割成更小的函数，而不是强制基于生命周期方法进行分割。 使用函数代替class相比函数，编写一个class可能需要掌握更多的知识，需要注意的点也越多，比如this指向、绑定事件等等。另外，计算机理解一个class比理解一个函数更快。Hooks让你可以在classes之外使用更多React的新特性。 理性的选择实际上，Hook在react 16.8.0才正式发布Hook稳定版本，笔者也还未在生产环境下使用，目前笔者在生产环境下使用的最多的是HOC。 React官方完全没有把classes从React中移除的打算，class组件和Hook完全可以同时存在，官方也建议避免任何“大范围重构”，毕竟这是一个非常新的版本，如果你喜欢它，可以在新的非关键性的代码中使用Hook。 小结mixin已被抛弃，HOC正当壮年，Hook初露锋芒，前端圈就是这样，技术迭代速度非常之快，但我们在学习这些知识之时一定要明白为什么要学，学了有没有用，要不要用。不忘初心，方得始终。 文中如有错误，欢迎在评论区指正，谢谢阅读。","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://www.lisq.xyz/tags/React/"}]},{"title":"全面分析前端的网络请求方式","slug":"【浏览器和网络】全面分析前端的网络请求方式","date":"2019-03-28T12:38:59.000Z","updated":"2019-04-06T05:14:21.095Z","comments":true,"path":"2019/03/28/【浏览器和网络】全面分析前端的网络请求方式/","link":"","permalink":"https://www.lisq.xyz/2019/03/28/【浏览器和网络】全面分析前端的网络请求方式/","excerpt":"","text":"一、前端进行网络请求的关注点大多数情况下，在前端发起一个网络请求我们只需关注下面几点： 传入基本参数（url，请求方式） 请求参数、请求参数类型 设置请求头 获取响应的方式 获取响应头、响应状态、响应结果 异常处理 携带cookie设置 跨域请求 二、前端进行网络请求的方式 form表单、ifream、刷新页面 Ajax - 异步网络请求的开山鼻祖 jQuery - 一个时代 fetch - Ajax的替代者 axios、request等众多开源库 三、关于网络请求的疑问 Ajax的出现解决了什么问题 原生Ajax如何使用 jQuery的网络请求方式 fetch的用法以及坑点 如何正确的使用fetch 如何选择合适的跨域方式 带着以上这些问题、关注点我们对几种网络请求进行一次全面的分析。 四、Ajax的出现解决了什么问题在Ajax出现之前，web程序是这样工作的： 这种交互的的缺陷是显而易见的，任何和服务器的交互都需要刷新页面，用户体验非常差，Ajax的出现解决了这个问题。Ajax全称Asynchronous JavaScript + XML（异步JavaScript和XML） 使用Ajax，网页应用能够快速地将增量更新呈现在用户界面上，而不需要重载（刷新）整个页面。 Ajax本身不是一种新技术，而是用来描述一种使用现有技术集合实现的一个技术方案，浏览器的XMLHttpRequest是实现Ajax最重要的对象（IE6以下使用ActiveXObject）。 尽管X在Ajax中代表XML, 但由于JSON的许多优势，比如更加轻量以及作为Javascript的一部分，目前JSON的使用比XML更加普遍。 五、原生Ajax的用法这里主要分析XMLHttpRequest对象，下面是它的一段基础使用： 1234567891011121314151617181920212223242526272829var xhr = new XMLHttpRequest();xhr.open('post','www.xxx.com',true)// 接收返回值xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4 )&#123; if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123; console.log(xhr.responseText); &#125; &#125;&#125;// 处理请求参数postData = &#123;\"name1\":\"value1\",\"name2\":\"value2\"&#125;;postData = (function(value)&#123;var dataString = \"\";for(var key in value)&#123; dataString += key+\"=\"+value[key]+\"&amp;\";&#125;; return dataString;&#125;(postData));// 设置请求头xhr.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");// 异常处理xhr.onerror = function() &#123; console.log('Network request failed')&#125;// 跨域携带cookiexhr.withCredentials = true;// 发出请求xhr.send(postData); 下面分别对XMLHttpRequest对象常用的的函数、属性、事件进行分析。 函数open 用于初始化一个请求，用法： 1xhr.open(method, url, async); method：请求方式，如get、post url：请求的url async：是否为异步请求 send 用于发送HTTP请求，即调用该方法后HTTP请求才会被真正发出，用法： 1xhr.send(param) param：http请求的参数，可以为string、Blob等类型。 abort 用于终止一个ajax请求，调用此方法后readyState将被设置为0，用法： 1xhr.abort() setRequestHeader 用于设置HTTP请求头，此方法必须在open()方法和send()之间调用，用法： 1xhr.setRequestHeader(header, value); getResponseHeader 用于获取http返回头，如果在返回头中有多个一样的名称，那么返回的值就会是用逗号和空格将值分隔的字符串，用法： 1var header = xhr.getResponseHeader(name); 属性readyState 用来标识当前XMLHttpRequest对象所处的状态，XMLHttpRequest对象总是位于下列状态中的一个： 值 状态 描述 0 UNSENT 代理被创建，但尚未调用 open() 方法。 1 OPENED open() 方法已经被调用。 2 HEADERS_RECEIVED send()方法已经被调用，并且头部和状态已经可获得。 3 LOADING 下载中； responseText 属性已经包含部分数据。 4 DONE 下载操作已完成。 status 表示http请求的状态, 初始值为0。如果服务器没有显式地指定状态码, 那么status将被设置为默认值, 即200。 responseType 表示响应的数据类型，并允许我们手动设置，如果为空，默认为text类型，可以有下面的取值： 值 描述 &quot;&quot; 将 responseType设为空字符串与设置为&quot;text&quot;相同， 是默认类型 （实际上是 DOMString）。 &quot;arraybuffer&quot; response 是一个包含二进制数据的JavaScript ArrayBuffer 。 &quot;blob&quot; response是一个包含二进制数据的 Blob 对象 。 &quot;document&quot; response 是一个HTML Document或XML XMLDocument，这取决于接收到的数据的 MIME 类型。 &quot;json&quot; response 是一个 JavaScript 对象。这个对象是通过将接收到的数据类型视为JSON解析得到的。 &quot;text&quot; response是包含在DOMString对象中的文本。 response 返回响应的正文，返回的类型由上面的responseType决定。 withCredentials ajax请求默认会携带同源请求的cookie，而跨域请求则不会携带cookie，设置xhr的withCredentials的属性为true将允许携带跨域cookie。 事件回调onreadystatechange 1xhr.onreadystatechange = callback; 当readyState属性发生变化时，callback会被触发。 onloadstart 1xhr.onloadstart = callback; 在ajax请求发送之前（readyState==1后, readyState==2前），callback会被触发。 onprogress 123xhr.onprogress = function(event)&#123; console.log(event.loaded / event.total);&#125; 回调函数可以获取资源总大小total，已经加载的资源大小loaded，用这两个值可以计算加载进度。 onload 1xhr.onload = callback; 当一个资源及其依赖资源已完成加载时，将触发callback，通常我们会在onload事件中处理返回值。 异常处理onerror 1xhr.onerror = callback; 当ajax资源加载失败时会触发callback。 ontimeout 1xhr.ontimeout = callback; 当进度由于预定时间到期而终止时，会触发callback，超时时间可使用timeout属性进行设置。 六、jQuery对Ajax的封装在很长一段时间里，人们使用jQuery提供的ajax封装进行网络请求，包括$.ajax、$.get、$.post等，这几个方法放到现在，我依然觉得很实用。 12345678910111213$.ajax(&#123; dataType: 'json', // 设置返回值类型 contentType: 'application/json', // 设置参数类型 headers: &#123;'Content-Type','application/json'&#125;,// 设置请求头 xhrFields: &#123; withCredentials: true &#125;, // 跨域携带cookie data: JSON.stringify(&#123;a: [&#123;b:1, a:1&#125;]&#125;), // 传递参数 error:function(xhr,status)&#123; // 错误处理 console.log(xhr,status); &#125;, success: function (data,status) &#123; // 获取结果 console.log(data,status); &#125;&#125;) $.ajax只接收一个参数，这个参数接收一系列配置，其自己封装了一个jqXHR对象，有兴趣可以阅读一下jQuary-ajax 源码 常用配置： url 当前页地址。发送请求的地址。 type 类型：String 请求方式 (&quot;POST&quot; 或&quot;GET&quot;)， 默认为 &quot;GET&quot;。注意：其它HTTP请求方法，如PUT和 DELETE也可以使用，但仅部分浏览器支持。 timeout 类型：Number设置请求超时时间（毫秒）。此设置将覆盖全局设置。 success 类型：Function 请求成功后的回调函数。 jsonp 在一个jsonp请求中重写回调函数的名字。这个值用来替代在&quot;callback=?&quot;这种GET或POST请求中URL参数里的&quot;callback&quot;部分。 error 类型：Function 。请求失败时调用此函数。 注意：源码里对错误的判定： 1isSuccess = status &gt;= 200 &amp;&amp; status &lt; 300 || status === 304; 返回值除了这几个状态码都会进error回调。 dataType 123456\"xml\": 返回 XML 文档，可用 jQuery 处理。\"html\": 返回纯文本 HTML 信息；包含的 script 标签会在插入 dom 时执行。\"script\": 返回纯文本 JavaScript 代码。不会自动缓存结果。除非设置了 \"cache\" 参数。注意：在远程请求时(不在同一个域下)，所有 POST 请求都将转为 GET 请求。（因为将使用 DOM 的 script标签来加载）\"json\": 返回 JSON 数据 。\"jsonp\": JSONP 格式。使用 JSONP 形式调用函数时，如 \"myurl?callback=?\" jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。\"text\": 返回纯文本字符串 data 类型：String 使用JSON.stringify转码 complete 类型：Function请求完成后回调函数 (请求成功或失败之后均调用)。 async 类型：Boolean 默认值:true。默认设置下，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为 false。 contentType 类型：String默认值: &quot;application/x-www-form-urlencoded&quot;。发送信息至服务器时内容编码类型。 键值对这样组织在一般的情况下是没有什么问题的，这里说的一般是，不带嵌套类型JSON，也就是 简单的JSON，形如这样： 12345&#123; a: 1, b: 2, c: 3&#125; 但是在一些复杂的情况下就有问题了。 例如在 Ajax中你要传一个复杂的 json 对像，也就说是对象嵌数组，数组中包括对象，你这样传：application/x-www-form-urlencoded 这种形式是没有办法将复杂的JSON组织成键值对形式。 1234567&#123; data: &#123; a: [&#123; x: 2 &#125;] &#125;&#125; 可以用如下方式传递复杂的json对象 12345$.ajax(&#123; dataType: 'json', contentType: 'application/json', data: JSON.stringify(&#123;a: [&#123;b:1, a:1&#125;]&#125;)&#125;) 七、jQuery的替代者近年来前端MV*的发展壮大，人们越来越少的使用jQuery，我们不可能单独为了使用jQuery的Ajax api来单独引入他，无可避免的，我们需要寻找新的技术方案。 尤雨溪在他的文档中推荐大家用axios进行网络请求。axios基于Promise对原生的XHR进行了非常全面的封装，使用方式也非常的优雅。另外，axios同样提供了在node环境下的支持，可谓是网络请求的首选方案。 未来必定还会出现更优秀的封装，他们有非常周全的考虑以及详细的文档，这里我们不多做考究，我们把关注的重点放在更底层的APIfetch。 Fetch API是一个用用于访问和操纵HTTP管道的强大的原生 API。 这种功能以前是使用 XMLHttpRequest实现的。Fetch提供了一个更好的替代方法，可以很容易地被其他技术使用，例如 Service Workers。Fetch还提供了单个逻辑位置来定义其他HTTP相关概念，例如CORS和HTTP的扩展。 可见fetch是作为XMLHttpRequest的替代品出现的。 使用fetch，你不需要再额外加载一个外部资源。但它还没有被浏览器完全支持，所以你仍然需要一个polyfill。 八、fetch的使用一个基本的 fetch请求： 1234567891011121314151617const options = &#123; method: \"POST\", // 请求参数 headers: &#123; \"Content-Type\": \"application/json\"&#125;, // 设置请求头 body: JSON.stringify(&#123;name:'123'&#125;), // 请求参数 credentials: \"same-origin\", // cookie设置 mode: \"cors\", // 跨域&#125;fetch('http://www.xxx.com') .then(function(response) &#123; return response.json(); &#125;) .then(function(myJson) &#123; console.log(myJson); // 响应数据 &#125;) .catch(function(err)&#123; console.log(err); // 异常处理 &#125;) Fetch API提供了一个全局的fetch()方法，以及几个辅助对象来发起一个网络请求。 fetch() fetch()方法用于发起获取资源的请求。它返回一个promise，这个 promise 会在请求响应后被 resolve，并传回 Response 对象。 Headers 可以通过Headers()构造函数来创建一个你自己的headers对象，相当于 response/request 的头信息，可以使你查询到这些头信息，或者针对不同的结果做不同的操作。12var myHeaders = new Headers();myHeaders.append(\"Content-Type\", \"text/plain\"); Request 通过Request()构造函数可以创建一个Request对象，这个对象可以作为fetch函数的第二个参数。 Response 在fetch()处理完promises之后返回一个Response实例，也可以手动创建一个Response实例。 九、fetch polyfill源码分析由于fetch是一个非常底层的API，所以我们无法进一步的探究它的底层，但是我们可以借助它的polyfill探究它的基本原理，并找出其中的坑点。 代码结构 由代码可见，polyfill主要对Fetch API提供的四大对象进行了封装： fetch 封装 代码非常清晰： 构造一个Promise对象并返回 创建一个Request对象 创建一个XMLHttpRequest对象 取出Request对象中的请求url，请求方发，open一个xhr请求，并将Request对象中存储的headers取出赋给xhr xhr onload后取出response的status、headers、body封装Response对象，调用resolve。 异常处理 可以发现，调用reject有三种可能： 1.请求超时 2.请求失败 注意：当和服务器建立简介，并收到服务器的异常状态码如404、500等并不能触发onerror。当网络故障时或请求被阻止时，才会标记为 reject，如跨域、url不存在，网络异常等会触发onerror。 所以使用fetch当接收到异常状态码都是会进入then而不是catch。这些错误请求往往要手动处理。 3.手动终止 可以在request参数中传入signal对象，并对signal对象添加abort事件监听，当xhr.readyState变为4（响应内容解析完成）后将signal对象的abort事件监听移除掉。 这表示，在一个fetch请求结束之前可以调用signal.abort将其终止。在浏览器中可以使用AbortController()构造函数创建一个控制器，然后使用AbortController.signal属性 这是一个实验中的功能，此功能某些浏览器尚在开发中 Headers封装 在header对象中维护了一个map对象，构造函数中可以传入Header对象、数组、普通对象类型的header，并将所有的值维护到map中。 之前在fetch函数中看到调用了header的forEach方法，下面是它的实现： 可见header的遍历即其内部map的遍历。 另外Header还提供了append、delete、get、set等方法，都是对其内部的map对象进行操作。 Request对象 Request对象接收的两个参数即fetch函数接收的两个参数，第一个参数可以直接传递url，也可以传递一个构造好的request对象。第二个参数即控制不同配置的option对象。 可以传入credentials、headers、method、mode、signal、referrer等属性。 这里注意： 传入的headers被当作Headers构造函数的参数来构造header对象。 cookie处理fetch函数中还有如下的代码： 12345if (request.credentials === 'include') &#123; xhr.withCredentials = true&#125; else if (request.credentials === 'omit') &#123; xhr.withCredentials = false&#125; 默认的credentials类型为same-origin,即可携带同源请求的coodkie。 然后我发现这里polyfill的实现和MDN-使用Fetch以及很多资料是不一致的： mdn: 默认情况下，fetch 不会从服务端发送或接收任何 cookies 于是我分别实验了下使用polyfill和使用原生fetch携带cookie的情况，发现在不设置credentials的情况下居然都是默认携带同源cookie的，这和文档的说明说不一致的，查阅了许多资料后都是说fetch默认不会携带cookie，下面是使用原生fetch在浏览器进行请求的情况： 然后我发现在MDN-Fetch-Request已经指出新版浏览器credentials默认值已更改为same-origin，旧版依然是omit。 确实MDN-使用Fetch这里的文档更新的有些不及时，误人子弟了… Response对象Response对象是fetch调用成功后的返回值： 回顾下fetch中对Response`的操作： 12345678910xhr.onload = function () &#123; var options = &#123; status: xhr.status, statusText: xhr.statusText, headers: parseHeaders(xhr.getAllResponseHeaders() || '') &#125; options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL') var body = 'response' in xhr ? xhr.response : xhr.responseText resolve(new Response(body, options))&#125; Response构造函数： 可见在构造函数中主要对options中的status、statusText、headers、url等分别做了处理并挂载到Response对象上。 构造函数里面并没有对responseText的明确处理，最后交给了_initBody函数处理，而Response并没有主动声明_initBody属性，代码最后使用Response调用了Body函数，实际上_initBody函数是通过Body函数挂载到Response身上的，先来看看_initBody函数： 可见，_initBody函数根据xhr.response的类型（Blob、FormData、String...），为不同的参数进行赋值，这些参数在Body方法中得到不同的应用，下面具体看看Body函数还做了哪些其他的操作： Body函数中还为Response对象挂载了四个函数，text、json、blob、formData，这些函数中的操作就是将_initBody中得到的不同类型的返回值返回。 这也说明了，在fetch执行完毕后，不能直接在response中获取到返回值而必须调用text()、json()等函数才能获取到返回值。 这里还有一点需要说明：几个函数中都有类似下面的逻辑： 1234var rejected = consumed(this)if (rejected) &#123; return rejected&#125; consumed函数：123456function consumed(body) &#123; if (body.bodyUsed) &#123; return Promise.reject(new TypeError('Already read')) &#125; body.bodyUsed = true&#125; 每次调用text()、json()等函数后会将bodyUsed变量变为true，用来标识返回值已经读取过了，下一次再读取直接抛出TypeError(&#39;Already read&#39;)。这也遵循了原生fetch的原则： 因为Responses对象被设置为了 stream 的方式，所以它们只能被读取一次 十、fetch的坑点VUE的文档中对fetch有下面的描述： 使用fetch还有很多别的注意事项，这也是为什么大家现阶段还是更喜欢axios 多一些。当然这个事情在未来可能会发生改变。 由于fetch是一个非常底层的API，它并没有被进行很多封装，还有许多问题需要处理： 不能直接传递JavaScript对象作为参数 需要自己判断返回值类型，并执行响应获取返回值的方法 获取返回值方法只能调用一次，不能多次调用 无法正常的捕获异常 老版浏览器不会默认携带cookie 不支持jsonp 十一、对fetch的封装请求参数处理支持传入不同的参数类型：12345678910111213141516171819function stringify(url, data) &#123; var dataString = url.indexOf('?') == -1 ? '?' : '&amp;'; for (var key in data) &#123; dataString += key + '=' + data[key] + '&amp;'; &#125;; return dataString;&#125;if (request.formData) &#123; request.body = request.data;&#125; else if (/^get$/i.test(request.method)) &#123; request.url = `$&#123;request.url&#125;$&#123;stringify(request.url, request.data)&#125;`;&#125; else if (request.form) &#123; request.headers.set('Content-Type', 'application/x-www-form-urlencoded;charset=UTF-8'); request.body = stringify(request.data);&#125; else &#123; request.headers.set('Content-Type', 'application/json;charset=UTF-8'); request.body = JSON.stringify(request.data);&#125; cookie携带fetch在新版浏览器已经开始默认携带同源cookie，但在老版浏览器中不会默认携带，我们需要对他进行统一设置： 12request.credentials = 'same-origin'; // 同源携带request.credentials = 'include'; // 可跨域携带 异常处理 当接收到一个代表错误的 HTTP 状态码时，从 fetch()返回的 Promise 不会被标记为 reject， 即使该 HTTP 响应的状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 ok 属性设置为 false ），仅当网络故障时或请求被阻止时，才会标记为 reject。 因此我们要对fetch的异常进行统一处理 123456789.then(response =&gt; &#123; if (response.ok) &#123; return Promise.resolve(response); &#125;else&#123; const error = new Error(`请求失败! 状态码: $&#123;response.status&#125;, 失败信息: $&#123;response.statusText&#125;`); error.response = response; return Promise.reject(error); &#125;&#125;); 返回值处理对不同的返回值类型调用不同的函数接收，这里必须提前判断好类型，不能多次调用获取返回值的方法： 12345678.then(response =&gt; &#123; let contentType = response.headers.get('content-type'); if (contentType.includes('application/json')) &#123; return response.json(); &#125; else &#123; return response.text(); &#125;&#125;); jsonpfetch本身没有提供对jsonp的支持，jsonp本身也不属于一种非常好的解决跨域的方式，推荐使用cors或者nginx解决跨域，具体请看下面的章节。 fetch封装好了，可以愉快的使用了。 嗯，axios真好用… 十二、跨域总结谈到网络请求，就不得不提跨域。 浏览器的同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。通常不允许不同源间的读操作。 跨域条件：协议，域名，端口，有一个不同就算跨域。 下面是解决跨域的几种方式： nginx使用nginx反向代理实现跨域，参考我这篇文章：前端开发者必备的nginx知识 corsCORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求。 服务端设置Access-Control-Allow-Origin就可以开启CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。 123456app.all('*', function (req, res, next) &#123; res.header(\"Access-Control-Allow-Origin\", \"*\"); res.header(\"Access-Control-Allow-Headers\", \"X-Requested-With\"); res.header(\"Access-Control-Allow-Methods\", \"PUT,POST,GET,DELETE,OPTIONS\"); next();&#125;); jsonpscript标签的src属性中的链接可以访问跨域的js脚本，利用这个特性，服务端不再返回JSON格式的数据，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。 jquery对jsonp的支持： 12345678910$.ajax(&#123; type : \"get\", url : \"http://xxxx\" dataType: \"jsonp\", jsonp:\"callback\", jsonpCallback: \"doo\", success : function(data) &#123; console.log(data); &#125;&#125;); fetch、axios等并没有直接提供对jsonp的支持，如果需要使用这种方式，我们可以尝试进行手动封装： 123456789101112131415161718192021222324252627282930313233(function (window,document) &#123; \"use strict\"; var jsonp = function (url,data,callback) &#123; // 1.将传入的data数据转化为url字符串形式 // &#123;id:1,name:'jack'&#125; =&gt; id=1&amp;name=jack var dataString = url.indexof('?') == -1? '?': '&amp;'; for(var key in data)&#123; dataString += key + '=' + data[key] + '&amp;'; &#125;; // 2 处理url中的回调函数 // cbFuncName回调函数的名字 ：my_json_cb_名字的前缀 + 随机数（把小数点去掉） var cbFuncName = 'my_json_cb_' + Math.random().toString().replace('.',''); dataString += 'callback=' + cbFuncName; // 3.创建一个script标签并插入到页面中 var scriptEle = document.createElement('script'); scriptEle.src = url + dataString; // 4.挂载回调函数 window[cbFuncName] = function (data) &#123; callback(data); // 处理完回调函数的数据之后，删除jsonp的script标签 document.body.removeChild(scriptEle); &#125; document.body.appendChild(scriptEle); &#125; window.$jsonp = jsonp;&#125;)(window,document) postMessage跨域postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。 1234567891011//捕获iframevar domain = 'http://scriptandstyle.com';var iframe = document.getElementById('myIFrame').contentWindow;//发送消息setInterval(function()&#123; var message = 'Hello! The time is: ' + (new Date().getTime()); console.log('blog.local: sending message: ' + message); //send the message and target URI iframe.postMessage(message,domain); &#125;,6000); 123456//响应事件window.addEventListener('message',function(event) &#123; if(event.origin !== 'http://davidwalsh.name') return; console.log('message received: ' + event.data,event); event.source.postMessage('holla back youngin!',event.origin);&#125;,false); postMessage跨域适用于以下场景：同浏览器多窗口间跨域通信、iframe间跨域通信。 WebSocketWebSocket 是一种双向通信协议，在建立连接之后，WebSocket的 server与 client都能主动向对方发送或接收数据而不受同源策略的限制。 1234567891011121314151617181920212223function WebSocketTest()&#123; if (\"WebSocket\" in window)&#123; alert(\"您的浏览器支持 WebSocket!\"); // 打开一个 web socket var ws = new WebSocket(\"ws://localhost:3000/abcd\"); ws.onopen = function()&#123; // Web Socket 已连接上，使用 send() 方法发送数据 ws.send(\"发送数据\"); alert(\"数据发送中...\"); &#125;; ws.onmessage = function (evt) &#123; var received_msg = evt.data; alert(\"数据已接收...\"); &#125;; ws.onclose = function()&#123; // 关闭 websocket alert(\"连接已关闭...\"); &#125;; &#125; else&#123; // 浏览器不支持 WebSocket alert(\"您的浏览器不支持 WebSocket!\"); &#125;&#125; 文中如有错误，欢迎在评论区指正，谢谢阅读。","categories":[],"tags":[{"name":"浏览器和网络","slug":"浏览器和网络","permalink":"https://www.lisq.xyz/tags/浏览器和网络/"}]},{"title":"前端开发者必备的nginx知识","slug":"【前端工程】前端开发者必备的nginx知识","date":"2019-03-12T06:50:35.000Z","updated":"2019-04-06T05:25:56.565Z","comments":true,"path":"2019/03/12/【前端工程】前端开发者必备的nginx知识/","link":"","permalink":"https://www.lisq.xyz/2019/03/12/【前端工程】前端开发者必备的nginx知识/","excerpt":"","text":"nginx在应用程序中的作用 解决跨域 请求过滤 配置gzip 负载均衡 静态资源服务器 nginx是一个高性能的HTTP和反向代理服务器，也是一个通用的TCP/UDP代理服务器，最初由俄罗斯人Igor Sysoev编写。 nginx现在几乎是众多大型网站的必用技术，大多数情况下，我们不需要亲自去配置它，但是了解它在应用程序中所担任的角色，以及如何解决这些问题是非常必要的。 下面我将从nginx在企业中的真实应用来解释nginx在应用程序中起到的作用。 为了便于理解，首先先来了解一下一些基础知识，nginx是一个高性能的反向代理服务器那么什么是反向代理呢？ 正向代理与反向代理代理是在服务器和客户端之间假设的一层服务器，代理将接收客户端的请求并将它转发给服务器，然后将服务端的响应转发给客户端。 不管是正向代理还是反向代理，实现的都是上面的功能。 正向代理 正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。 正向代理是为我们服务的，即为客户端服务的，客户端可以根据正向代理访问到它本身无法访问到的服务器资源。 正向代理对我们是透明的，对服务端是非透明的，即服务端并不知道自己收到的是来自代理的访问还是来自真实客户端的访问。 反向代理 反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。 反向代理是为服务端服务的，反向代理可以帮助服务器接收来自客户端的请求，帮助服务器做请求转发，负载均衡等。 反向代理对服务端是透明的，对我们是非透明的，即我们并不知道自己访问的是代理服务器，而服务器知道反向代理在为他服务。 基本配置配置结构下面是一个nginx配置文件的基本结构： 123456789101112131415161718192021222324events &#123; &#125;http &#123; server &#123; location path &#123; ... &#125; location path &#123; ... &#125; &#125; server &#123; ... &#125;&#125; main:nginx的全局配置，对全局生效。 events:配置影响nginx服务器或与用户的网络连接。 http：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。 server：配置虚拟主机的相关参数，一个http中可以有多个server。 location：配置请求的路由，以及各种页面的处理情况。 upstream：配置后端服务器具体地址，负载均衡配置不可或缺的部分。 内置变量下面是nginx一些配置中常用的内置全局变量，你可以在配置的任何位置使用它们。 变量名 功能 $host 请求信息中的Host，如果请求中没有Host行，则等于设置的服务器名 $request_method 客户端请求类型，如GET、POST $remote_addr 客户端的IP地址 $args 请求中的参数 $content_length 请求头中的Content-length字段 $http_user_agent 客户端agent信息 $http_cookie 客户端cookie信息 $remote_addr 客户端的IP地址 $remote_port 客户端的端口 $server_protocol 请求使用的协议，如HTTP/1.0、·HTTP/1.1` $server_addr 服务器地址 $server_name 服务器名称 $server_port 服务器的端口号 解决跨域先追本溯源以下，跨域究竟是怎么回事。 跨域的定义同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。通常不允许不同源间的读操作。 同源的定义如果两个页面的协议，端口（如果有指定）和域名都相同，则两个页面具有相同的源。 nginx解决跨域的原理例如： 前端server的域名为：fe.server.com 后端服务的域名为：dev.server.com 现在我在fe.server.com对dev.server.com发起请求一定会出现跨域。 现在我们只需要启动一个nginx服务器，将server_name设置为fe.server.com,然后设置相应的location以拦截前端需要跨域的请求，最后将请求代理回dev.server.com。如下面的配置： 1234567server &#123; listen 80; server_name fe.server.com; location / &#123; proxy_pass dev.server.com; &#125;&#125; 这样可以完美绕过浏览器的同源策略：fe.server.com访问nginx的fe.server.com属于同源访问，而nginx对服务端转发的请求不会触发浏览器的同源策略。 请求过滤 根据状态码过滤12345error_page 500 501 502 503 504 506 /50x.html; location = /50x.html &#123; #将跟路径改编为存放html的路径。 root /root/static/html; &#125; 根据URL名称过滤，精准匹配URL，不匹配的URL全部重定向到主页。 123location / &#123; rewrite ^.*$ /index.html redirect;&#125; 根据请求类型过滤。123if ( $request_method !~ ^(GET|POST|HEAD)$ ) &#123; return 403; &#125; 配置gzip GZIP是规定的三种标准HTTP压缩格式之一。目前绝大多数的网站都在使用GZIP传输 HTML、CSS、JavaScript 等资源文件。 对于文本文件，GZip 的效果非常明显，开启后传输所需流量大约会降至 1/4 ~ 1/3。 并不是每个浏览器都支持gzip的，如何知道客户端是否支持gzip呢，请求头中的Accept-Encoding来标识对压缩的支持。 启用gzip同时需要客户端和服务端的支持，如果客户端支持gzip的解析，那么只要服务端能够返回gzip的文件就可以启用gzip了,我们可以通过nginx的配置来让服务端支持gzip。下面的respone中content-encoding:gzip，指服务端开启了gzip的压缩方式。 12345gzip on;gzip_http_version 1.1; gzip_comp_level 5;gzip_min_length 1000;gzip_types text/csv text/xml text/css text/plain text/javascript application/javascript application/x-javascript application/json application/xml; gzip 开启或者关闭gzip模块 默认值为off 可配置为on / off gzip_http_version 启用 GZip 所需的HTTP 最低版本 默认值为HTTP/1.1 这里为什么默认版本不是1.0呢？ HTTP 运行在TCP 连接之上，自然也有着跟TCP 一样的三次握手、慢启动等特性。 启用持久连接情况下，服务器发出响应后让TCP连接继续打开着。同一对客户/服务器之间的后续请求和响应可以通过这个连接发送。 为了尽可能的提高 HTTP 性能，使用持久连接就显得尤为重要了。 HTTP/1.1默认支持TCP持久连接，HTTP/1.0 也可以通过显式指定 Connection: keep-alive 来启用持久连接。对于TCP持久连接上的HTTP 报文，客户端需要一种机制来准确判断结束位置，而在 HTTP/1.0中，这种机制只有Content-Length。而在HTTP/1.1中新增的 Transfer-Encoding: chunked 所对应的分块传输机制可以完美解决这类问题。 nginx同样有着配置chunked的属性chunked_transfer_encoding，这个属性是默认开启的。 Nginx在启用了GZip的情况下，不会等文件 GZip 完成再返回响应，而是边压缩边响应，这样可以显著提高 TTFB(Time To First Byte，首字节时间，WEB 性能优化重要指标)。这样唯一的问题是，Nginx 开始返回响应时，它无法知道将要传输的文件最终有多大，也就是无法给出Content-Length这个响应头部。 所以，在HTTP1.0中如果利用Nginx启用了GZip，是无法获得Content-Length的，这导致HTTP1.0中开启持久链接和使用GZip只能二选一，所以在这里gzip_http_version默认设置为1.1。 gzip_comp_level 压缩级别，级别越高压缩率越大，当然压缩时间也就越长（传输快但比较消耗cpu）。 默认值为 1 压缩级别取值为1-9 gzip_min_length 设置允许压缩的页面最小字节数，Content-Length小于该值的请求将不会被压缩 默认值:0 当设置的值较小时，压缩后的长度可能比原文件大，建议设置1000以上 gzip_types 要采用gzip压缩的文件类型(MIME类型) 默认值:text/html(默认不压缩js/css) 负载均衡什么是负载均衡 如上面的图，前面是众多的服务窗口，下面有很多用户需要服务，我们需要一个工具或策略来帮助我们将如此多的用户分配到每个窗口，来达到资源的充分利用以及更少的排队时间。 把前面的服务窗口想像成我们的后端服务器，而后面终端的人则是无数个客户端正在发起请求。负载均衡就是用来帮助我们将众多的客户端请求合理的分配到各个服务器，以达到服务端资源的充分利用和更少的请求时间。 nginx如何实现负载均衡Upstream指定后端服务器地址列表 12345upstream balanceServer &#123; server 10.1.22.33:12345; server 10.1.22.34:12345; server 10.1.22.35:12345;&#125; 在server中拦截响应请求，并将请求转发到Upstream中配置的服务器列表。 1234567server &#123; server_name fe.server.com; listen 80; location /api &#123; proxy_pass http://balanceServer; &#125;&#125; 上面的配置只是指定了nginx需要转发的服务端列表，并没有指定分配策略。 nginx实现负载均衡的策略 轮询策略 默认情况下采用的策略，将所有客户端请求轮询分配给服务端。这种策略是可以正常工作的，但是如果其中某一台服务器压力太大，出现延迟，会影响所有分配在这台服务器下的用户。 12345upstream balanceServer &#123; server 10.1.22.33:12345; server 10.1.22.34:12345; server 10.1.22.35:12345;&#125; 最小连接数策略 将请求优先分配给压力较小的服务器，它可以平衡每个队列的长度，并避免向压力大的服务器添加更多的请求。 123456upstream balanceServer &#123; least_conn; server 10.1.22.33:12345; server 10.1.22.34:12345; server 10.1.22.35:12345;&#125; 最快响应时间策略 依赖于NGINX Plus，优先分配给响应时间最短的服务器。 123456upstream balanceServer &#123; fair; server 10.1.22.33:12345; server 10.1.22.34:12345; server 10.1.22.35:12345;&#125; 客户端ip绑定 来自同一个ip的请求永远只分配一台服务器，有效解决了动态网页存在的session共享问题。123456upstream balanceServer &#123; ip_hash; server 10.1.22.33:12345; server 10.1.22.34:12345; server 10.1.22.35:12345;&#125; 静态资源服务器123456location ~* \\.(png|gif|jpg|jpeg)$ &#123; root /root/static/; autoindex on; access_log off; expires 10h;# 设置过期时间为10小时 &#125; 匹配以png|gif|jpg|jpeg为结尾的请求，并将请求转发到本地路径，root中指定的路径即nginx本地路径。同时也可以进行一些缓存的设置。 小结nginx的功能非常强大，还有很多需要探索，上面的一些配置都是公司配置的真实应用（精简过了），如果您有什么意见或者建议，欢迎在下方留言…","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://www.lisq.xyz/tags/nginx/"}]},{"title":"深入分析前端小数计算问题","slug":"【JavaScript】深入分析前端小数计算问题","date":"2019-03-06T08:22:51.000Z","updated":"2019-04-06T05:28:05.940Z","comments":true,"path":"2019/03/06/【JavaScript】深入分析前端小数计算问题/","link":"","permalink":"https://www.lisq.xyz/2019/03/06/【JavaScript】深入分析前端小数计算问题/","excerpt":"","text":"话不多说，先上代码12345678910111213141516171819202122232425262728function judgeFloat(n, m) &#123; const binaryN = n.toString(2); const binaryM = m.toString(2); console.log(`$&#123;n&#125;的二进制是 $&#123;binaryN&#125;`); console.log(`$&#123;m&#125;的二进制是 $&#123;binaryM&#125;`); const MN = m + n; const accuracyMN = (m * 100 + n * 100) / 100; const binaryMN = MN.toString(2); const accuracyBinaryMN = accuracyMN.toString(2); console.log(`$&#123;n&#125;+$&#123;m&#125;的二进制是$&#123;binaryMN&#125;`); console.log(`$&#123;accuracyMN&#125;的二进制是 $&#123;accuracyBinaryMN&#125;`); console.log(`$&#123;n&#125;+$&#123;m&#125;的二进制再转成十进制是$&#123;to10(binaryMN)&#125;`); console.log(`$&#123;accuracyMN&#125;的二进制是再转成十进制是$&#123;to10(accuracyBinaryMN)&#125;`); console.log(`$&#123;n&#125;+$&#123;m&#125;在js中计算是$&#123;(to10(binaryMN) === to10(accuracyBinaryMN)) ? '' : '不'&#125;准确的`);&#125;function to10(n) &#123; const pre = (n.split('.')[0] - 0).toString(2); const arr = n.split('.')[1].split(''); let i = 0; let result = 0; while (i &lt; arr.length) &#123; result += arr[i] * Math.pow(2, -(i + 1)); i++; &#125; return result;&#125;judgeFloat(0.1, 0.2);judgeFloat(0.6, 0.7); 由于JavaScript中没有将小数的二进制转换成十进制的方法，于是手动实现了一个。 先来一个简单的结论计算机中所有的数据都是以二进制存储的，所以在计算时计算机要把数据先转换成二进制进行计算，然后在把计算结果转换成十进制。 由上面的代码不难看出，在计算0.1+0.2时，二进制计算发生了精度丢失，导致再转换成十进制后和预计的结果不符。 其实有些标题党了，一个函数并不能让你深入理解，还得继续看下面… 对结果的分析—更多的问题0.1和0.2的二进制都是以1100无限循环的小数，下面逐个来看JS帮我们计算所得的结果： 0.1的二进制： 10.0001100110011001100110011001100110011001100110011001101 0.2的二进制：10.001100110011001100110011001100110011001100110011001101 理论上讲，由上面的结果相加应该：： 10.0100110011001100110011001100110011001100110011001100111 实际JS计算得到的0.1+0.2的二进制 10.0100110011001100110011001100110011001100110011001101 作为一个代码强迫症的我又产生的新的问题： Why js计算出的 0.1的二进制 是这么多位而不是更多位？？？ Why js计算的（0.1+0.2）的二进制和我们自己计算的（0.1+0.2）的二进制结果不一样呢？？？ Why 0.1的二进制 + 0.2的二进制 != 0.3的二进制？？？ js对二进制小数的存储方式小数的二进制大多数都是无限循环的，JavaScript是怎么来存储他们的呢？ 在ECMAScript®语言规范中可以看到，ECMAScript中的Number类型遵循IEEE 754标准。使用64位固定长度来表示。 事实上有很多语言的数字类型都遵循这个标准，例如JAVA,所以很多语言同样有着上面同样的问题。 所以下次遇到这种问题不要上来就喷JavaScript… 有兴趣可以看看下这个网站http://0.30000000000000004.com/，是的，你没看错，就是http://0.30000000000000004.com/！！！ IEEE 754IEEE754标准包含一组实数的二进制表示法。它有三部分组成： 符号位 指数位 尾数位 三种精度的浮点数各个部分位数如下： JavaScript使用的是64位双精度浮点数编码，所以它的符号位占1位，指数位占11位，尾数位占52位。 下面我们在理解下什么是符号位、指数位、尾数位，以0.1为例： 它的二进制为：0.0001100110011001100... 为了节省存储空间，在计算机中它是以科学计数法表示的，也就是 1.100110011001100... X 2-4 如果这里不好理解可以想一下十进制的数： 1100的科学计数法为11 X 102 所以： 符号位就是标识正负的，1表示负，0表示正； 指数位存储科学计数法的指数； 尾数位存储科学计数法后的有效数字； 所以我们通常看到的二进制，其实是计算机实际存储的尾数位。 js中的toString(2)由于尾数位只能存储52个数字，这就能解释toString(2)的执行结果了： 如果计算机没有存储空间的限制，那么0.1的二进制应该是：10.00011001100110011001100110011001100110011001100110011001... 科学计数法尾数位 11.1001100110011001100110011001100110011001100110011001... 但是由于限制，有效数字第53位及以后的数字是不能存储的，它遵循，如果是1就向前一位进1，如果是0就舍弃的原则。 0.1的二进制科学计数法第53位是1，所以就有了下面的结果： 10.0001100110011001100110011001100110011001100110011001101 0.2有着同样的问题，其实正是由于这样的存储，在这里有了精度丢失，导致了0.1+0.2!=0.3。 事实上有着同样精度问题的计算还有很多，我们无法把他们都记下来，所以当程序中有数字计算时，我们最好用工具库来帮助我们解决，下面是两个推荐使用的开源库： number-precision mathjs/ 下面我们再来看上面的其他两个问题。 Why JavaScript计算出的 0.1的二进制 是这么多位而不是更多位？？？上面的toString原理帮我们解答了这个问题，在有效数字第53位以后的数字将遵循1进0舍的原则，内存中只允许存储52位有效数字。 Why JavaScript计算的（0.1+0.2）的二进制和我们自己计算的（0.1+0.2）的二进制结果不一样呢？？？我们自己计算的0.1+0.2：： 10.0100110011001100110011001100110011001100110011001100111 实际上这个结果的有效数字已经超过了52位，我们要从末尾进行1进0舍得到下面的结果 10.0100110011001100110011001100110011001100110011001101 JavaScript能表示的最大数字由与IEEE 754双精度64位规范的限制： 指数位能表示的最大数字：1023(十进制) 尾数位能表达的最大数字即尾数位都位1的情况 所以JavaScript能表示的最大数字即位 1.111...X 21023 这个结果转换成十进制是1.7976931348623157e+308,这个结果即为Number.MAX_VALUE。 最大安全数字JavaScript中Number.MAX_SAFE_INTEGER表示最大安全数字,计算结果是9007199254740991，即在这个数范围内不会出现精度丢失（小数除外）,这个数实际上是1.111...X 252。 我们同样可以用一些开源库来处理大整数： node-bignum node-bigint 其实官方也考虑到了这个问题，bigInt类型在es10中被提出，现在Chrome中已经可以使用。 bigInt类型BigInt 是第七种原始类型。 BigInt 是一个任意精度的整数。这意味着变量现在可以计算9007199254740991即最大安全整数以上的数字。 1const b = 1n; // 追加 n 以创建 BigInt 在过去，不支持大于 9007199254740992 的整数值。如果超过，该值将锁定为MAX_SAFE_INTEGER + 1: 123456789101112const limit = Number.MAX_SAFE_INTEGER;⇨ 9007199254740991limit + 1;⇨ 9007199254740992limit + 2;⇨ 9007199254740992 &lt;--- MAX_SAFE_INTEGER + 1 exceededconst larger = 9007199254740991n;⇨ 9007199254740991nconst integer = BigInt(9007199254740991); // initialize with number⇨ 9007199254740991nconst same = BigInt(&quot;9007199254740991&quot;); // initialize with &quot;string&quot;⇨ 9007199254740991n typeof1234typeof 10;⇨ &apos;number&apos;typeof 10n;⇨ &apos;bigint&apos;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.lisq.xyz/tags/JavaScript/"}]},{"title":"【React深入】React事件机制","slug":"【React深入】React事件机制","date":"2019-03-06T08:19:35.000Z","updated":"2019-04-06T05:13:09.693Z","comments":true,"path":"2019/03/06/【React深入】React事件机制/","link":"","permalink":"https://www.lisq.xyz/2019/03/06/【React深入】React事件机制/","excerpt":"","text":"关于React事件的疑问 1.为什么要手动绑定this 2.React事件和原生事件有什么区别 3.React事件和原生事件的执行顺序，可以混用吗 4.React事件如何解决跨浏览器兼容 5.什么是合成事件 下面是我阅读过源码后，将所有的执行流程总结出来的流程图，不会贴代码，如果你想阅读代码看看具体是如何实现的，可以根据流程图去源码里寻找。 事件注册 组件装载 / 更新。 通过lastProps、nextProps判断是否新增、删除事件分别调用事件注册、卸载方法。 调用EventPluginHub的enqueuePutListener进行事件存储 获取document对象。 根据事件名称（如onClick、onCaptureClick）判断是进行冒泡还是捕获。 判断是否存在addEventListener方法，否则使用attachEvent（兼容IE）。 给document注册原生事件回调为dispatchEvent（统一的事件分发机制）。 事件存储 EventPluginHub负责管理React合成事件的callback，它将callback存储在listenerBank中，另外还存储了负责合成事件的Plugin。 EventPluginHub的putListener方法是向存储容器中增加一个listener。 获取绑定事件的元素的唯一标识key。 将callback根据事件类型，元素的唯一标识key存储在listenerBank中。 listenerBank的结构是：listenerBank[registrationName][key]。 例如： 12345678910&#123; onClick:&#123; nodeid1:()=&gt;&#123;...&#125; nodeid2:()=&gt;&#123;...&#125; &#125;, onChange:&#123; nodeid3:()=&gt;&#123;...&#125; nodeid4:()=&gt;&#123;...&#125; &#125;&#125; 事件触发 / 执行 这里的事件执行利用了React的批处理机制，在前一篇的【React深入】setState执行机制中已经分析过，这里不再多加分析。 触发document注册原生事件的回调dispatchEvent 获取到触发这个事件最深一级的元素 例如下面的代码：首先会获取到this.child 12345&lt;div onClick=&#123;this.parentClick&#125; ref=&#123;ref =&gt; this.parent = ref&#125;&gt; &lt;div onClick=&#123;this.childClick&#125; ref=&#123;ref =&gt; this.child = ref&#125;&gt; test &lt;/div&gt;&lt;/div&gt; 遍历这个元素的所有父元素，依次对每一级元素进行处理。 构造合成事件。 将每一级的合成事件存储在eventQueue事件队列中。 遍历eventQueue。 通过isPropagationStopped判断当前事件是否执行了阻止冒泡方法。 如果阻止了冒泡，停止遍历，否则通过executeDispatch执行合成事件。 释放处理完成的事件。 react在自己的合成事件中重写了stopPropagation方法，将isPropagationStopped设置为true，然后在遍历每一级事件的过程中根据此遍历判断是否继续执行。这就是react自己实现的冒泡机制。 合成事件 调用EventPluginHub的extractEvents方法。 循环所有类型的EventPlugin（用来处理不同事件的工具方法）。 在每个EventPlugin中根据不同的事件类型，返回不同的事件池。 在事件池中取出合成事件，如果事件池是空的，那么创建一个新的。 根据元素nodeid(唯一标识key)和事件类型从listenerBink中取出回调函数 返回带有合成事件参数的回调函数 总流程将上面的四个流程串联起来。 为什么要手动绑定this通过事件触发过程的分析，dispatchEvent调用了invokeGuardedCallback方法。 123456789function invokeGuardedCallback(name, func, a) &#123; try &#123; func(a); &#125; catch (x) &#123; if (caughtError === null) &#123; caughtError = x; &#125; &#125;&#125; 可见，回调函数是直接调用调用的，并没有指定调用的组件，所以不进行手动绑定的情况下直接获取到的this是undefined。 这里可以使用实验性的属性初始化语法 ，也就是直接在组件声明箭头函数。箭头函数不会创建自己的this，它只会从自己的作用域链的上一层继承this。因此这样我们在React事件中获取到的就是组件本身了。 和原生事件有什么区别 React 事件使用驼峰命名，而不是全部小写。 通过 JSX , 你传递一个函数作为事件处理程序，而不是一个字符串。 例如，HTML：123&lt;button onclick=&quot;activateLasers()&quot;&gt; Activate Lasers&lt;/button&gt; 在 React 中略有不同：123&lt;button onClick=&#123;activateLasers&#125;&gt; Activate Lasers&lt;/button&gt; 另一个区别是，在 React 中你不能通过返回false 来阻止默认行为。必须明确调用 preventDefault。 由上面执行机制我们可以得出：React自己实现了一套事件机制，自己模拟了事件冒泡和捕获的过程，采用了事件代理，批量更新等方法，并且抹平了各个浏览器的兼容性问题。 React事件和原生事件的执行顺序12345678910111213141516171819202122232425262728componentDidMount() &#123; this.parent.addEventListener(&apos;click&apos;, (e) =&gt; &#123; console.log(&apos;dom parent&apos;); &#125;) this.child.addEventListener(&apos;click&apos;, (e) =&gt; &#123; console.log(&apos;dom child&apos;); &#125;) document.addEventListener(&apos;click&apos;, (e) =&gt; &#123; console.log(&apos;document&apos;); &#125;)&#125;childClick = (e) =&gt; &#123; console.log(&apos;react child&apos;);&#125;parentClick = (e) =&gt; &#123; console.log(&apos;react parent&apos;);&#125;render() &#123; return ( &lt;div onClick=&#123;this.parentClick&#125; ref=&#123;ref =&gt; this.parent = ref&#125;&gt; &lt;div onClick=&#123;this.childClick&#125; ref=&#123;ref =&gt; this.child = ref&#125;&gt; test &lt;/div&gt; &lt;/div&gt;)&#125; 执行结果： 由上面的流程我们可以理解： react的所有事件都挂载在document中 当真实dom触发后冒泡到document后才会对react事件进行处理 所以原生的事件会先执行 然后执行react合成事件 最后执行真正在document上挂载的事件 react事件和原生事件可以混用吗？react事件和原生事件最好不要混用。 原生事件中如果执行了stopPropagation方法，则会导致其他react事件失效。因为所有元素的事件将无法冒泡到document上。 由上面的执行机制不难得出，所有的react事件都将无法被注册。 合成事件、浏览器兼容1234function handleClick(e) &#123; e.preventDefault(); console.log(&apos;The link was clicked.&apos;);&#125; 这里， e 是一个合成的事件。 React 根据 W3C 规范 定义了这个合成事件，所以你不需要担心跨浏览器的兼容性问题。 事件处理程序将传递 SyntheticEvent 的实例，这是一个跨浏览器原生事件包装器。 它具有与浏览器原生事件相同的接口，包括stopPropagation() 和 preventDefault() ，在所有浏览器中他们工作方式都相同。 每个SyntheticEvent对象都具有以下属性： 1234567891011121314boolean bubblesboolean cancelableDOMEventTarget currentTargetboolean defaultPreventednumber eventPhaseboolean isTrustedDOMEvent nativeEventvoid preventDefault()boolean isDefaultPrevented()void stopPropagation()boolean isPropagationStopped()DOMEventTarget targetnumber timeStampstring type React合成的SyntheticEvent采用了事件池，这样做可以大大节省内存，而不会频繁的创建和销毁事件对象。 另外，不管在什么浏览器环境下，浏览器会将该事件类型统一创建为合成事件，从而达到了浏览器兼容的目的。 推荐阅读【React深入】setState的执行机制","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://www.lisq.xyz/tags/React/"}]},{"title":"【React深入】setState的执行机制","slug":"【React深入】setState的执行机制","date":"2019-03-06T08:12:35.000Z","updated":"2019-04-06T05:27:16.846Z","comments":true,"path":"2019/03/06/【React深入】setState的执行机制/","link":"","permalink":"https://www.lisq.xyz/2019/03/06/【React深入】setState的执行机制/","excerpt":"","text":"一.几个开发中经常会遇到的问题以下几个问题是我们在实际开发中经常会遇到的场景，下面用几个简单的示例代码来还原一下。 1.setState是同步还是异步的，为什么有的时候不能立即拿到更新结果而有的时候可以?1.1 钩子函数和React合成事件中的setState现在有两个组件 123456789101112componentDidMount() &#123; console.log('parent componentDidMount');&#125;render() &#123; return ( &lt;div&gt; &lt;SetState2&gt;&lt;/SetState2&gt; &lt;SetState&gt;&lt;/SetState&gt; &lt;/div&gt; );&#125; 组件内部放入同样的代码，并在Setstate1中的componentDidMount中放入一段同步延时代码，打印延时时间： 123456789101112131415161718192021componentWillUpdate() &#123; console.log('componentWillUpdate');&#125;componentDidUpdate() &#123; console.log('componentDidUpdate');&#125;componentDidMount() &#123; console.log('SetState调用setState'); this.setState(&#123; index: this.state.index + 1 &#125;) console.log('state', this.state.index); console.log('SetState调用setState'); this.setState(&#123; index: this.state.index + 1 &#125;) console.log('state', this.state.index);&#125; 下面是执行结果： 说明： 1.调用setState不会立即更新 2.所有组件使用的是同一套更新机制，当所有组件didmount后，父组件didmount，然后执行更新 3.更新时会把每个组件的更新合并，每个组件只会触发一次更新的生命周期。 1.2 异步函数和原生事件中的setstate？在setTimeout中调用setState（例子和在浏览器原生事件以及接口回调中执行效果相同）1234567891011121314componentDidMount() &#123; setTimeout(() =&gt; &#123; console.log(&apos;调用setState&apos;); this.setState(&#123; index: this.state.index + 1 &#125;) console.log(&apos;state&apos;, this.state.index); console.log(&apos;调用setState&apos;); this.setState(&#123; index: this.state.index + 1 &#125;) console.log(&apos;state&apos;, this.state.index); &#125;, 0);&#125; 执行结果： 说明： 1.在父组件didmount后执行 2.调用setState同步更新 2.为什么有时连续两次setState只有一次生效？分别执行以下代码： 12345678componentDidMount() &#123; this.setState(&#123; index: this.state.index + 1 &#125;, () =&gt; &#123; console.log(this.state.index); &#125;) this.setState(&#123; index: this.state.index + 1 &#125;, () =&gt; &#123; console.log(this.state.index); &#125;)&#125; 12345678componentDidMount() &#123; this.setState((preState) =&gt; (&#123; index: preState.index + 1 &#125;), () =&gt; &#123; console.log(this.state.index); &#125;) this.setState(preState =&gt; (&#123; index: preState.index + 1 &#125;), () =&gt; &#123; console.log(this.state.index); &#125;)&#125; 执行结果： 1211 1222 说明： 1.直接传递对象的setstate会被合并成一次 2.使用函数传递state不会被合并 二.setState执行过程由于源码比较复杂，就不贴在这里了，有兴趣的可以去github上clone一份然后按照下面的流程图去走一遍。 1.流程图 partialState：setState传入的第一个参数，对象或函数 _pendingStateQueue：当前组件等待执行更新的state队列 isBatchingUpdates：react用于标识当前是否处于批量更新状态，所有组件公用 dirtyComponent：当前所有处于待更新状态的组件队列 transcation：react的事务机制，在被事务调用的方法外包装n个waper对象，并一次执行：waper.init、被调用方法、waper.close FLUSH_BATCHED_UPDATES：用于执行更新的waper，只有一个close方法 2.执行过程对照上面流程图的文字说明，大概可分为以下几步： 1.将setState传入的partialState参数存储在当前组件实例的state暂存队列中。 2.判断当前React是否处于批量更新状态，如果是，将当前组件加入待更新的组件队列中。 3.如果未处于批量更新状态，将批量更新状态标识设置为true，用事务再次调用前一步方法，保证当前组件加入到了待更新组件队列中。 4.调用事务的waper方法，遍历待更新组件队列依次执行更新。 5.执行生命周期componentWillReceiveProps。 6.将组件的state暂存队列中的state进行合并，获得最终要更新的state对象，并将队列置为空。 7.执行生命周期componentShouldUpdate，根据返回值判断是否要继续更新。 8.执行生命周期componentWillUpdate。 9.执行真正的更新，render。 10.执行生命周期componentDidUpdate。 三.总结1.钩子函数和合成事件中：在react的生命周期和合成事件中，react仍然处于他的更新机制中，这时isBranchUpdate为true。 按照上述过程，这时无论调用多少次setState，都会不会执行更新，而是将要更新的state存入_pendingStateQueue，将要更新的组件存入dirtyComponent。 当上一次更新机制执行完毕，以生命周期为例，所有组件，即最顶层组件didmount后会将isBranchUpdate设置为false。这时将执行之前累积的setState。 2.异步函数和原生事件中由执行机制看，setState本身并不是异步的，而是如果在调用setState时，如果react正处于更新过程，当前更新会被暂存，等上一次更新执行后在执行，这个过程给人一种异步的假象。 在生命周期，根据JS的异步机制，会将异步函数先暂存，等所有同步代码执行完毕后在执行，这时上一次更新过程已经执行完毕，isBranchUpdate被设置为false，根据上面的流程，这时再调用setState即可立即执行更新，拿到更新结果。 3.partialState合并机制我们看下流程中_processPendingState的代码，这个函数是用来合并state暂存队列的，最后返回一个合并后的state。 123456789101112131415161718192021222324_processPendingState: function (props, context) &#123; var inst = this._instance; var queue = this._pendingStateQueue; var replace = this._pendingReplaceState; this._pendingReplaceState = false; this._pendingStateQueue = null; if (!queue) &#123; return inst.state; &#125; if (replace &amp;&amp; queue.length === 1) &#123; return queue[0]; &#125; var nextState = _assign(&#123;&#125;, replace ? queue[0] : inst.state); for (var i = replace ? 1 : 0; i &lt; queue.length; i++) &#123; var partial = queue[i]; _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial); &#125; return nextState;&#125;, 我们只需要关注下面\b这段代码： 1_assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial); 如果传入的是对象，很明显会被合并成一次： 12345Object.assign( nextState, &#123;index: state.index+ 1&#125;, &#123;index: state.index+ 1&#125;) 如果传入的是函数，函数的参数preState是前一次合并后的结果，所以计算结果是准确的。 4.componentDidMount调用setstate 在componentDidMount()中，你 可以立即调用setState()。它将会触发一次额外的渲染，但是它将在浏览器刷新屏幕之前发生。这保证了在此情况下即使render()将会调用两次，用户也不会看到中间状态。谨慎使用这一模式，因为它常导致性能问题。在大多数情况下，你可以 在constructor()中使用赋值初始状态来代替。然而，有些情况下必须这样，比如像模态框和工具提示框。这时，你需要先测量这些DOM节点，才能渲染依赖尺寸或者位置的某些东西。 以上是官方文档的说明，不推荐直接在componentDidMount直接调用setState，由上面的分析：componentDidMount本身处于一次更新中，我们又调用了一次setState，就会在未来再进行一次render，造成不必要的性能浪费，大多数情况可以设置初始值来搞定。 当然在componentDidMount我们可以调用接口，再回调中去修改state，这是正确的做法。 当state初始值依赖dom属性时，在componentDidMount中setState是无法避免的。 5.componentWillUpdate componentDidUpdate这两个生命周期中不能调用setState。 由上面的流程图很容易发现，在它们里面调用setState会造成死循环，导致程序崩溃。 6.推荐使用方式在调用setState时使用函数传递state值，在回调函数中获取最新更新后的state。","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://www.lisq.xyz/tags/React/"}]},{"title":"前端性能优化总结","slug":"【性能优化】前端性能优化总结","date":"2018-12-28T14:33:19.000Z","updated":"2019-03-28T13:03:55.501Z","comments":true,"path":"2018/12/28/【性能优化】前端性能优化总结/","link":"","permalink":"https://www.lisq.xyz/2018/12/28/【性能优化】前端性能优化总结/","excerpt":"","text":"1.原则多使用内存，缓存或者其他方法 减少CPU计算，减少网络请求 减少IO操作（硬盘读写） 2.加载资源优化静态资源的合并和压缩。 静态资源缓存（浏览器缓存策略）。 使用CDN让静态资源加载更快。 3. 渲染优化CSS放head中，JS放body后 图片懒加载 减少DOM操作，对DOM操作做缓存 减少DOM操作，多个操作尽量合并在一起执行 事件节流 尽早执行操作 DOMContentLoaded 4. 示例4.1 资源合并1a.js b.js c.js --- abc.js 4.2 缓存通过连接名称控制缓存 1&lt;script src=\"abc_1.js\" &gt;&lt;/script&gt; 只有改变内容的时候，链接名称才会改变。 4.3 懒加载12345&lt;img src=\"preview.png\" realsrc=\"abc.png\" id=\"img1\" /&gt;&lt;script&gt; var i = document.getElementById('img1'); i.src = i.getAttribute('realsrc');&lt;/script&gt; 4.4 缓存dom查询12345678910//没有缓存domfor (let i = 0; i &lt; document.getElementsByTagName('p').length; i++) &#123;&#125;//缓存domvar p = document.getElementsByTagName('p');for (let i = 0; i &lt; p.length; i++) &#123;&#125; 4.5 合并dom插入123456789var listNode = document.getElementById('list');var flag = document.createDocumentFragment();var li;for (let i = 0; i &lt; 10; i++) &#123; li = document.createElement('li'); li.innerHTML = i; flag.appendChild(li);&#125;listNode.appendChild(flag); 10次dom插入 —&gt; 1次dom插入 4.6 事件节流监听文字改变事件，无操作100毫秒后执行操作，不用每次触发。12345678910var textarea = document.getElementById('ta');var timeoutId;textarea.addEventListener('keyup',function()&#123; if(i)&#123; clearTimeout(i); &#125; timeoutId = setTimeout(() =&gt; &#123; //操作 &#125;, 100);&#125;); 事件节流主要用于触发频率较高的事件，设定一个缓冲触发事件。 补充异步加载非核心代码异步加载 – 异步加载的方式 – 区别 1.动态脚本加载 用js创建 2.defer 3.async 123456&lt;script src=\"script.js\"&gt;&lt;/script&gt;没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。&lt;script async src=\"script.js\"&gt;&lt;/script&gt;有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。&lt;script defer src=\"myscript.js\"&gt;&lt;/script&gt;有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。 关于 defer，我们还要记住的是它是按照加载顺序执行脚本的 标记为async的脚本并不保证按照指定它们的先后顺序执行。对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，只要它加载完了就会立刻执行。 浏览器缓存总结的非常好 浏览器缓存 – 缓存的分类 – 缓存的原理 缓存就是html文件在本地存在的副本， 强缓存 发现有缓存直接用。 12345Expires: 绝对时间，判断客户端日期是否超过这个时间Cache-Control：相对时间，判断访问间隔是否大于3600秒//在设定时间之前不会和服务端进行通信了//如果两个都下发以后者为准 协商缓存 询问服务器缓存是否可以用，在进行判断是否用。 Last-Modified/If-Modified-Since 123456789第一次请求，respone的header加上Last-Modified（最后修改时间）再次请求，在request的header上加上If-Modified-Since 和服务端的最后修改时间对比，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。浏览器收到304的响应后，就会从缓存中加载资源如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified的Header在重新加载的时候会被更新 Etag/If-None-Match 这两个值是由服务器生成的每个资源的唯一标识字符串，只要资源有变化就这个值就会改变；其判断过程与Last-Modified/If-Modified-Since类似，他可以精确到秒的更高级别。 DNS预解析12&lt;meta http-equiv=\"x-dns-prefetch-control\" content=\"on\"&gt;&lt;link rel=\"dns-prefetch\" href=\"//www.zhix.net\"&gt; 在一些浏览器的a标签是默认打开dns预解析的，在https协议下dns预解析是关闭的，加入mate后会打开。","categories":[],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://www.lisq.xyz/tags/性能优化/"}]},{"title":"指令控制 windows 电源选项","slug":"【electron】指令控制-windows-电源选项","date":"2018-12-17T10:07:12.000Z","updated":"2019-04-06T05:28:00.004Z","comments":true,"path":"2018/12/17/【electron】指令控制-windows-电源选项/","link":"","permalink":"https://www.lisq.xyz/2018/12/17/【electron】指令控制-windows-电源选项/","excerpt":"","text":"1.powercfg命令。使用powercfg.exe控制电源计划（也称为电源使用方案）。 2.ac和dc一般电源有两种供电模式： ac代表交流电源 dc代表直流电源 一般情况下ac就是直接接通电源，dc是使用电池供电。 一般电源命令都需要分别设置在ac和dc下的模式。 3.电源选项的唯一标识每个电源选项都有一个唯一的guid标识，我们可以使用某些命令通过这个唯一标识来设定这个电源选项。 例如官方文档中的电源计划： 如图：电源计划 节电，平衡，高性能分别对应了一个guid。 我们可以通过查阅windows文档或者使用 1powercfg /query 命令来查询每个选项对应的guid。 4.设置电源计划1powercfg -setactive guid 可以通过-setactive来设置当前电源计划。 例如下面的代码将电源设置为平衡模式 1powercfg -setactive 381b4222-f694-41f0-9685-ff5bb260df2e 5.修改电源计划中的电源选项直接查看控制面板中的电源选项可以看到下面的界面 我们可以通过下面的命令来修改1powercfg -change value 后面的value有如下几个选项 12345678monitor-timeout-ac &lt;分钟&gt;monitor-timeout-dc &lt;分钟&gt;disk-timeout-ac &lt;分钟&gt;disk-timeout-dc &lt;分钟&gt;standby-timeout-ac &lt;分钟&gt;standby-timeout-dc &lt;分钟&gt;hibernate-timeout-ac &lt;分钟&gt;hibernate-timeout-dc &lt;分钟&gt; monitor:屏幕disk:磁盘standby:待机hibernate:休眠 实例： 1powercfg /change monitor-timeout-ac 5 表示：在接通电源模式下设置屏幕5分钟后关闭。 1powercfg /change monitor-hibernate-dc 0 表示：在不接通电源模式下永不休眠 6.高级选项还有一些其他选项，例如按下电源按钮，睡眠按钮，关闭盖子等发生的操作。 可以使用如下命令设置： 123powercfg /setacvalueindex scheme_GUID sub_GUID setting_GUID setting_indexpowercfg /setdcvalueindex scheme_GUID sub_GUID setting_GUID setting_index scheme_GUID : 电源计划guid，可以通过powercfg /list查询 sub_GUID：子组guid，可以解释成在众多的电源选项上又分的一层组，可以通过过powercfg /query查询 setting_GUID：选项guid，具体的电源选项。 setting_index：具体设置的索引，如下图： 不采取任何操作，睡眠，休眠，关机 例如： 1powercfg -SetAcValueIndex 381b4222-f694-41f0-9685-ff5bb260df2e 4f971e89-eebd-4455-a8de-9e59040e7347 5ca83367-6e45-459f-a27b-476b1d01c936 0 表示：设置接通电源的情况下，电源关盖后不采取任何操作。 1powercfg -SetDcValueIndex 381b4222-f694-41f0-9685-ff5bb260df2e 4f971e89-eebd-4455-a8de-9e59040e7347 7648efa3-dd9c-4e3e-b566-50f929386280 1 表示：设置未接通电源的情况下，按下电源键使电脑进入睡眠。 7.总结有了这些操作，我们就可以使用某些语言比如node，来批处理windows电源选项了。 更详细的选项可以查询windows官方文档： https://docs.microsoft.com/en-us/windows-hardware/design/device-experiences/powercfg-command-line-options#option_getactivescheme","categories":[],"tags":[{"name":"electron","slug":"electron","permalink":"https://www.lisq.xyz/tags/electron/"}]},{"title":"react中key的正确使用方式","slug":"【React深入】react中key的正确使用方式","date":"2018-11-26T17:50:45.000Z","updated":"2019-03-28T13:03:38.972Z","comments":true,"path":"2018/11/27/【React深入】react中key的正确使用方式/","link":"","permalink":"https://www.lisq.xyz/2018/11/27/【React深入】react中key的正确使用方式/","excerpt":"","text":"在开发react程序时我们经常会遇到这样的警告，然后就会想到：哦！循环子组件忘记加key了～ 出于方便，有时候会不假思索的使用循环的索引作为key，但是这样真的好吗？什么样的值才是key的最佳选择？ 为了弄明白，本文将从三个方面来分析”key”： 1.为什么要使用key 2.使用index做key存在的问题 3.正确的选择key 1.为什么要使用keyreact官方文档是这样描述key的： Keys可以在DOM中的某些元素被增加或删除的时候帮助React识别哪些元素发生了变化。因此你应当给数组中的每一个元素赋予一个确定的标识。 react的diff算法是把key当成唯一id然后比对组件的value来确定是否需要更新的，所以如果没有key，react将不会知道该如何更新组件。 你不传key也能用是因为react检测到子组件没有key后，会默认将数组的索引作为key。 react根据key来决定是销毁重新创建组件还是更新组件，原则是： key相同，组件有所变化，react会只更新组件对应变化的属性。 key不同，组件会销毁之前的组件，将整个组件重新渲染。 2.使用index做key存在的问题2.1 受控组件单纯的展示组件比如span，这些组件是受控组件，意味着他们的值将是我们给定好的。 如果子组件只是受控组件，使用index作为key，可能表面上不会有什么问题，实际上性能会受很大的影响。例如下面的代码： 123456789101112// [&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;]=&gt;&lt;ul&gt; &lt;li key=&quot;0&quot;&gt;张三&lt;/li&gt; &lt;li key=&quot;1&quot;&gt;李四&lt;/li&gt; &lt;li key=&quot;2&quot;&gt;王五&lt;/li&gt;&lt;/ul&gt;// 数组重排 -&gt; [&apos;王五&apos;,&apos;张三&apos;,&apos;李四&apos;] =&gt;&lt;ul&gt; &lt;li key=&quot;0&quot;&gt;王五&lt;/li&gt; &lt;li key=&quot;1&quot;&gt;张三&lt;/li&gt; &lt;li key=&quot;2&quot;&gt;李四&lt;/li&gt;&lt;/ul&gt; 当元素数据源的顺序发生改变时，对应的： key为0，1，2的组件都发生了变化，三个子组件都会被重新渲染。（这里的重新渲染不是销毁，因为key还在） 相反，我们使用唯一id作为key： 123456789101112// [&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;]=&gt;&lt;ul&gt; &lt;li key=&quot;000&quot;&gt;张三&lt;/li&gt; &lt;li key=&quot;111&quot;&gt;李四&lt;/li&gt; &lt;li key=&quot;222&quot;&gt;王五&lt;/li&gt;&lt;/ul&gt;// 数组重排 -&gt; [&apos;王五&apos;,&apos;张三&apos;,&apos;李四&apos;] =&gt;&lt;ul&gt; &lt;li key=&quot;222&quot;&gt;王五&lt;/li&gt; &lt;li key=&quot;000&quot;&gt;张三&lt;/li&gt; &lt;li key=&quot;111&quot;&gt;李四&lt;/li&gt;&lt;/ul&gt; 根据上面的更新原则，子组件的值和key均未发生变化，只是顺序发生改变，因此react只是将他们做了移动，并未重新渲染。 2.2 非受控组件像input这样可以由用户任意改变值，不受我们控制的组件，在使用了index作为key时可能会发生问题，看如下的栗子： 子组件： 123456789 render() &#123; return ( &lt;div&gt; &lt;p &gt;值：&#123;this.props.value&#125;&lt;/p&gt; &lt;input /&gt; &lt;/div&gt; ); &#125;&#125; 父组件12345&#123;this.state.data.map((element, index) =&gt; &#123; return &lt;Child value=&#123;element&#125; key=&#123;index&#125; /&gt; &#125;)&#125; 我们在前两个输入框分别输入对应的值： 然后在头部添加一个元素： 很明显，这个结果并不符合我们的预期，我们来分析一下发生了什么： 123456789101112&lt;div key=&quot;0&quot;&gt; &lt;p &gt;值：0&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=&quot;1&quot;&gt; &lt;p &gt;值：1&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=&quot;2&quot;&gt; &lt;p &gt;值：2&lt;/p&gt; &lt;input /&gt;&lt;/div&gt; 变化后： 12345678910111213141516&lt;div key=&quot;0&quot;&gt; &lt;p &gt;值：5&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=&quot;1&quot;&gt; &lt;p &gt;值：0&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=&quot;2&quot;&gt; &lt;p &gt;值：1&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=&quot;3&quot;&gt; &lt;p &gt;值：2&lt;/p&gt; &lt;input /&gt;&lt;/div&gt; 可以发现：key 0，1，2并没有发生改变，根据规则，不会卸载组件，只会更新改变的属性。 react只diff到了p标签内值的变化，而input框中的值并未发生改变，因此不会重新渲染，只更新的p标签的值。 当使用唯一id作为key后： 123456789101112&lt;div key=&quot;000&quot;&gt; &lt;p &gt;值：0&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=&quot;111&quot;&gt; &lt;p &gt;值：1&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=&quot;222&quot;&gt; &lt;p &gt;值：2&lt;/p&gt; &lt;input /&gt;&lt;/div&gt; 变化后： 12345678910111213141516&lt;div key=&quot;555&quot;&gt; &lt;p &gt;值：5&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=&quot;000&quot;&gt; &lt;p &gt;值：0&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=&quot;111&quot;&gt; &lt;p &gt;值：1&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=&quot;222&quot;&gt; &lt;p &gt;值：2&lt;/p&gt; &lt;input /&gt;&lt;/div&gt; 可以很明显的发现：key为 111，222，333的组件没有发生任何改变，react不会更新他们，只是新插入了子组件555，并改变了其他组件的位置。 3.正确的选择key3.1 纯展示如果组件单纯的用于展示，不会发生其他变更，那么使用index或者其他任何不相同的值作为key是没有任何问题的，因为不会发生diff，就不会用到key。 3.2 推荐使用index的情况并不是任何情况使用index作为key会有缺陷，比如如下情况： 你要分页渲染一个列表，每次点击翻页会重新渲染： 使用唯一id： 123456789101112第一页&lt;ul&gt; &lt;li key=&quot;000&quot;&gt;张三&lt;/li&gt; &lt;li key=&quot;111&quot;&gt;李四&lt;/li&gt; &lt;li key=&quot;222&quot;&gt;王五&lt;/li&gt;&lt;/ul&gt;第二页&lt;ul&gt; &lt;li key=&quot;333&quot;&gt;张三三&lt;/li&gt; &lt;li key=&quot;444&quot;&gt;李四四&lt;/li&gt; &lt;li key=&quot;555&quot;&gt;王五五&lt;/li&gt;&lt;/ul&gt; 翻页后，三条记录的key和组件都发生了改变，因此三个子组件都会被卸载然后重新渲染。 使用index： 123456789101112第一页&lt;ul&gt; &lt;li key=&quot;0&quot;&gt;张三&lt;/li&gt; &lt;li key=&quot;1&quot;&gt;李四&lt;/li&gt; &lt;li key=&quot;2&quot;&gt;王五&lt;/li&gt;&lt;/ul&gt;第二页&lt;ul&gt; &lt;li key=&quot;0&quot;&gt;张三三&lt;/li&gt; &lt;li key=&quot;1&quot;&gt;李四四&lt;/li&gt; &lt;li key=&quot;2&quot;&gt;王五五&lt;/li&gt;&lt;/ul&gt; 翻页后，key不变，子组件值发生改变，组件并不会被卸载，只发生更新。 3.3 子组件可能发生变更/使用了非受控组件大多数情况下，使用唯一id作为子组件的key是不会有任何问题的。 这个id一定要是唯一，并且稳定的，意思是这条记录对应的id一定是独一无二的，并且永远不会发生改变。 不推荐使用math.random或者其他的第三方库来生成唯一值作为key。 因为当数据变更后，相同的数据的key也有可能会发生变化，从而重新渲染，引起不必要的性能浪费。 如果数据源不满足我们这样的需求，我们可以在渲染之前为数据源手动添加唯一id，而不是在渲染时添加。","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://www.lisq.xyz/tags/React/"}]},{"title":"electron程序保护措施（崩溃监控，开机自启，托盘关闭）","slug":"【electron】electron程序保护措施（崩溃监控，开机自启，托盘关闭）","date":"2018-11-07T12:11:41.000Z","updated":"2019-04-06T05:27:51.873Z","comments":true,"path":"2018/11/07/【electron】electron程序保护措施（崩溃监控，开机自启，托盘关闭）/","link":"","permalink":"https://www.lisq.xyz/2018/11/07/【electron】electron程序保护措施（崩溃监控，开机自启，托盘关闭）/","excerpt":"","text":"在某种情况下，我们可能希望我们的客户端程序尽可能连续不断的运行在我们的系统中，并保持稳定。 以下几种方式可以帮助我们做到这一点： 1.崩溃监控electron为我们提供了监听程序崩溃的事件： 123456Event: &apos;crashed&apos;返回:event Eventkilled Boolean当渲染进程崩溃或被结束时触发 此事件是用来家庭渲染进程崩溃的，但是当主进程意外崩溃时也会触发该事件。 在监测到程序崩溃后，我们要让程序重新启动，此时我们要首先判断window对象是否被销毁，也就是主进程是否被杀死，还是渲染进程崩溃，同时作出不同的处理。 当mainWin被销毁时我们直接重启整个应用，使用如下api： 12345678910app.relaunch([options])options Object (可选)args StringexecPath String (可选)从当前实例退出，重启应用。默认情况下，新的实例会和当前实例使用相同的工作目录以及命令行参数。 当设置了 args 参数时， args 将作为命令行参数传递。 当设置了 execPath ，execPath 将被执行以重新启动，而不是当前的应用程序。请注意, 此方法在执行时不会退出当前的应用程序, 你需要在调用 app.relaunch 方法后再执行 app. quit 或者 app.exit 来让应用重启。 只是渲染进程崩溃，我们只需将其他窗体销毁，然后重新load我们的主窗口。 崩溃重启逻辑： 123456789if (mainWin.isDestroyed()) &#123; app.relaunch(); app.exit(0);&#125; else &#123; BrowserWindow.getAllWindows().forEach((w) =&gt; &#123; if (w.id !== mainWin.id) w.destroy(); &#125;); mainWin.reload();&#125; 当然，我们还要记录一下程序的崩溃日志，我们要确保日志接口发出成功后再重启我们的程序： 下面是程序崩溃后的完整逻辑： 123456789101112131415161718192021222324252627282930313233343536373839import &#123; BrowserWindow, app, dialog&#125; from &apos;electron&apos;; const mainWindow = BrowserWindow.fromId(global.mainId);mainWindow.webContents.on(&apos;crashed&apos;, () =&gt; &#123; const options = &#123; type: &apos;error&apos;, title: &apos;进程崩溃了&apos;, message: &apos;这个进程已经崩溃.&apos;, buttons: [&apos;重载&apos;, &apos;退出&apos;], &#125;; recordCrash().then(() =&gt; &#123; dialog.showMessageBox(options, (index) =&gt; &#123; if (index === 0) reloadWindow(mainWindow); else app.quit(); &#125;); &#125;).catch((e) =&gt; &#123; console.log(&apos;err&apos;, e); &#125;);&#125;)function recordCrash() &#123; return new Promise(resolve =&gt; &#123; // 崩溃日志请求成功.... resolve(); &#125;)&#125; function reloadWindow(mainWin) &#123; if (mainWin.isDestroyed()) &#123; app.relaunch(); app.exit(0); &#125; else &#123; BrowserWindow.getAllWindows().forEach((w) =&gt; &#123; if (w.id !== mainWin.id) w.destroy(); &#125;); mainWin.reload(); &#125;&#125; 写好代码之后，我们可以直接在控制台输入 123456789101112# 2.开机自启开机自启是保证我们的程序能长时间在机器上运行很重要的一点。电脑上有很多程序都设置了开机自启动，比如qq，微信，迅雷等，他们都是通过修改注册表来实现的，我们可以看一下注册表``` \\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run```:![image](https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/zhucebiao1.bmp)所以我们也要将我们程序的路径写到这里。发现了一个非常好的写注册表的模块，```winreg 注意mac不能使用这个模块，所以首先要判断是否为window再引用这个模块。 借助这个模块我们可以非常简单的修改注册表： 1234567891011121314151617181920212223242526272829303132333435363738394041const WinReg = require(&apos;winreg&apos;);const startOnBoot = &#123; enableAutoStart: function (name, file, callback) &#123; var key = getKey(); key.set(name, WinReg.REG_SZ, file, callback || noop); &#125;, disableAutoStart: function (name, callback) &#123; var key = getKey(); key.remove(name, callback || noop); &#125;, getAutoStartValue: function (name, callback) &#123; var key = getKey(); key.get(name, function (error, result) &#123; if (result) &#123; callback(result.value); &#125; else &#123; callback(null, error); &#125; &#125;); &#125;&#125;;function noop() &#123; &#125;const RUN_LOCATION = &apos;\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run&apos;;function getKey() &#123; return new WinReg(&#123; hive: WinReg.HKCU, //CurrentUser, key: RUN_LOCATION &#125;);&#125;export default function autoStart() &#123; startOnBoot.getAutoStartValue(&apos;MY_CLIENT_AUTOSTART&apos;, function (value) &#123; if (!value) &#123; startOnBoot.enableAutoStart(&apos;MY_CLIENT_AUTOSTART&apos;, process.execPath, function () &#123; console.log(&apos;开机自动启设置&apos;); &#125;); &#125; &#125;);&#125; 执行完程序之后，再看注册表，发现我们程序的路径已经写进去了： 然后电脑重启后你的程序就自动启动了。 3.托盘关闭向qq和微信一样，有的时候我们并不想让用户通过点关闭按钮的时候就关闭程序，而是把程序最小化到托盘，在托盘上做真正的退出操作。 首先要监听窗口的关闭事件，阻止用户关闭操作的默认行为。 1234mainWindow.on(&apos;close&apos;, (event) =&gt; &#123; mainWindow.hide(); event.preventDefault();&#125;); 然而这时你发现，这只是最小化了程序，任务栏里程序依然存在，我们需要让程序在任务栏里也消失： 12345mainWindow.on(&apos;close&apos;, (event) =&gt; &#123; mainWindow.hide(); mainWindow.setSkipTaskbar(true); event.preventDefault();&#125;); 这时程序就再也找不到了，任务托盘中也没有我们的程序，所以我们要先创建好任务托盘，并做好事件监听： 123456789101112131415161718function createTray() &#123; const mainWindow = BrowserWindow.fromId(global.mainId); tray = new Tray(path.join(global.__dirname, &apos;icon.ico&apos;)); const contextMenu = Menu.buildFromTemplate([ &#123; label: &apos;退出&apos;, click: () =&gt; &#123; mainWindow.destroy(); app.quit(); &#125; &#125;, ]) tray.setToolTip(&apos;我的客户端&apos;) tray.setContextMenu(contextMenu) tray.on(&apos;click&apos;, () =&gt; &#123; if (mainWindow.isVisible()) &#123; mainWindow.hide(); mainWindow.setSkipTaskbar(false); &#125; else &#123; mainWindow.show(); mainWindow.setSkipTaskbar(true); &#125; &#125;) &#125; 以上这些操作为我们的程序又增加了好几层的防护措施，我们的程序就不会那么轻而易举的挂掉啦！","categories":[],"tags":[{"name":"electron","slug":"electron","permalink":"https://www.lisq.xyz/tags/electron/"}]},{"title":"使用electron静默打印","slug":"【electron】使用electron静默打印","date":"2018-11-01T10:30:14.000Z","updated":"2019-04-06T05:27:56.036Z","comments":true,"path":"2018/11/01/【electron】使用electron静默打印/","link":"","permalink":"https://www.lisq.xyz/2018/11/01/【electron】使用electron静默打印/","excerpt":"","text":"1.使用electron打印的理由很多情况下程序中使用的打印都是用户无感知的。并且想要灵活的控制打印内容，往往需要借助打印机给我们提供的api再进行开发，这种开发方式非常繁琐，并且开发难度较大。 electron提供的打印api可以非常灵活的控制打印设置的显示，并且可以通过html来书写打印内容。 2.apielectron提供了两种方式进行打印，一种是直接调用打印机打印，一种是打印到pdf。 并且有两种对象可以调用打印： 第一是通过window的webcontent对象，使用此种方式需要单独开出一个打印的窗口，可以将该窗口隐藏，但是通信调用相对复杂。 另一种是使用页面的webview元素调用打印，可以将webview隐藏在调用的页面中，通信方式比较简单。 两个对象调用打印方法的使用方式都一样。 2.1 print官网api如下 123456789contents.print([options], [callback])选项 Object (可选)silent Boolean (可选) - 不询问用户打印信息，默认为 false。printBackground Boolean (optional) - Also prints the background color and image of the web page. Default is false.deviceName String (optional) - Set the printer device name to use. Default is &apos;&apos;.callback Function (可选)success Boolean - Indicates success of the print call. 打印配置(options)中只有简单的三个配置： silent：打印时是否不展示打印配置（是否静默打印） printBackground：是否打印背景 deviceName：打印机设备名称 首先要将我们使用的打印机名称配置好，并且要在调用打印前首先要判断打印机是否可用。 使用getPrinters方法可获取当前设备已经配置的打印机列表，注意配置过不是可用，只是在此设备上安装过驱动。 通过getprinter获取到的打印机对象：https://electronjs.org/docs/api/structures/printer-info 我们这里只管关心两个，name和status，status为0时表示打印机可用。 这里的status必须经历一次打印失败才能返回非0值，也就是说第一次获取打印机状态一定是0。但是这一次的打印虽然不能判断出错误，打印的任务已经预存在队列中了，当下一次打印机状态变为可用时，将会打印暂存的任务。 当打印机纸张用完时也是这种情况，剩余任务会暂存起来，下次打印机可用时即可以打印了。 print的第二个参数callback是用于判断打印任务是否发出的回调，而不是打印任务完成后的回调。所以一般打印任务发出，回调函数即会调用并返回参数true。这个回调并不能判断打印是否真的成功了。 2.2 printToPdf123456789101112contents.printToPDF(options, callback)选项 ObjectmarginsType Integer (optional) - Specifies the type of margins to use. Uses 0 for default margin, 1 for no margin, and 2 for minimum margin.pageSize String (optional) - Specify page size of the generated PDF. Can be A3, A4, A5, Legal, Letter, Tabloid or an Object containing height and width in microns.printBackground Boolean (optional) - Whether to print CSS backgrounds.printSelectionOnly Boolean (optional) - Whether to print selection only.landscape Boolean (optional) - true for landscape, false for portrait.callback Function - 回调函数error Errordata Buffer printToPdf的用法基本和print相同，但是由于print是native code提供的方法，配置项非常少，而printToPdf则扩展了很多属性。 包括可以对打印的margin，打印页眉页脚等进行配置。 配置项很多，翻了一下源码发现还有很多没有被贴进api的： 123456789101112131415161718192021222324252627const defaultPrintingSetting = &#123; pageRage: [], mediaSize: &#123;&#125;, landscape: false, color: 2, headerFooterEnabled: false, marginsType: 0, isFirstRequest: false, requestID: getNextId(), previewModifiable: true, printToPDF: true, printWithCloudPrint: false, printWithPrivet: false, printWithExtension: false, deviceName: &apos;Save as PDF&apos;, generateDraftData: true, fitToPageEnabled: false, scaleFactor: 1, dpiHorizontal: 72, dpiVertical: 72, rasterizePDF: false, duplex: 0, copies: 1, collate: true, shouldPrintBackgrounds: false, shouldPrintSelectionOnly: false&#125; 3.打印边距问题打印的时候打印机会给纸张留一个默认边距，如果是A4这样的纸张几乎可以忽略不计了，但是打印小规格纸张如50mm*50mm，这个边距就十分明显了，严重影响了整体布局。 printToPdf方法提供了非常多的配置项，其中包括了配置打印边距的参数，但是print方法却没有该配置项。 我们可以通过一项css配置来解决这个问题,即12 @page { margin: 0px; } 12345678910111213141516171819通过此配置可灵活配置打印边距。还有一个css属性``` @media print &#123;&#125;``` 此配置是只有在打印时才生效的css，控制的是打印边距以内的css，并不能控制打印边距。# 4.打印方案使用webcontent打印，首先要有一个打印窗口，这个窗口不能随时打印随时创建，比较耗费性能。可以将它在程序运行时启动好，并做好事件监听。此过程需和调用打印的进行做好通信：大致过程如下：![image](http://on-img.com/chart_image/5badf135e4b0fe81b64ad7b9.png)可见通信非常繁琐使用webview进行打印可实现同样的效果但是通信方式会变得简单，因为渲染进程和webview通信不需要经过主进程，通过如下方式即可： // In embedder page. const webview = document.querySelector(‘webview’) webview.addEventListener(‘ipc-message’, (event) =&gt; { console.log(event.channel) // Prints “pong” }) webview.send(‘ping’)Copy123456```// 在访客页。 const &#123;ipcRenderer&#125; = require(&apos;electron&apos;) ipcRenderer.on(&apos;ping&apos;, () =&gt; &#123; ipcRenderer.sendToHost(&apos;pong&apos;) &#125;) 5.示例程序示例demo：https://github.com/ConardLi/electron-print-demo","categories":[],"tags":[{"name":"electron","slug":"electron","permalink":"https://www.lisq.xyz/tags/electron/"}]},{"title":"个人博客搭建及配置","slug":"【博客搭建】个人博客搭建及配置","date":"2018-01-01T12:13:20.000Z","updated":"2019-04-06T05:24:53.435Z","comments":true,"path":"2018/01/01/【博客搭建】个人博客搭建及配置/","link":"","permalink":"https://www.lisq.xyz/2018/01/01/【博客搭建】个人博客搭建及配置/","excerpt":"","text":"一、基础配置 1.1.本地安装hexo首先保证你电脑上有node环境，这个不懂的可以自定百度。 控制台输入node -v出现版本号说明安装成功。 有了node就可以安装hexo了，控制台输入如下命令 1npm i -g hexo 同样控制台输入hexo -v出现版本号说明安装成功。 然后开始初始化项目，控制台输入： 1hexo init 得到如下项目目录： 12345678node_modules：是依赖包public：存放的是生成的页面scaffolds：命令生成文章等的模板source：用命令创建的各种文章themes：主题_config.yml：整个博客的配置db.json：source解析所得到的package.json：项目所需模块项目的配置信息 1.2.本地运行首先在本地跑起来你的代码 控制台安装hexo-server 1npm i hexo-server 然后运行 hexo-server 在浏览器中访问：http://localhost:4000就可以看到你本定运行的页面了 这时你可以在本地调试一下你的blog。 1.3.github配置首先要创建一个github账号 并配置好ssh 这些不懂的可以自行百度。 创建一个repo，名称为yourname.github.io, 其中yourname是你的github名称，按照这个规则创建github page才会生效。 修改_config.yml中的git配置 1234deploy: type: git repo: https://github.com/xxxx.git branch: master 1.4.部署上传在本地安装上传工具 1npm install hexo-deployer-git --save 依次执行如下命令 123hexo clean //删除上次打包hexo generate //打包hexo deploy /上传 这里我单独写了sh执行这三段脚本，这样每次只需要执行这个sh即可。 在浏览器中输入http://yourgithubname.github.io就可以看到你的个人博客了！ 1.5一些其他配置搜索功能使用搜索功能首先需要： 1npm install -S hexo-generator-json-content 然后： 12search: insight: true readme1.首先在source文件夹下建立一个README.md 2.修改_config.yml 1skip_render: README.md 二、绑定二人域名2.1购买一个域名这里我选择的是阿里云，挑选一个自己喜欢的域名购买。 2.2域名解析进入控制台添加域名解析。 按照如下规则添加两条记录。 这时去访问解析好的域名会出现如下页面。 这说明域名解析没有问题，接下来进入github进行配置 2.3 hexo配置在本地的博客目录中找到source文件夹。 新建一个没有后缀名的文件GNAME 在文件中添加你的域名，如： 1lisq.xyz 保存后重新生成，并提交你的博客。 2.4 github配置在github中找到你的博客仓库。 点击12找到```Custom domain 输入你的域名点击save 然后你就可以在浏览器用你的域名愉快的访问啦！ 三、同时托管到github和coding上github page毕竟是国外站点，访问速度相对来说比较慢，但是同时你又想在gihub上保存一下代码，可以尝试同时托管两个仓库。 做解析的时候海外的ip 指向到github，国内的或者说百度的直接指向coding。 3.1.在coding上提交代码首先做的操作和github是一样的，就是创建一个ssh。 这里要注意的是，你的电脑上已经有了gihub的ssh，如果还像github一样一路回车会把gihub的ssh给覆盖掉。 所以这里在执行 1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 时要注意，给生成的文件配置一个新路径： 然后配置生成的ssh 在coding中创建一个仓库，这里注意仓库的名字可以随意取，不像gihub一样可以随意给定。 将创建仓库的git地址添加到_config.yml中： 123456deploy: type: git repo: github: https://github.com/ConardLi/ConardLi.github.io.git coding: https://git.dev.tencent.com/ConardLi/lisqBlog.git branch: master 然后重新部署并上传博客，去仓库查看代码证明上传成功： 3.2.开启coding page点击coding的pages服务，直接点击一键开启即可。 开启后即可通过给定域名直接访问了： http://conardli.coding.me/ 3.3.域名解析将新生成的coding域名进行解析，这样国内就默认访问coding的页面，比github要快不少。 另外还可以将github的ip进行国外站点配置。 在coding page中将自己的域名进行绑定。 配置完成后发现速度快了不少，有木有… 四、站长统计 使用一个站长统计工具，可以为博客添加一个如上面似的详细的访问报表。 站长统计工具有很多，每个工具大同小异，这里我选择了CNZZ。 4.1.CNZZ配置1.注册一个账号。 2.添加网站。 按照如下要求添加网站 3.选择统计代码 添加完网站后就可以选择一段代码插入你的博客里了，CNZZ提供了几种样式，你可以选择展示真实的统计数量，一个cnzz图标或者什么都不显示。 4.2.代码配置将上面复制的代码插入到你主题代码的公共区域中。 每个主题的代码都不一样，但是大体结构是相同的，都会将通用的组件抽取出来。 这里我找到了每个页面都使用的footer组件，我使用的是hueman主题，代码在themes/hueman/common/footer.ejs 在此文件中找到合适的位置插入你的统计代码。 比如我的（script内的部分）： 五、阅读统计这里的统计是用来展示在页面上的，可以标示文章以及博客的热度。 使用不蒜子来展示文章访问统计和页面访问统计。 5.1.引入不蒜子将不蒜子js文件引入博客主题公共组件中。 1&lt;script async src=\"//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt; 这里我同站长统计一样放在themes/hueman/common/footer.ejs 5.2.文章访问统计要显示每篇文章的访问量，复制以下代码添加到你需要显示的位置。 可以在标签上自定义一些样式。 算法：pv的方式，单个用户点击1篇文章，本篇文章记录1次阅读量。 123&lt;span id=\"busuanzi_container_page_pv\"&gt; 本文总阅读量&lt;span id=\"busuanzi_value_page_pv\"&gt;&lt;/span&gt;次&lt;/span&gt; 5.3.整站访问统计算法a：pv的方式，单个用户连续点击n篇文章，记录n次访问量。 123&lt;span id=\"busuanzi_container_site_pv\"&gt; 本站总访问量&lt;span id=\"busuanzi_value_site_pv\"&gt;&lt;/span&gt;次&lt;/span&gt; 算法b：uv的方式，单个用户连续点击n篇文章，只记录1次访客数。123&lt;span id=\"busuanzi_container_site_uv\"&gt; 本站访客数&lt;span id=\"busuanzi_value_site_uv\"&gt;&lt;/span&gt;人次&lt;/span&gt; 六、评论系统博客使用valine作为评论工具，原因是他使用简介，体积轻量，灵活配置，速度很快！ 6.1 注册LeanCloudvaline接住了LeanCloud的力量，所以需要LeanCloud的APP ID 和 APP Key 首先注册和登录LeanCloud 创建一个应用： 应用创建好以后，进入刚刚创建的应用，选择左下角的设置&gt;应用Key，然后就能看到你的APP ID和APP Key了： 6.2 代码将如下代码插入你的文章模板中 1234567891011121314151617&lt;head&gt; ... &lt;script src=&quot;//cdn1.lncld.net/static/js/3.0.4/av-min.js&quot;&gt;&lt;/script&gt; &lt;script src=&apos;//unpkg.com/valine/dist/Valine.min.js&apos;&gt;&lt;/script&gt; ...&lt;/head&gt;&lt;body&gt; ... &lt;div id=&quot;vcomments&quot;&gt;&lt;/div&gt; &lt;script&gt; new Valine(&#123; el: &apos;#vcomments&apos;, appId: &apos;&lt;API_ID&gt;&apos;, appKey: &apos;&lt;API_Key&gt;&apos; &#125;) &lt;/script&gt;&lt;/body&gt; 配置好这些，等待两分钟，就可以在文章里使用你的评论啦。 6.3 数据管理由于Valine 是无后端评论系统，所以也就没有开发评论数据管理功能。 可以在leanCloud中管理评论 1登录&gt;选择你创建的应用&gt;存储&gt;选择Class Comment 6.4 安全域名为了数据安全，在leanCloud中配置你的安全域名 6.5 配置项Valine还有一些其他的配置项 123456789new Valine(&#123; el: &apos;#vcomments&apos; , appId: &apos;&lt;APP_ID&gt;&apos;, appKey: &apos;&lt;APP_KEY&gt;&apos;, notify:false, verify:false, avatar:&apos;mm&apos;, placeholder: &apos;just go go&apos; &#125;); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788placeholder类型:String默认值:Just go go必要性:false评论框占位提示符。notify类型:Boolean默认值:false必要性:false评论回复邮件提醒，请参考配置。verify类型:Boolean默认值:false必要性:false验证码服务。path类型:String默认值:window.location.pathname必要性:false当前文章页路径，用于区分不同的文章页，以保证正确读取该文章页下的评论列表。可选值：window.location.pathname (默认值，推荐)window.location.href自定义I. 请保证每个文章页路径的唯一性，否则可能会出现不同文章页下加载相同评论列表的情况。II. 如果值为window.location.href，可能会出现随便加不同参数进入该页面，而被判断成新页面的情况。avatar类型:String默认值:mm必要性:falseGravatar 头像展示方式。可选值：&apos;&apos;(空字符串)mpidenticonmonsteridwavatarretrorobohashhide更多信息，请查看头像配置。meta类型:Array默认值:[&apos;nick&apos;,&apos;mail&apos;,&apos;link&apos;]必要性:false评论者相关属性。pageSize类型:Number默认值:10必要性:false评论列表分页，每页条数。lang类型:String默认值:zh-cn必要性:false多语言支持。可选值：zh-cnen如需自定义语言，请参考i18n。visitor类型:Boolean默认值:false必要性:false文章访问量统计。highlight类型：Boolean默认值: true必要性: false代码高亮，默认开启，若不需要，请手动关闭avatarForce类型: Boolean默认值: false必要性: false 七、SEO优化SEO是由英文Search Engine Optimization缩写而来， 中文意译为“搜索引擎优化”。SEO是指通过站内优化比如网站结构调整、网站内容建设、网站代码优化等以及站外优化。 简而言之，就是让人们更容易搜索到你的站点。 首先要做的就是让搜索引擎收录我们的站点。 7.1.百度7.1.1 提交网址在搜索引擎中输入site:&lt;域名&gt;,如果如下图所示就是说明我们的网站并没有被百度收录。我们可以直接点击下面的“网址提交”来提交我们的网站 然后点击途中的提交网址 选择站点的相关属性： 接下来进行网站验证，推荐使用第三种GNAME验证，简单快捷，只需要给你的链接增加一条解析即可: 7.1.2 生成网站地图接下来要让你的网站生成网站地图，及生产sitemap，将sitemap提交到百度，先安装地图生成插件： 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 注意根目录的_config.yml将url配置成你的站点1234# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://lisq.xyz/root: / 重新部署博客后就会生成两个新文件sitemap.xml和baidusitemap.xml 7.1.3 将sitemap提交给百度点击链接提交 使用主动推送 主动推送安装插件npm install hexo-baidu-url-submit –save然后再根目录的配置文件中新增字段12345baidu_url_submit: count: 100 host: https://lisq.xyz/ token: 8OGYpxowYnhgVsUM path: baidu_urls.txt # 文本文档的地址 在加入新的deploye12deploy: - type:baidu_url_submitter 百度收录的时间非常长，耐心等待吧。 7.2.谷歌点击这里添加你的网址 点击添加属性后即可添加你的博客地址。 进行验证： 谷歌收录的速度还是相当快的，而且操作比较简单。","categories":[],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.lisq.xyz/tags/博客搭建/"}]}]}