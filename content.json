{"meta":{"title":"李世奇的技术专栏","subtitle":null,"description":"Fe Coder","author":"ConardLi","url":"https://www.lisq.xyz"},"pages":[{"title":"about","date":"2018-10-28T15:07:13.000Z","updated":"2018-11-03T15:46:49.634Z","comments":true,"path":"about/index.html","permalink":"https://www.lisq.xyz/about/index.html","excerpt":"","text":"关于，以后再说…….."}],"posts":[{"title":"css面试题总结","slug":"css面试题总结","date":"2019-01-04T12:48:27.000Z","updated":"2019-01-04T12:49:27.999Z","comments":true,"path":"2019/01/04/css面试题总结/","link":"","permalink":"https://www.lisq.xyz/2019/01/04/css面试题总结/","excerpt":"","text":"1. 介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？ css可以设置： 1box-sizing : content-box / border-box js设置对应的盒模型的宽和高 123456dom.style.width //只能获取到内联属性 window.getComputedStyle(dom).height; //所有属性都可以取到document.getElementById().getBoundingClientRect().height; //相对浏览器窗口的属性，还可以取到top，left 2. CSS选择符有哪些？哪些属性可以继承？123456789 1.id选择器（ # myid）2.类选择器（.myclassname）3.标签选择器（div, h1, p）4.相邻选择器（h1 + p） //紧接在另一个元素后的元素，具有同一父元素5.子选择器（ul &gt; li） //只是子代6.后代选择器（li a）//全部后代7.通配符选择器（ * ）8.属性选择器（a[rel = &quot;external&quot;]）9.伪类选择器（a:hover, li:nth-child） 12可继承的样式： font-size font-family color, UL LI DL DD DT;不可继承的样式：border padding margin width height ; 3. CSS优先级算法如何计算？123456优先级就近原则，同权重情况下样式定义最近者为准;优先级为: 同权重: 内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）。 !important &gt; id &gt; class &gt; tag important 比 内联优先级高 http://blog.csdn.net/taotao6039/article/details/32137819 http://www.haorooms.com/post/css3_nth-child http://www.haorooms.com/post/css_wl_wys 4. 伪类和伪元素的区别伪类和伪元素是用来修饰不在文档树中的部分，比如，一句话中的第一个字母，或者是列表中的第一个元素。 伪类一开始单单只是用来表示一些元素的动态状态，典型的就是链接的各个状态(LVHA)。随后CSS2标准扩展了其概念范围，使其成为了所有逻辑上存在但在文档树中却无须标识的“幽灵”分类。 伪元素则代表了某个元素的子元素，这个子元素虽然在逻辑上存在，但却并不实际存在于文档树中。 CSS3中的标准是伪类使用单冒号“:” 而伪元素使用双冒号“::”（避免混淆） 但是在此之前无论是伪类还是伪元素都使用单冒号“:”所以为了保证兼容伪元素两种使用方法都是可以的但是低版本IE有双冒号兼容问 5. CSS3新增伪类有那些？12345p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。 6.百分比问题百分数是相对于父元素的width计算，不管是margin-top/margin-bottom还是margin-left/margin-right。（padding同理） translate 的百分比是根据自身宽高计算的。 7.position文档流其实就 是文档的输出顺序，也就是我们通常看到的由左到右、由上而下的输出形式，在网页中每个元素都是按照这个顺序进行排序和显示的，而float和 position两个属性可以将元素从文档流脱离出来显示。 7.1、static默认值默认值就是让元素继续按照文档流显示，不作出任何改变。 此时设置 top left 是无效的。 但是设置margin值是可以生效的，这会改变元素在文档流中的位置。 12345678910111213141516div&#123; height: 100px; width: 100px; opacity: 0.8;&#125;.it1&#123; background-color: cadetblue;&#125;.it2&#123; background-color: rebeccapurple; margin-bottom: -20px;&#125;.it3&#123; background-color: red;&#125; 7.2 relative相对定位一个最大特点是：自己通过定位跑开了还占用着原来的位置本身位置变化了，而元素最初所占的物理空间依然还是存在，另外一点元素相对定位后并没有影响其他相邻的元素。 此时设置 top , left 是让其在其应该在文档流中的位置做出移动： 12345678910111213.it1 &#123; background-color: cadetblue;&#125;.it2 &#123; background-color: rebeccapurple; position: relative; bottom: -20px;&#125;.it3 &#123; background-color: red;&#125; 7.3 absolute绝对定位的元素相对于最近的已定位(非static)父元素，如果元素没有已定位的父元素，那么它的位置相对于html。窗口滚动会随之滚动。 12345678910111213141516171819202122232425 .container&#123; height: 300px; width: 300px; background-color: powderblue; position: relative; &#125; .box&#123; height: 150px; width: 150px; background-color: palegoldenrod; /* position: relative; */ &#125; .content&#123; position: absolute; background-color: orangered; right: 10px; &#125; &lt;div class=\"container\"&gt; &lt;div class=\"box\"&gt; &lt;span class=\"content\"&gt; 哈哈哈 &lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 7.3.1 absolute和float的区别 两者都会使元素脱离文档流，但是float是半脱离，还会占有一席之地。 对比默认的文档流： 7.4 fixedfixed定位是指元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会滚动，且fixed定位使元素的位置与文档流无关，因此不占据空间，且它会和其他元素发生重叠。值得注意的是：fixed定位在IE7和IE8下需要描述！DOCTYPE才能支持。 7.5 sticky设置了sticky的元素，在屏幕范围（viewport）时该元素的位置并不受到定位影响（设置是top、left等属性无效），当该元素的位置将要移出偏移范围时，定位又会变成fixed，根据设置的left、top等属性成固定位置的效果。 1234nav&#123; position:sticky; top:10px; /* 阈值 */&#125; 8.如何居中div12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879* 水平居中：给div设置一个宽度，然后添加margin:0 auto属性 div&#123; width:200px; margin:0 auto; &#125;* 让绝对定位的div居中 div &#123; position: absolute; width: 300px; height: 300px; margin: auto; top: 0; left: 0; bottom: 0; right: 0; background-color: pink; /* 方便看效果 */ &#125;* 水平垂直居中一 确定容器的宽高 宽500 高 300 的层 设置层的外边距 div &#123; position: relative; /* 相对定位或绝对定位均可 */ width:500px; height:300px; top: 50%; left: 50%; margin: -150px 0 0 -250px; /* 外边距为自身宽高的一半 */ background-color: pink; /* 方便看效果 */ &#125;* 水平垂直居中二 未知容器的宽高，利用 `transform` 属性 div &#123; position: absolute; /* 相对定位或绝对定位均可 */ width:500px; height:300px; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: pink; /* 方便看效果 */ &#125;* 水平垂直居中三 利用 flex 布局 实际使用时应考虑兼容性 .container &#123; display: flex; align-items: center; /* 垂直居中 */ justify-content: center; /* 水平居中 */ &#125; .container div &#123; width: 100px; height: 100px; background-color: pink; /* 方便看效果 */ &#125;* 水平垂直居中四 .container &#123; display: flex; &#125; .container div &#123; width: 100px; height: 100px; background-color: pink; /* 方便看效果 */ margin:auto; &#125; 9. em 和 rem两者都是基于一个相对值来做缩放的 em:基于body的font-size rem:基于父元素的字体大小 10.BFCBFC 边距重叠解决方案边距重叠：同时设置 margin-top 和 margin-bottom 取最大值。 BFC基本概念：块级格式化上下文 具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。 通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。 BFC原理： 在BFC垂直方向的边距重叠 BFC的区域不会与浮动BOX重叠 BFC是独立容器，外面的元素不会影响里面的元素，里面的元素也不会影响外面的元素。 计算BFC高度浮动元素也会计算 如何创建BFC： body 根元素 float值不为none position值不为static或者不为relative display table ，inline-block，flex overflow 不为visible （auto hidden） BFC实际应用1.避免外边距重叠123456789101112&lt;head&gt;div&#123; width: 100px; height: 100px; background: lightblue; margin: 100px;&#125;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt; 从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 div 的下边距和第二个 div 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。 如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。 123456789101112131415&lt;div class=\"container\"&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;div class=\"container\"&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;.container &#123; overflow: hidden;&#125;p &#123; width: 100px; height: 100px; background: lightblue; margin: 100px;&#125; 这时候，两个盒子边距就变成了 200px 2.BFC 可以包含浮动的元素（清除浮动）我们都知道，浮动的元素会脱离普通文档流，来看下下面一个例子123&lt;div style=\"border: 1px solid #000;\"&gt; &lt;div style=\"width: 100px;height: 100px;background: #eee;float: left;\"&gt;&lt;/div&gt;&lt;/div&gt; 由于容器内元素浮动，脱离了文档流，所以容器只剩下 2px 的边距高度。如果使触发容器的 BFC，那么容器将会包裹着浮动元素。123&lt;div style=\"border: 1px solid #000;overflow: hidden\"&gt; &lt;div style=\"width: 100px;height: 100px;background: #eee;float: left;\"&gt;&lt;/div&gt;&lt;/div&gt; 3.BFC 可以阻止元素被浮动元素覆盖先来看一个文字环绕效果：123&lt;div style=\"height: 100px;width: 100px;float: left;background: lightblue\"&gt;我是一个左浮动的元素&lt;/div&gt;&lt;div style=\"width: 200px; height: 200px;background: #eee\"&gt;我是一个没有设置浮动, 也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;&lt;/div&gt; 这时候其实第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖) 如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 overflow: hidden，就会变成： 这个方法可以用来实现两列自适应布局，效果不错，这时候左边的宽度固定，右边的内容自适应宽度(去掉上面右边内容的宽度)。 浮动元素的块状兄弟元素会无视浮动元素的位置，尽量占满一整行，这样该兄弟元素就会被浮动元素覆盖。 https://segmentfault.com/a/1190000004424442 viewport12345678&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\" /&gt;// width 设置viewport宽度，为一个正整数，或字符串‘device-width’// device-width 设备宽度// height 设置viewport高度，一般设置了宽度，会自动解析出高度，可以不用设置// initial-scale 默认缩放比例（初始缩放比例），为一个数字，可以带小数// minimum-scale 允许用户最小缩放比例，为一个数字，可以带小数// maximum-scale 允许用户最大缩放比例，为一个数字，可以带小数// user-scalable 是否允许手动缩放","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://www.lisq.xyz/tags/css/"},{"name":"面试　","slug":"面试","permalink":"https://www.lisq.xyz/tags/面试/"}]},{"title":"es6学习记录","slug":"es6学习记录","date":"2019-01-01T14:54:38.000Z","updated":"2019-01-01T14:57:21.884Z","comments":true,"path":"2019/01/01/es6学习记录/","link":"","permalink":"https://www.lisq.xyz/2019/01/01/es6学习记录/","excerpt":"","text":"1.let 和 const1.1 let在JS函数中的var声明，其作用域是函数体的全部。 问题1： 12345for(var i=0;i&lt;10;i++)&#123; var a = 'a';&#125;console.log(a); 明明已经跳出 for 循环了，却还可以访问到 for 循环内定义的变量 a ，甚至连 i 都可以被放访问到。 问题2 12345for (var i = 0; i &lt; 3; i++) &#123; setTimeout(function () &#123; console.log(i) &#125;, 1000); &#125; 定时器是异步执行，浏览器在遇到定时器时会先把他们存在一个定时器队列中，待所有同步代码执行完毕后再执行定时器，这时定时器访问到的i早已是3. let的作用： let声明的变量拥有块级作用域。即在for循环或if中用let定义变量，在外面是访问不到的。 形如for (let x…)的循环在每次迭代时都为x创建新的绑定。其实还可以按上面来理解，let在局部作用域有效，每次循环的i其实都是一个新的值，在内存中存储了多次。 let声明的全局变量不是全局对象的属性。这就意味着，你不可以通过window.变量名的方式访问这些变量。它们只存在于一个不可见的块的作用域中，这个块理论上是Web页面中运行的所有JS代码的外层块。 用let重定义变量会抛出一个语法错误（SyntaxError）。这个很好理解，用代码说话.12let a = 'a';let a = 'b'; 上述写法是不允许的，浏览器会报错，因为重复定义了。 let不存在变量提升。一定要先定义后使用 12console.log(i);let i = 1; 1.2 const用于声明常量 const 变量必须在定义时赋值而且不能发生改变。下面的写法都是错误的。 12345678910//只声明变量不赋值const a//重复声明变量const a = 'a';const a = 'b';//给变量重新赋值const a = 'a';a = 'b' 2. 面向对象1234567class Animal&#123; constructor ()&#123; this.name = '小李' &#125;&#125;var a = new Animal(); 3.箭头函数和普通函数相比，箭头函数主要就是以下两个方面的特点 不绑定this，arguments 更简化的代码语法 箭头函数的this是在定义时就确定好的，而普通函数由运行时确定。 123456789const Person = &#123; 'name': 'little bear', 'age': 18, 'sayHello': function () &#123; setInterval(function () &#123; console.log('我叫' + this.name + '我今年' + this.age + '岁!') &#125;, 1000) &#125;Person.sayHello() 当Person.sayHello()去执行setInterval的时候，是在全局作用下执行的所有setInterval回调函数的this就为全局对象。es3-5中的函数this的值和调用这个函数的上下文有关。 123456789const Person = &#123; 'name': 'little bear', 'age': 18, 'sayHello': () =&gt; &#123; setInterval(() =&gt; &#123; console.log('我叫' + this.name + '我今年' + this.age + '岁!') &#125;, 1000) &#125;Person.sayHello() 因为我把方法写在了对象里，而对象的括号是不能封闭作用域的。所以此时的this还是指向全局对象。所以，通过以上的错误可以提醒我们，最好不要用箭头函数作为对象的方法。 12345678function Person () &#123; this.name = 'little bear', this.age = 18 setInterval(() =&gt; &#123; console.log('我叫' + this.name + '我今年' + this.age + '岁')&#125;,1000)&#125;let p = new Person() 我们可以看到，箭头函数使用了定义时上下文的this，且与在哪里调用没有关系。 箭头函数还有一个比较有特点的地方就是其不绑定arguments,即如果你在箭头函数中使用arguments参数不能得到想要的内容。1234let arrowfunc = () =&gt; console.log(arguments.length)arrowfunc()//output arguments is not defined 所以在箭头函数中我们是不能直接使用arguments对象的，但是如果我们又想获得函数的参数怎么办呢？我们可以使用剩余参数来取代arguments剩余参数详情1234let arrowfunc = (...theArgs) =&gt; console.log(theArgs.length)arrowfunc(1,2)//output2 4.解构赋值解构赋值语法是一个 Javascript 表达式，这使得可以将值从数组或属性从对象提取到不同的变量中。1234567891011121314151617181920var a, b, rest;[a, b] = [10, 20];console.log(a); // 10console.log(b); // 20[a, b, ...rest] = [10, 20, 30, 40, 50];console.log(a); // 10console.log(b); // 20console.log(rest); // [30, 40, 50](&#123; a, b &#125; = &#123; a: 10, b: 20 &#125;);console.log(a); // 10console.log(b); // 20// Stage 3 proposal(&#123;a, b, ...rest&#125; = &#123;a: 10, b: 20, c: 30, d: 40&#125;);console.log(a); // 10console.log(b); // 20console.log(rest); //&#123;c: 30, d: 40&#125;","categories":[],"tags":[]},{"title":"前端安全性浅析","slug":"前端安全性浅析","date":"2018-12-30T09:06:46.000Z","updated":"2018-12-30T09:12:19.058Z","comments":true,"path":"2018/12/30/前端安全性浅析/","link":"","permalink":"https://www.lisq.xyz/2018/12/30/前端安全性浅析/","excerpt":"","text":"XSS跨站脚本攻击在新浪博客写一篇文章，同时偷偷插入一段 script 攻击代码中，获取cookie，发送给自己的服务器 发布博客，有人查看博客内容 会把查看者的cookie发送到攻击者的服务器 攻击原理： 能注入恶意的HTML/JavaScript代码到用户浏览的网页上，从而达到Cookie资料窃取、会话劫持、钓鱼欺骗等攻击。 Web浏览器本身的设计不安全。浏览器能解析和执行JS等代码，但是不会判断该数据和程序代码是否恶意。 防御措施： 让注入的js不可执行。 1.输入检查 XSS Filter 对输入内容做格式检查，类似“白名单”，可以让一些基于特殊字符的攻击失效。在客户端JS和服务器端代码中实现相同的输入检查（服务器端必须有）。 2.输出检查 在变量输出到html页面时，可以使用编码或转义的方式来防御XSS攻击 HtmlEncode：将字符转成HTMLEntities，对应的标准是ISO-8859-1。1&amp; --&gt; &amp;amp; &lt; --&gt; &amp;lt; &gt; --&gt;&amp;gt; \" --&gt; &amp;quot; ' --&gt; &amp;#x27; / --&gt; &amp;#x2F; JS中可以使用JavascriptEncode。需要对“\\”对特殊字符转义，输出的变量的必须在引号内部。 3.请求头设置 set-cookie 设置 httpOnly 属性可以禁止JavaScript读取cookie CSRF 跨站请求攻击攻击原理： 1.在网站A中登录过，存在漏洞（只用cookie验证） 2.在网站B引诱点击 传统使用cookie中存储sessionid，但是在任何一个站点都可以获取到你的sessionid并发起携带他的请求，这就是CSRF的原理。 防御措施： 1.token验证 token存储在用户session中，每个用户不同。 不将token存储在cookie中而是放在表单隐藏域中或者localstorage中，每次请求用代码添加，就能防止钓鱼。 2.Referer验证（判断站点的来源，比如不是订单页面不让提交订单） 在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址 3.隐藏令牌 （和token类似，比较隐蔽，比如放在请求头中）","categories":[],"tags":[{"name":"安全性","slug":"安全性","permalink":"https://www.lisq.xyz/tags/安全性/"}]},{"title":"前端性能优化总结","slug":"前端性能优化总结","date":"2018-12-28T14:33:19.000Z","updated":"2018-12-29T03:26:54.837Z","comments":true,"path":"2018/12/28/前端性能优化总结/","link":"","permalink":"https://www.lisq.xyz/2018/12/28/前端性能优化总结/","excerpt":"","text":"1.原则多使用内存，缓存或者其他方法 减少CPU计算，减少网络请求 减少IO操作（硬盘读写） 2.加载资源优化静态资源的合并和压缩。 静态资源缓存（浏览器缓存策略）。 使用CDN让静态资源加载更快。 3. 渲染优化CSS放head中，JS放body后 图片懒加载 减少DOM操作，对DOM操作做缓存 减少DOM操作，多个操作尽量合并在一起执行 事件节流 尽早执行操作 DOMContentLoaded 4. 示例4.1 资源合并1a.js b.js c.js --- abc.js 4.2 缓存通过连接名称控制缓存 1&lt;script src=\"abc_1.js\" &gt;&lt;/script&gt; 只有改变内容的时候，链接名称才会改变。 4.3 懒加载12345&lt;img src=\"preview.png\" realsrc=\"abc.png\" id=\"img1\" /&gt;&lt;script&gt; var i = document.getElementById('img1'); i.src = i.getAttribute('realsrc');&lt;/script&gt; 4.4 缓存dom查询12345678910//没有缓存domfor (let i = 0; i &lt; document.getElementsByTagName('p').length; i++) &#123;&#125;//缓存domvar p = document.getElementsByTagName('p');for (let i = 0; i &lt; p.length; i++) &#123;&#125; 4.5 合并dom插入123456789var listNode = document.getElementById('list');var flag = document.createDocumentFragment();var li;for (let i = 0; i &lt; 10; i++) &#123; li = document.createElement('li'); li.innerHTML = i; flag.appendChild(li);&#125;listNode.appendChild(flag); 10次dom插入 —&gt; 1次dom插入 4.6 事件节流监听文字改变事件，无操作100毫秒后执行操作，不用每次触发。12345678910var textarea = document.getElementById('ta');var timeoutId;textarea.addEventListener('keyup',function()&#123; if(i)&#123; clearTimeout(i); &#125; timeoutId = setTimeout(() =&gt; &#123; //操作 &#125;, 100);&#125;); 事件节流主要用于触发频率较高的事件，设定一个缓冲触发事件。 补充异步加载非核心代码异步加载 – 异步加载的方式 – 区别 1.动态脚本加载 用js创建 2.defer 3.async 123456&lt;script src=\"script.js\"&gt;&lt;/script&gt;没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。&lt;script async src=\"script.js\"&gt;&lt;/script&gt;有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。&lt;script defer src=\"myscript.js\"&gt;&lt;/script&gt;有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。 关于 defer，我们还要记住的是它是按照加载顺序执行脚本的 标记为async的脚本并不保证按照指定它们的先后顺序执行。对它来说脚本的加载和执行是紧紧挨着的，所以不管你声明的顺序如何，只要它加载完了就会立刻执行。 浏览器缓存总结的非常好 浏览器缓存 – 缓存的分类 – 缓存的原理 缓存就是html文件在本地存在的副本， 强缓存 发现有缓存直接用。 12345Expires: 绝对时间，判断客户端日期是否超过这个时间Cache-Control：相对时间，判断访问间隔是否大于3600秒//在设定时间之前不会和服务端进行通信了//如果两个都下发以后者为准 协商缓存 询问服务器缓存是否可以用，在进行判断是否用。 Last-Modified/If-Modified-Since 123456789第一次请求，respone的header加上Last-Modified（最后修改时间）再次请求，在request的header上加上If-Modified-Since 和服务端的最后修改时间对比，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。浏览器收到304的响应后，就会从缓存中加载资源如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified的Header在重新加载的时候会被更新 Etag/If-None-Match 这两个值是由服务器生成的每个资源的唯一标识字符串，只要资源有变化就这个值就会改变；其判断过程与Last-Modified/If-Modified-Since类似，他可以精确到秒的更高级别。 DNS预解析12&lt;meta http-equiv=\"x-dns-prefetch-control\" content=\"on\"&gt;&lt;link rel=\"dns-prefetch\" href=\"//www.zhix.net\"&gt; 在一些浏览器的a标签是默认打开dns预解析的，在https协议下dns预解析是关闭的，加入mate后会打开。","categories":[],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://www.lisq.xyz/tags/性能优化/"}]},{"title":"Web运行环境总结","slug":"Web运行环境","date":"2018-12-22T14:38:50.000Z","updated":"2018-12-22T14:42:14.822Z","comments":true,"path":"2018/12/22/Web运行环境/","link":"","permalink":"https://www.lisq.xyz/2018/12/22/Web运行环境/","excerpt":"","text":"1. 页面加载过程1.1 加载一个资源的过程在浏览器地址栏输入URL 浏览器查看缓存(强缓存) 浏览器解析URL获取协议，主机，端口，path 浏览器组装一个HTTP（GET）请求报文 浏览器根据DNS服务器得要域名的IP地址 打开一个socket与目标IP地址，端口建立TCP链接 向这个IP的机器发送http/https请求 服务器收到处理并返回http请求 判断协商缓存 服务器将响应报文通过TCP连接发送回浏览器 关闭TCP连接 浏览器检查响应状态吗做出不同处理 如果资源可缓存，进行缓存 浏览器得到返回的内容 1.2 浏览器渲染页面的过程根据HTML结构生成DOM Tree 根据CSS生成CSSOM 将DOM和CSSOM整合成RenderTree（渲染树，比DOM树多了样式） 根据RenderTree开始渲染和展示 HTML解析器遇到没有async和defer的script时，会执行并阻塞渲染 （js可能会改变dom结构） 浏览器在Document对象上触发DOMContentLoaded事件 显示页面 图片加载完毕 调用onload 1.3 为什么把css放在head中在html渲染之前渲染css 如果css放在html元素后面，会先按没有css的情况渲染html，然后加载到css后再重新渲染html元素，这样会损耗性能。 1.4 为什么要把js放在body的最下面1.不会阻塞body中元素的渲染，能让页面更快出来 2.script能拿到所有的标签 1.5 图片图片是异步请求，不会影响dom树的渲染 1.6 load,DOMContentLoaded1234567window.addEventListener('load',function()&#123; //页面资源全部加载完成，包括图片视频&#125;);document.addEventListener('DOMContentLoaded',function()&#123; //DOM 渲染完即可执行，图片视频还没有加载完&#125;); DOMContentLoaded : dom结构化完成以后 load：dom 结构化以及静态资源全部加载完毕以后 $(document).ready 底层是DOMContentLoaded函数 $(window).load 底层是load函数 $(function () {}) 是$(document).ready的缩写 12345678910111213141516171819202122232425262728293031var show = console.log.bind(console); show('观察脚本加载的顺序') document.addEventListener(\"DOMContentLoaded\", function () &#123; show('DOMContentLoaded回调') &#125;, false); window.addEventListener(\"load\", function () &#123; show('load事件回调') &#125;, false); show('脚本解析一'); $(document).ready(function () &#123; show('$(document).ready') &#125;) // 测试加载 $(function () &#123; show('脚本解析二'); &#125;) $(window).load(function () &#123; show('$(document).load'); &#125;); show('脚本解析三'); 1.7 重排ReflowDOM结构中的元素都有自己的盒子，这些都需要浏览器根据各种样式来计算并根据计算结果来将元素放到他们该出现的位置，称为Reflow。 触发reflow的条件： 1.增删改dom节点 2.移动dom位置或者有动画 3.修改css样式 4.resize窗口或者滚动（移动端没有该问题） 1.8 重绘Repaint页面要呈现的内容绘制在屏幕上。 DOM改动，CSS改动（判断页面呈现的内容有没有发生变化） 1.9 避免relow和repaint1.尽量用class来修改样式 如果要修改多个样式，每个样式修改时都会出发reflow，可以将这些样式保存在一个class中，每次修改只reflow一次。 将元素的position设置为absolute和fixed可以使元素从DOM树结构中脱离出来独立的存在，而浏览器在需要渲染时只需要渲染该元素以及位于该元素下方的元素，从而在某种程度上缩短浏览器渲染时间，这在当今越来越多的Javascript动画方面尤其值得考虑。 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://www.lisq.xyz/tags/css/"},{"name":"基础","slug":"基础","permalink":"https://www.lisq.xyz/tags/基础/"},{"name":"浏览器","slug":"浏览器","permalink":"https://www.lisq.xyz/tags/浏览器/"}]},{"title":"指令控制 windows 电源选项","slug":"指令控制-windows-电源选项","date":"2018-12-17T10:07:12.000Z","updated":"2018-12-17T10:23:47.416Z","comments":true,"path":"2018/12/17/指令控制-windows-电源选项/","link":"","permalink":"https://www.lisq.xyz/2018/12/17/指令控制-windows-电源选项/","excerpt":"","text":"1.powercfg命令。使用powercfg.exe控制电源计划（也称为电源使用方案）。 2.ac和dc一般电源有两种供电模式： ac代表交流电源 dc代表直流电源 一般情况下ac就是直接接通电源，dc是使用电池供电。 一般电源命令都需要分别设置在ac和dc下的模式。 3.电源选项的唯一标识每个电源选项都有一个唯一的guid标识，我们可以使用某些命令通过这个唯一标识来设定这个电源选项。 例如官方文档中的电源计划： 如图：电源计划 节电，平衡，高性能分别对应了一个guid。 我们可以通过查阅windows文档或者使用 1powercfg /query 命令来查询每个选项对应的guid。 4.设置电源计划1powercfg -setactive guid 可以通过-setactive来设置当前电源计划。 例如下面的代码将电源设置为平衡模式 1powercfg -setactive 381b4222-f694-41f0-9685-ff5bb260df2e 5.修改电源计划中的电源选项直接查看控制面板中的电源选项可以看到下面的界面 我们可以通过下面的命令来修改1powercfg -change value 后面的value有如下几个选项 12345678monitor-timeout-ac &lt;分钟&gt;monitor-timeout-dc &lt;分钟&gt;disk-timeout-ac &lt;分钟&gt;disk-timeout-dc &lt;分钟&gt;standby-timeout-ac &lt;分钟&gt;standby-timeout-dc &lt;分钟&gt;hibernate-timeout-ac &lt;分钟&gt;hibernate-timeout-dc &lt;分钟&gt; monitor:屏幕disk:磁盘standby:待机hibernate:休眠 实例： 1powercfg /change monitor-timeout-ac 5 表示：在接通电源模式下设置屏幕5分钟后关闭。 1powercfg /change monitor-hibernate-dc 0 表示：在不接通电源模式下永不休眠 6.高级选项还有一些其他选项，例如按下电源按钮，睡眠按钮，关闭盖子等发生的操作。 可以使用如下命令设置： 123powercfg /setacvalueindex scheme_GUID sub_GUID setting_GUID setting_indexpowercfg /setdcvalueindex scheme_GUID sub_GUID setting_GUID setting_index scheme_GUID : 电源计划guid，可以通过powercfg /list查询 sub_GUID：子组guid，可以解释成在众多的电源选项上又分的一层组，可以通过过powercfg /query查询 setting_GUID：选项guid，具体的电源选项。 setting_index：具体设置的索引，如下图： 不采取任何操作，睡眠，休眠，关机 例如： 1powercfg -SetAcValueIndex 381b4222-f694-41f0-9685-ff5bb260df2e 4f971e89-eebd-4455-a8de-9e59040e7347 5ca83367-6e45-459f-a27b-476b1d01c936 0 表示：设置接通电源的情况下，电源关盖后不采取任何操作。 1powercfg -SetDcValueIndex 381b4222-f694-41f0-9685-ff5bb260df2e 4f971e89-eebd-4455-a8de-9e59040e7347 7648efa3-dd9c-4e3e-b566-50f929386280 1 表示：设置未接通电源的情况下，按下电源键使电脑进入睡眠。 7.总结有了这些操作，我们就可以使用某些语言比如node，来批处理windows电源选项了。 更详细的选项可以查询windows官方文档： https://docs.microsoft.com/en-us/windows-hardware/design/device-experiences/powercfg-command-line-options#option_getactivescheme","categories":[],"tags":[]},{"title":"TCP总结","slug":"TCP总结","date":"2018-12-08T08:11:30.000Z","updated":"2018-12-08T08:11:53.985Z","comments":true,"path":"2018/12/08/TCP总结/","link":"","permalink":"https://www.lisq.xyz/2018/12/08/TCP总结/","excerpt":"","text":"网络模型 TCP/IP 是因特网的通信协议。 通信协议是对计算机必须遵守的规则的描述，只有遵守这些规则，计算机之间才能进行通信。 应用层应用层是应用程序间沟通的层文件传输协议（FTP）和超文本传送协议(HTTP) 传输层使源端和目的端机器上的对等实体可以进行会话。在这一层定义了两个端到端的协议：传输控制协议(TCP)和用户数据报协议(UDP)。TCP是面向连接的协议，它提供可靠的报文传输和对上层应用的连接服务。UDP是面向无连接的不可靠传输的协议。 socket 套接字, 是基于TCP UDP 协议的 一种通信机制, 它本身就是对TCP 和UDp 协议应用的一种管理用 Socket 能够实现网络上的不同主机之间或同一主机的不同对象之间的数据通信。 TCP和UDP的区别TCP是面向连接的，建立连接需要经历三次握手，保证数据正确性和数据顺序 UDP是非连接的协议，传送数据受生成速度，传输带宽等限制，可能造成丢包 UDP一台服务端可以同时向多个客户端传输信息 TCP报头体积更大，对系统资源要求更多 三次握手 TCP三次握手涉及到TCP首部的一些知识，所有有必要先介绍下TCP首部的相关知识。如果嫌TCP首部内容太多，那么只要看下ACK和SYN这两个标志比特就行了（因为TCP三次握手过程主要用到这两个标志比特）。 序号(seq): 用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节在数据流中的序号。主要用来解决网络报乱序的问题。(即发送请求的唯一标识) 确认号(ack): 32位确认序列号包含发送确认的一端所期望收到的下一个序号，因此，确认序号应当是上次已成功收到数据字节序号加1。不过，只有当标志位中的ACK标志（下面介绍）为1时该确认序列号的字段才有效。主要用来解决不丢包的问题。（即响应请求的唯一标识） 标志比特(TCP Flags): TCP首部中有6个标志比特，它们中的多个可同时被设置为1，主要是用于操控TCP的状态机的，依次为URG，ACK，PSH，RST，SYN，FIN。每个标志位的意思如下: SYN: 表示同步序号，用来建立连接。SYN标志位和ACK标志位搭配使用，当连接请求的时候，SYN=1，ACK=0。连接被响应的时候，SYN=1，ACK=1。 ACK: 此标志表示应答域有效，就是说前面所说的TCP应答号将会包含在TCP数据包中。有两个取值: 0和1，为1的时候表示应答域有效，反之为0。 为什么要三次握手为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。 A : 你好我是A，你听得到我在说话吗 B : 听到了，我是B，你听到我在说话吗 A : 嗯，听到了 建立连接，开始聊天！ 四次挥手 第一次挥手: 主动关闭方(可以使客户端，也可以是服务器端，这里标记为：A)，将FIN置为1，ACK置为1，Seq设置为X为上一次对方传送过来的Ack值，Ack设置为Y为上一次对方传过来的Seq值+1。设置好以上值后，将数据发送至被动关闭方(这里标记为：B)。然后A进入FIN_WAIT_1状态。 第二次挥手：B收到了A发送的FIN报文段，向A回复，将ACK置为1，Ack设置为X第一次挥手中的Seq值+1，Seq设置为Y第一次挥手中的Ack值。然后B进入CLOSE_WAIT状态，A收到B的回复后，进入FIN_WAIT_2状态。 第三次挥手：B再次向A发送报文，将FIN置为1，ACK置为1，Ack设置为X+1第二次挥手中的Ack(Acknowledgment Number)值，Seq设置为Y第二次挥手中的Seq值。然后B进入LAST_ACK状态，A收到B的报文后，进入TIME_WAIT状态。 第四次挥手：A收到B发送的FIN报文段，像B回复，将ACK置为1，Ack设置为Y第三次挥手中的Seq值+1，Seq设置为X+1第三次挥手中的Ack值。然后A进入TIME_WAIT状态，B在收到报文后进入CLOSED状态，A在发送完报文等待了2MSL时间后进入CLOSED状态。 为什么要四次挥手我在《TCP三次握手简介》得出过这样一个结论：三次握手的本质是：将“四次握手”中的第二次、第三次握手合为一次，因为“四次握手”中的第二次、第三次握手都是由B向A传递报文，而且这两次发送报文的目的允许这两次报文合并为一次。那么，TCP四次挥手中的第二次、第三次挥手，能否也能合为一次呢？ 答案是否定的。将TCP四次挥手中的第二次、第三次挥手，合为一次。也就是将CLOSE_WAIT状态的停留时间变为0。然而，B之所以存在CLOSE_WAIT状态，是因为B可能还存在着需要发送给A但是未发送的数据，如果存在着这些数据，那么这个状态的时间，就是用来发送这些数据的，所以，TCP四次挥手中的第二次、第三次挥手无法合并为一次。所以，也就无法实现“TCP三次挥手”。","categories":[],"tags":[{"name":"网络","slug":"网络","permalink":"https://www.lisq.xyz/tags/网络/"},{"name":"协议","slug":"协议","permalink":"https://www.lisq.xyz/tags/协议/"},{"name":"tcp","slug":"tcp","permalink":"https://www.lisq.xyz/tags/tcp/"}]},{"title":"http总结","slug":"http总结","date":"2018-12-07T06:19:06.000Z","updated":"2018-12-07T06:19:50.859Z","comments":true,"path":"2018/12/07/http总结/","link":"","permalink":"https://www.lisq.xyz/2018/12/07/http总结/","excerpt":"","text":"http协议的主要特点1、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、PUT、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 2、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 3.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 4.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 http报文的组成部分HTTP之请求消息Request客户端发送一个HTTP请求到服务器的请求消息包括以下格式： 请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。 Get请求例子，使用Charles抓取的request： 1234567GET /562f25980001b1b106000338.jpg HTTP/1.1Host img.mukewang.comUser-Agent Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.106 Safari/537.36Accept image/webp,image/*,*/*;q=0.8Referer http://www.imooc.com/Accept-Encoding gzip, deflate, sdchAccept-Language zh-CN,zh;q=0.8 第一部分：请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本. GET说明请求类型为GET,[/562f25980001b1b106000338.jpg]为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。 第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息 从第二行起为请求头部，HOST将指出请求的目的地.User-Agent,服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等 第三部分：空行，请求头部后面的空行是必须的 即使第四部分的请求数据为空，也必须有空行。 第四部分：请求数据也叫主体，可以添加任意的其他数据。 这个例子的请求数据为空。 POST请求例子： 12345678POST / HTTP1.1Host:www.wrox.comUser-Agent:Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727; .NET CLR 3.0.04506.648; .NET CLR 3.5.21022)Content-Type:application/x-www-form-urlencodedContent-Length:40Connection: Keep-Alivename=Professional%20Ajax&amp;publisher=Wiley 第一部分：请求行，第一行明了是post请求，以及http1.1版本。 第二部分：请求头部，第二行至第六行。 第三部分：空行，第七行的空行。 第四部分：请求数据，第八行。 HTTP之响应消息Response一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。 HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。 例子 12345678910HTTP/1.1 200 OKDate: Fri, 22 May 2009 06:07:21 GMTContent-Type: text/html; charset=UTF-8&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;!--body goes here--&gt; &lt;/body&gt;&lt;/html&gt; 第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。 第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok） 第二部分：消息报头，用来说明客户端要使用的一些附加信息 第二行和第三行为消息报头，Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8 第三部分：空行，消息报头后面的空行是必须的 第四部分：响应正文，服务器返回给客户端的文本信息。 空行后面的html部分为响应正文。 GET和POST的区别1.请求参数 GET提交，请求的数据会附在URL之后。 POST提交：把提交的数据放置在是HTTP包的包体中。 2.传输数据大小 GET:特定浏览器和服务器对URL长度有限制，例如 IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系 统的支持。 因此对于GET提交时，传输数据就会受到URL长度的 限制。 POST:由于不是通过URL传值，理论上数据不受 限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。 3.安全性 GET请求的参数会暴露在URL中，不能存放敏感信息 GET请求会被浏览器主动缓存，POST要设置 4.取值 GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。 5.回退GET在浏览器回退时是无害的，而post会重新提交 6.收藏GET产生的URL可以被收藏，POST不可以 7.编码GET只接受ASCll编码的参数，而POST不限制 http状态码状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别: 1xx：指示信息–表示请求已接收，继续处理 2xx：成功–表示请求已被成功接收、理解、接受 3xx：重定向–要完成请求必须进行更进一步的操作 4xx：客户端错误–请求有语法错误或请求无法实现 5xx：服务器端错误–服务器未能实现合法的请求 常见状态码： 200 OK //客户端请求成功 206 服务端发送了一个带有range头的请求（设置请求的范围如1-10000字节），服务器完成了他。 301 所请求的页面已经转移到新的url 302 请求页面临时转移 304 服务端告诉浏览器有缓存可以直接使用，不用在服务器中取 400 Bad Request //客户端请求有语法错误，不能被服务器所理解 401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 403 Forbidden //服务器收到请求，但是拒绝提供服务（只允许服务端访问） 404 Not Found //请求资源不存在，eg：输入了错误的URL 500 Internal Server Error //服务器发生不可预期的错误 503 Server Unavailable //服务器当前不能处理客户端的请求（服务器临时过载），一段时间后可能恢复正常 持久链接HTTP协议使用”请求-应答”模式，即非keep-active模式，每个请求应答客户和服务器都要建立一次连接，完成之后即断开连接。 当时用keep-active模式（持久链接），keep-active功能使服务端到客户端的连接持久有效，当出现对服务器的后继请求时，keep-active避免了建立或重新建立连接。（1.1版本支持） 管线化使用持久链接的情况，某个链接类似于下面的情况：1请求1-&gt;响应1-&gt;请求2-&gt;响应2 箭头代表链接一直没有中断 管线化情况：1请求1-&gt;请求2-&gt;响应1-&gt;响应2 将请求打包一次请求，响应打包一次返回。 特点： 浏览器没有默认开启管线化，服务端可能不支持 通过持久连接完成的，必须要求1.1 只有GET请求可以实现管线化，post有所限制 httpshttp和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 HTTPS可以理解为HTTP+TLS,TLS是传输层加密协议 https是在客户端和服务器端通信的过程中加密数据的. 使用 https 可以有效防止别人使用抓包工具获得你的报文的信息，因为 https 在通信的时候是加密的，http 直接抓包就能获得明文信息。而使用 https 获得的是一串乱码。 1234567891011大概过程，（实际过程更复杂）： 1. 你访问HTTPS网站，网站把公钥给你。 2. 你验证公钥，然后生成一个串随机AES_128密码（假如是用AES加密），并把这个密码用刚才那个公钥加密，发给服务端。 3. 服务端用私钥解密你的发送的数据，得到你随机生成的AES_128密码，并把网页内容全部用AES_128加密器起来，发会给你。 4. 浏览器用刚刚的AES_128密码解密 服务器返回的数据，得到你可读的内容。 5. 之后你发出的请求数据，也是用AES_128密码来加密。 版本迭代HTTP/1.1 HTTP协议的第三个版本是HTTP/1.1，是目前使用最广泛的协议版本。HTTP/1.1是目前主流的HTTP协议版本，相对于HTTP/1.0新增了以下内容： HTTP 1.1支持长连接和请求的流水线）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection：keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。 多了一些缓存处理字段 HTTP/1.1在1.0的基础上加入了一些cache的新特性 HTTP/2.0 头部压缩 HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。HTTP/2.0 要求通讯双方各自缓存一份首部字段表，从而避免了重复传输。 服务端推送 服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。","categories":[],"tags":[{"name":"网络","slug":"网络","permalink":"https://www.lisq.xyz/tags/网络/"},{"name":"协议","slug":"协议","permalink":"https://www.lisq.xyz/tags/协议/"},{"name":"http","slug":"http","permalink":"https://www.lisq.xyz/tags/http/"}]},{"title":"react中key的正确使用方式","slug":"react中key的正确使用方式","date":"2018-11-26T17:50:45.000Z","updated":"2018-11-26T17:52:20.367Z","comments":true,"path":"2018/11/27/react中key的正确使用方式/","link":"","permalink":"https://www.lisq.xyz/2018/11/27/react中key的正确使用方式/","excerpt":"","text":"在开发react程序时我们经常会遇到这样的警告，然后就会想到：哦！循环子组件忘记加key了～ 出于方便，有时候会不假思索的使用循环的索引作为key，但是这样真的好吗？什么样的值才是key的最佳选择？ 为了弄明白，本文将从三个方面来分析”key”： 1.为什么要使用key 2.使用index做key存在的问题 3.正确的选择key 1.为什么要使用keyreact官方文档是这样描述key的： Keys可以在DOM中的某些元素被增加或删除的时候帮助React识别哪些元素发生了变化。因此你应当给数组中的每一个元素赋予一个确定的标识。 react的diff算法是把key当成唯一id然后比对组件的value来确定是否需要更新的，所以如果没有key，react将不会知道该如何更新组件。 你不传key也能用是因为react检测到子组件没有key后，会默认将数组的索引作为key。 react根据key来决定是销毁重新创建组件还是更新组件，原则是： key相同，组件有所变化，react会只更新组件对应变化的属性。 key不同，组件会销毁之前的组件，将整个组件重新渲染。 2.使用index做key存在的问题2.1 受控组件单纯的展示组件比如span，这些组件是受控组件，意味着他们的值将是我们给定好的。 如果子组件只是受控组件，使用index作为key，可能表面上不会有什么问题，实际上性能会受很大的影响。例如下面的代码： 123456789101112// [&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;]=&gt;&lt;ul&gt; &lt;li key=&quot;0&quot;&gt;张三&lt;/li&gt; &lt;li key=&quot;1&quot;&gt;李四&lt;/li&gt; &lt;li key=&quot;2&quot;&gt;王五&lt;/li&gt;&lt;/ul&gt;// 数组重排 -&gt; [&apos;王五&apos;,&apos;张三&apos;,&apos;李四&apos;] =&gt;&lt;ul&gt; &lt;li key=&quot;0&quot;&gt;王五&lt;/li&gt; &lt;li key=&quot;1&quot;&gt;张三&lt;/li&gt; &lt;li key=&quot;2&quot;&gt;李四&lt;/li&gt;&lt;/ul&gt; 当元素数据源的顺序发生改变时，对应的： key为0，1，2的组件都发生了变化，三个子组件都会被重新渲染。（这里的重新渲染不是销毁，因为key还在） 相反，我们使用唯一id作为key： 123456789101112// [&apos;张三&apos;,&apos;李四&apos;,&apos;王五&apos;]=&gt;&lt;ul&gt; &lt;li key=&quot;000&quot;&gt;张三&lt;/li&gt; &lt;li key=&quot;111&quot;&gt;李四&lt;/li&gt; &lt;li key=&quot;222&quot;&gt;王五&lt;/li&gt;&lt;/ul&gt;// 数组重排 -&gt; [&apos;王五&apos;,&apos;张三&apos;,&apos;李四&apos;] =&gt;&lt;ul&gt; &lt;li key=&quot;222&quot;&gt;王五&lt;/li&gt; &lt;li key=&quot;000&quot;&gt;张三&lt;/li&gt; &lt;li key=&quot;111&quot;&gt;李四&lt;/li&gt;&lt;/ul&gt; 根据上面的更新原则，子组件的值和key均未发生变化，只是顺序发生改变，因此react只是将他们做了移动，并未重新渲染。 2.2 非受控组件像input这样可以由用户任意改变值，不受我们控制的组件，在使用了index作为key时可能会发生问题，看如下的栗子： 子组件： 123456789 render() &#123; return ( &lt;div&gt; &lt;p &gt;值：&#123;this.props.value&#125;&lt;/p&gt; &lt;input /&gt; &lt;/div&gt; ); &#125;&#125; 父组件12345&#123;this.state.data.map((element, index) =&gt; &#123; return &lt;Child value=&#123;element&#125; key=&#123;index&#125; /&gt; &#125;)&#125; 我们在前两个输入框分别输入对应的值： 然后在头部添加一个元素： 很明显，这个结果并不符合我们的预期，我们来分析一下发生了什么： 123456789101112&lt;div key=&quot;0&quot;&gt; &lt;p &gt;值：0&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=&quot;1&quot;&gt; &lt;p &gt;值：1&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=&quot;2&quot;&gt; &lt;p &gt;值：2&lt;/p&gt; &lt;input /&gt;&lt;/div&gt; 变化后： 12345678910111213141516&lt;div key=&quot;0&quot;&gt; &lt;p &gt;值：5&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=&quot;1&quot;&gt; &lt;p &gt;值：0&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=&quot;2&quot;&gt; &lt;p &gt;值：1&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=&quot;3&quot;&gt; &lt;p &gt;值：2&lt;/p&gt; &lt;input /&gt;&lt;/div&gt; 可以发现：key 0，1，2并没有发生改变，根据规则，不会卸载组件，只会更新改变的属性。 react只diff到了p标签内值的变化，而input框中的值并未发生改变，因此不会重新渲染，只更新的p标签的值。 当使用唯一id作为key后： 123456789101112&lt;div key=&quot;000&quot;&gt; &lt;p &gt;值：0&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=&quot;111&quot;&gt; &lt;p &gt;值：1&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=&quot;222&quot;&gt; &lt;p &gt;值：2&lt;/p&gt; &lt;input /&gt;&lt;/div&gt; 变化后： 12345678910111213141516&lt;div key=&quot;555&quot;&gt; &lt;p &gt;值：5&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=&quot;000&quot;&gt; &lt;p &gt;值：0&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=&quot;111&quot;&gt; &lt;p &gt;值：1&lt;/p&gt; &lt;input /&gt;&lt;/div&gt;&lt;div key=&quot;222&quot;&gt; &lt;p &gt;值：2&lt;/p&gt; &lt;input /&gt;&lt;/div&gt; 可以很明显的发现：key为 111，222，333的组件没有发生任何改变，react不会更新他们，只是新插入了子组件555，并改变了其他组件的位置。 3.正确的选择key3.1 纯展示如果组件单纯的用于展示，不会发生其他变更，那么使用index或者其他任何不相同的值作为key是没有任何问题的，因为不会发生diff，就不会用到key。 3.2 推荐使用index的情况并不是任何情况使用index作为key会有缺陷，比如如下情况： 你要分页渲染一个列表，每次点击翻页会重新渲染： 使用唯一id： 123456789101112第一页&lt;ul&gt; &lt;li key=&quot;000&quot;&gt;张三&lt;/li&gt; &lt;li key=&quot;111&quot;&gt;李四&lt;/li&gt; &lt;li key=&quot;222&quot;&gt;王五&lt;/li&gt;&lt;/ul&gt;第二页&lt;ul&gt; &lt;li key=&quot;333&quot;&gt;张三三&lt;/li&gt; &lt;li key=&quot;444&quot;&gt;李四四&lt;/li&gt; &lt;li key=&quot;555&quot;&gt;王五五&lt;/li&gt;&lt;/ul&gt; 翻页后，三条记录的key和组件都发生了改变，因此三个子组件都会被卸载然后重新渲染。 使用index： 123456789101112第一页&lt;ul&gt; &lt;li key=&quot;0&quot;&gt;张三&lt;/li&gt; &lt;li key=&quot;1&quot;&gt;李四&lt;/li&gt; &lt;li key=&quot;2&quot;&gt;王五&lt;/li&gt;&lt;/ul&gt;第二页&lt;ul&gt; &lt;li key=&quot;0&quot;&gt;张三三&lt;/li&gt; &lt;li key=&quot;1&quot;&gt;李四四&lt;/li&gt; &lt;li key=&quot;2&quot;&gt;王五五&lt;/li&gt;&lt;/ul&gt; 翻页后，key不变，子组件值发生改变，组件并不会被卸载，只发生更新。 3.3 子组件可能发生变更/使用了非受控组件大多数情况下，使用唯一id作为子组件的key是不会有任何问题的。 这个id一定要是唯一，并且稳定的，意思是这条记录对应的id一定是独一无二的，并且永远不会发生改变。 不推荐使用math.random或者其他的第三方库来生成唯一值作为key。 因为当数据变更后，相同的数据的key也有可能会发生变化，从而重新渲染，引起不必要的性能浪费。 如果数据源不满足我们这样的需求，我们可以在渲染之前为数据源手动添加唯一id，而不是在渲染时添加。","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://www.lisq.xyz/tags/react/"},{"name":"原理","slug":"原理","permalink":"https://www.lisq.xyz/tags/原理/"}]},{"title":"electron程序保护措施（崩溃监控，开机自启，托盘关闭）","slug":"electron程序保护措施（崩溃监控，开机自启，托盘关闭）","date":"2018-11-07T12:11:41.000Z","updated":"2018-11-07T12:12:13.617Z","comments":true,"path":"2018/11/07/electron程序保护措施（崩溃监控，开机自启，托盘关闭）/","link":"","permalink":"https://www.lisq.xyz/2018/11/07/electron程序保护措施（崩溃监控，开机自启，托盘关闭）/","excerpt":"","text":"在某种情况下，我们可能希望我们的客户端程序尽可能连续不断的运行在我们的系统中，并保持稳定。 以下几种方式可以帮助我们做到这一点： 1.崩溃监控electron为我们提供了监听程序崩溃的事件： 123456Event: &apos;crashed&apos;返回:event Eventkilled Boolean当渲染进程崩溃或被结束时触发 此事件是用来家庭渲染进程崩溃的，但是当主进程意外崩溃时也会触发该事件。 在监测到程序崩溃后，我们要让程序重新启动，此时我们要首先判断window对象是否被销毁，也就是主进程是否被杀死，还是渲染进程崩溃，同时作出不同的处理。 当mainWin被销毁时我们直接重启整个应用，使用如下api： 12345678910app.relaunch([options])options Object (可选)args StringexecPath String (可选)从当前实例退出，重启应用。默认情况下，新的实例会和当前实例使用相同的工作目录以及命令行参数。 当设置了 args 参数时， args 将作为命令行参数传递。 当设置了 execPath ，execPath 将被执行以重新启动，而不是当前的应用程序。请注意, 此方法在执行时不会退出当前的应用程序, 你需要在调用 app.relaunch 方法后再执行 app. quit 或者 app.exit 来让应用重启。 只是渲染进程崩溃，我们只需将其他窗体销毁，然后重新load我们的主窗口。 崩溃重启逻辑： 123456789if (mainWin.isDestroyed()) &#123; app.relaunch(); app.exit(0);&#125; else &#123; BrowserWindow.getAllWindows().forEach((w) =&gt; &#123; if (w.id !== mainWin.id) w.destroy(); &#125;); mainWin.reload();&#125; 当然，我们还要记录一下程序的崩溃日志，我们要确保日志接口发出成功后再重启我们的程序： 下面是程序崩溃后的完整逻辑： 123456789101112131415161718192021222324252627282930313233343536373839import &#123; BrowserWindow, app, dialog&#125; from &apos;electron&apos;; const mainWindow = BrowserWindow.fromId(global.mainId);mainWindow.webContents.on(&apos;crashed&apos;, () =&gt; &#123; const options = &#123; type: &apos;error&apos;, title: &apos;进程崩溃了&apos;, message: &apos;这个进程已经崩溃.&apos;, buttons: [&apos;重载&apos;, &apos;退出&apos;], &#125;; recordCrash().then(() =&gt; &#123; dialog.showMessageBox(options, (index) =&gt; &#123; if (index === 0) reloadWindow(mainWindow); else app.quit(); &#125;); &#125;).catch((e) =&gt; &#123; console.log(&apos;err&apos;, e); &#125;);&#125;)function recordCrash() &#123; return new Promise(resolve =&gt; &#123; // 崩溃日志请求成功.... resolve(); &#125;)&#125; function reloadWindow(mainWin) &#123; if (mainWin.isDestroyed()) &#123; app.relaunch(); app.exit(0); &#125; else &#123; BrowserWindow.getAllWindows().forEach((w) =&gt; &#123; if (w.id !== mainWin.id) w.destroy(); &#125;); mainWin.reload(); &#125;&#125; 写好代码之后，我们可以直接在控制台输入 123456789101112# 2.开机自启开机自启是保证我们的程序能长时间在机器上运行很重要的一点。电脑上有很多程序都设置了开机自启动，比如qq，微信，迅雷等，他们都是通过修改注册表来实现的，我们可以看一下注册表``` \\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run```:![image](https://lsqimg-1257917459.cos-website.ap-beijing.myqcloud.com/blog/zhucebiao1.bmp)所以我们也要将我们程序的路径写到这里。发现了一个非常好的写注册表的模块，```winreg 注意mac不能使用这个模块，所以首先要判断是否为window再引用这个模块。 借助这个模块我们可以非常简单的修改注册表： 1234567891011121314151617181920212223242526272829303132333435363738394041const WinReg = require(&apos;winreg&apos;);const startOnBoot = &#123; enableAutoStart: function (name, file, callback) &#123; var key = getKey(); key.set(name, WinReg.REG_SZ, file, callback || noop); &#125;, disableAutoStart: function (name, callback) &#123; var key = getKey(); key.remove(name, callback || noop); &#125;, getAutoStartValue: function (name, callback) &#123; var key = getKey(); key.get(name, function (error, result) &#123; if (result) &#123; callback(result.value); &#125; else &#123; callback(null, error); &#125; &#125;); &#125;&#125;;function noop() &#123; &#125;const RUN_LOCATION = &apos;\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run&apos;;function getKey() &#123; return new WinReg(&#123; hive: WinReg.HKCU, //CurrentUser, key: RUN_LOCATION &#125;);&#125;export default function autoStart() &#123; startOnBoot.getAutoStartValue(&apos;MY_CLIENT_AUTOSTART&apos;, function (value) &#123; if (!value) &#123; startOnBoot.enableAutoStart(&apos;MY_CLIENT_AUTOSTART&apos;, process.execPath, function () &#123; console.log(&apos;开机自动启设置&apos;); &#125;); &#125; &#125;);&#125; 执行完程序之后，再看注册表，发现我们程序的路径已经写进去了： 然后电脑重启后你的程序就自动启动了。 3.托盘关闭向qq和微信一样，有的时候我们并不想让用户通过点关闭按钮的时候就关闭程序，而是把程序最小化到托盘，在托盘上做真正的退出操作。 首先要监听窗口的关闭事件，阻止用户关闭操作的默认行为。 1234mainWindow.on(&apos;close&apos;, (event) =&gt; &#123; mainWindow.hide(); event.preventDefault();&#125;); 然而这时你发现，这只是最小化了程序，任务栏里程序依然存在，我们需要让程序在任务栏里也消失： 12345mainWindow.on(&apos;close&apos;, (event) =&gt; &#123; mainWindow.hide(); mainWindow.setSkipTaskbar(true); event.preventDefault();&#125;); 这时程序就再也找不到了，任务托盘中也没有我们的程序，所以我们要先创建好任务托盘，并做好事件监听： 123456789101112131415161718function createTray() &#123; const mainWindow = BrowserWindow.fromId(global.mainId); tray = new Tray(path.join(global.__dirname, &apos;icon.ico&apos;)); const contextMenu = Menu.buildFromTemplate([ &#123; label: &apos;退出&apos;, click: () =&gt; &#123; mainWindow.destroy(); app.quit(); &#125; &#125;, ]) tray.setToolTip(&apos;我的客户端&apos;) tray.setContextMenu(contextMenu) tray.on(&apos;click&apos;, () =&gt; &#123; if (mainWindow.isVisible()) &#123; mainWindow.hide(); mainWindow.setSkipTaskbar(false); &#125; else &#123; mainWindow.show(); mainWindow.setSkipTaskbar(true); &#125; &#125;) &#125; 以上这些操作为我们的程序又增加了好几层的防护措施，我们的程序就不会那么轻而易举的挂掉啦！","categories":[],"tags":[{"name":"electron","slug":"electron","permalink":"https://www.lisq.xyz/tags/electron/"},{"name":"崩溃监控","slug":"崩溃监控","permalink":"https://www.lisq.xyz/tags/崩溃监控/"}]},{"title":"使用electron静默打印","slug":"使用electron静默打印","date":"2018-11-01T10:30:14.000Z","updated":"2018-11-07T12:13:02.582Z","comments":true,"path":"2018/11/01/使用electron静默打印/","link":"","permalink":"https://www.lisq.xyz/2018/11/01/使用electron静默打印/","excerpt":"","text":"1.使用electron打印的理由很多情况下程序中使用的打印都是用户无感知的。并且想要灵活的控制打印内容，往往需要借助打印机给我们提供的api再进行开发，这种开发方式非常繁琐，并且开发难度较大。 electron提供的打印api可以非常灵活的控制打印设置的显示，并且可以通过html来书写打印内容。 2.apielectron提供了两种方式进行打印，一种是直接调用打印机打印，一种是打印到pdf。 并且有两种对象可以调用打印： 第一是通过window的webcontent对象，使用此种方式需要单独开出一个打印的窗口，可以将该窗口隐藏，但是通信调用相对复杂。 另一种是使用页面的webview元素调用打印，可以将webview隐藏在调用的页面中，通信方式比较简单。 两个对象调用打印方法的使用方式都一样。 2.1 print官网api如下 123456789contents.print([options], [callback])选项 Object (可选)silent Boolean (可选) - 不询问用户打印信息，默认为 false。printBackground Boolean (optional) - Also prints the background color and image of the web page. Default is false.deviceName String (optional) - Set the printer device name to use. Default is &apos;&apos;.callback Function (可选)success Boolean - Indicates success of the print call. 打印配置(options)中只有简单的三个配置： silent：打印时是否不展示打印配置（是否静默打印） printBackground：是否打印背景 deviceName：打印机设备名称 首先要将我们使用的打印机名称配置好，并且要在调用打印前首先要判断打印机是否可用。 使用getPrinters方法可获取当前设备已经配置的打印机列表，注意配置过不是可用，只是在此设备上安装过驱动。 通过getprinter获取到的打印机对象：https://electronjs.org/docs/api/structures/printer-info 我们这里只管关心两个，name和status，status为0时表示打印机可用。 这里的status必须经历一次打印失败才能返回非0值，也就是说第一次获取打印机状态一定是0。但是这一次的打印虽然不能判断出错误，打印的任务已经预存在队列中了，当下一次打印机状态变为可用时，将会打印暂存的任务。 当打印机纸张用完时也是这种情况，剩余任务会暂存起来，下次打印机可用时即可以打印了。 print的第二个参数callback是用于判断打印任务是否发出的回调，而不是打印任务完成后的回调。所以一般打印任务发出，回调函数即会调用并返回参数true。这个回调并不能判断打印是否真的成功了。 2.2 printToPdf123456789101112contents.printToPDF(options, callback)选项 ObjectmarginsType Integer (optional) - Specifies the type of margins to use. Uses 0 for default margin, 1 for no margin, and 2 for minimum margin.pageSize String (optional) - Specify page size of the generated PDF. Can be A3, A4, A5, Legal, Letter, Tabloid or an Object containing height and width in microns.printBackground Boolean (optional) - Whether to print CSS backgrounds.printSelectionOnly Boolean (optional) - Whether to print selection only.landscape Boolean (optional) - true for landscape, false for portrait.callback Function - 回调函数error Errordata Buffer printToPdf的用法基本和print相同，但是由于print是native code提供的方法，配置项非常少，而printToPdf则扩展了很多属性。 包括可以对打印的margin，打印页眉页脚等进行配置。 配置项很多，翻了一下源码发现还有很多没有被贴进api的： 123456789101112131415161718192021222324252627const defaultPrintingSetting = &#123; pageRage: [], mediaSize: &#123;&#125;, landscape: false, color: 2, headerFooterEnabled: false, marginsType: 0, isFirstRequest: false, requestID: getNextId(), previewModifiable: true, printToPDF: true, printWithCloudPrint: false, printWithPrivet: false, printWithExtension: false, deviceName: &apos;Save as PDF&apos;, generateDraftData: true, fitToPageEnabled: false, scaleFactor: 1, dpiHorizontal: 72, dpiVertical: 72, rasterizePDF: false, duplex: 0, copies: 1, collate: true, shouldPrintBackgrounds: false, shouldPrintSelectionOnly: false&#125; 3.打印边距问题打印的时候打印机会给纸张留一个默认边距，如果是A4这样的纸张几乎可以忽略不计了，但是打印小规格纸张如50mm*50mm，这个边距就十分明显了，严重影响了整体布局。 printToPdf方法提供了非常多的配置项，其中包括了配置打印边距的参数，但是print方法却没有该配置项。 我们可以通过一项css配置来解决这个问题,即12 @page { margin: 0px; } 12345678910111213141516171819通过此配置可灵活配置打印边距。还有一个css属性``` @media print &#123;&#125;``` 此配置是只有在打印时才生效的css，控制的是打印边距以内的css，并不能控制打印边距。# 4.打印方案使用webcontent打印，首先要有一个打印窗口，这个窗口不能随时打印随时创建，比较耗费性能。可以将它在程序运行时启动好，并做好事件监听。此过程需和调用打印的进行做好通信：大致过程如下：![image](http://on-img.com/chart_image/5badf135e4b0fe81b64ad7b9.png)可见通信非常繁琐使用webview进行打印可实现同样的效果但是通信方式会变得简单，因为渲染进程和webview通信不需要经过主进程，通过如下方式即可： // In embedder page. const webview = document.querySelector(‘webview’) webview.addEventListener(‘ipc-message’, (event) =&gt; { console.log(event.channel) // Prints “pong” }) webview.send(‘ping’)Copy123456```// 在访客页。 const &#123;ipcRenderer&#125; = require(&apos;electron&apos;) ipcRenderer.on(&apos;ping&apos;, () =&gt; &#123; ipcRenderer.sendToHost(&apos;pong&apos;) &#125;) 5.示例程序示例demo：https://github.com/ConardLi/electron-print-demo","categories":[],"tags":[{"name":"electron","slug":"electron","permalink":"https://www.lisq.xyz/tags/electron/"},{"name":"打印","slug":"打印","permalink":"https://www.lisq.xyz/tags/打印/"}]},{"title":"【前端面试】web存储","slug":"【前端面试】web存储","date":"2018-03-20T12:18:05.000Z","updated":"2018-11-30T12:22:15.856Z","comments":true,"path":"2018/03/20/【前端面试】web存储/","link":"","permalink":"https://www.lisq.xyz/2018/03/20/【前端面试】web存储/","excerpt":"","text":"1. 题目请描述一下cookie,sessionStorage和localStorage的区别 2.知识点2.1 cookie本身用于客户端和服务器端通信 但是他有本地存储的功能，于是就被借用 使用document.cookie =…获取和修改即可 缺点： 存储量太小，只有4kb 所有http请求都带着，影响获取资源的效率 api简单，需要封装才能用 document.cookie = 2.2 cookie 和 sessioncookie和session都是用来跟踪浏览器用户身份的会话方式。 区别： 1、保持状态：cookie保存在浏览器端，session保存在服务器端 2、使用方式： cookie机制：如果不在浏览器中设置过期时间，cookie被保存在内存中，生命周期随浏览器的关闭而结束，这种cookie简称会话cookie。如果在浏览器中设置了cookie的过期时间，cookie被保存在硬盘中，关闭浏览器后，cookie数据仍然存在，直到过期时间结束才消失。 session机制：当服务器收到请求需要创建session对象时，首先会检查客户端请求中是否包含sessionid。如果有sessionid，服务器将根据该id返回对应session对象。如果客户端请求中没有sessionid，服务器会创建新的session对象，并把sessionid在本次响应中返回给客户端。通常使用cookie方式存储sessionid到客户端，在交互中浏览器按照规则将sessionid发送给服务器。如果用户禁用cookie，则要使用URL重写，可以通过response.encodeURL(url) 进行实现；API对encodeURL的结束为，当浏览器支持Cookie时，url不做任何处理；当浏览器不支持Cookie的时候，将会重写URL将SessionID拼接到访问地址后。 3.session没有大小限制 4.session的安全性大于cookie，sessionID存储在cookie中，若要攻破session首先要攻破cookie；sessionID是加密的。 5.应用场景： cookie: 判断用户是否登陆过网站，以便下次登录时能够实现自动登录 保存上次登录的时间等信息。 浏览计数 session： Session用于保存每个用户的专用信息，变量的值保存在服务器端，通过SessionID来区分不同的客户。 网上商城中的购物车 保存用户登录信息 2.3 local storage 和 session storagehtml5专门为存储设计，最大容量5M,不会被携带在请求中 有的数据存储在WebStorage上，再加上浏览器本身的缓存。获取数据时可以从本地获取会比从服务器端获取快得多，所以速度更快； API简单易用 12localStorage.setItem(\"name\",\"zhangsan\");localStorage.getItem(\"name\"); IOS safari 隐藏模式下 getItem 报错 建议统一使用 try-catch封装 localStorage:localStorage的生命周期是永久的，关闭页面或浏览器之后localStorage中的数据也不会消失。localStorage除非主动删除数据，否则数据永远不会消失。 sessionStorage的生命周期是在仅在当前会话下有效。sessionStorage引入了一个“浏览器窗口”的概念，sessionStorage是在同源的窗口中始终存在的数据。只要这个浏览器窗口没有关闭，即使刷新页面或者进入同源另一个页面，数据依然存在。但是sessionStorage在关闭了浏览器窗口后就会被销毁。同时独立的打开同一个窗口同一个页面，sessionStorage也是不一样的。 应用场景：localStoragese：常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据。sessionStorage：敏感账号一次性登录； localStorage 可以用来统计页面访问次数。 当前页面导航栏的选中状态。 购物车数据。 sessionStorage 可以用来统计当前页面元素的点击次数。 3 题目解答容量 是否会携带到ajax中 API易用性","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.lisq.xyz/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://www.lisq.xyz/tags/基础/"},{"name":"面试","slug":"面试","permalink":"https://www.lisq.xyz/tags/面试/"},{"name":"存储","slug":"存储","permalink":"https://www.lisq.xyz/tags/存储/"}]},{"title":"【前端面试】ajax","slug":"【前端面试】ajax","date":"2018-03-18T08:49:06.000Z","updated":"2018-11-26T08:52:38.541Z","comments":true,"path":"2018/03/18/【前端面试】ajax/","link":"","permalink":"https://www.lisq.xyz/2018/03/18/【前端面试】ajax/","excerpt":"","text":"1.题目 手动编写一个ajax，不依赖第三方库 jquery 几种ajax的区别 跨域的几种实现方式 http://blog.csdn.net/zqjflash/article/details/50179235 2.知识点2.1 原生jaxa写法及参数说明123456789101112131415161718var xhr = new XMLHttpRequest();xhr.open('get',url,true)xhr.onreadystatechange = function()&#123; if(xhr.readyState === 4 )&#123; if(xhr.status === 200)&#123; console.log(xhr.responseText); console.log(JSON.parse(xhr.responseText)) &#125; &#125;&#125;xhr.send();//oAjax.readyState //浏览器和服务器，进行到哪一步了。//0-&gt;（未初始化）：还没有调用 open() 方法。//1-&gt;（载入）：已调用 send() 方法，正在发送请求。//2-&gt;载入完成）：send() 方法完成，已收到全部响应内容。//3-&gt;（解析）：正在解析响应内容。//4-&gt;（完成）：响应内容解析完成，可以在客户端调用。 post写法 1234567891011121314//post提交的数据postData = &#123;\"name1\":\"value1\",\"name2\":\"value2\"&#125;;//这里需要将json数据转成post能够进行提交的字符串 name1=value1&amp;name2=value2格式postData = (function(value)&#123; for(var key in value)&#123; oStr += key+\"=\"+value[key]+\"&amp;\"; &#125;; return oStr;&#125;(postData));//post相比get方式提交多了个这个oAjax.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");//post发送数据oAjax.send(postData); IE低版本 ActiveObject 2.3 跨域https://juejin.im/post/5815f4abbf22ec006893b431 浏览器有同源策略，不允许ajax访问其他域的接口 跨域条件：协议，域名，端口，有一个不同就算跨域 可以跨域的三个标签： 123&lt;img src=xxx&gt;&lt;link href=xxx&gt;&lt;script src=xxx&gt; 1.服务端解决跨域(增加请求头) 12345678app.all('*', function (req, res, next) &#123; res.header(\"Access-Control-Allow-Origin\", \"*\"); res.header(\"Access-Control-Allow-Headers\", \"X-Requested-With\"); res.header(\"Access-Control-Allow-Methods\", \"PUT,POST,GET,DELETE,OPTIONS\"); res.header(\"X-Powered-By\", ' 3.2.1'); res.header(\"Content-Type\", \"application/json;charset=utf-8\"); next();&#125;); 2.4 jsonp 原理浏览器有同源策略，不允许从一个源加载的文件或脚本与另一个源加载的文件或脚本进行交互。 包括：cookie localstorage dom ajax 跨域条件：协议，域名，端口，有一个不同就算跨域 ajax请求受同源策略影响，不允许进行跨域请求，而script标签src属性中的链接却可以访问跨域的js脚本，利用这个特性，服务端不再返回JSON格式的数据，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。 原生jsonp实现： 服务：123var r = JSON.stringify( &#123; a: &#123; id: 1, name: \"test\" &#125;, b: &#123; id: 2, name: \"test\" &#125; &#125;);r = `doo($&#123;r&#125;)`res.send(r) 调用：12345678function doo (data)&#123; console.log(data);&#125;document.addEventListener('DOMContentLoaded', function () &#123; var script = document.createElement('script'); script.setAttribute('src', 'http://127.0.0.1:3001/devices'); document.body.appendChild(script);&#125;); 1234567891011121314151617181920212223242526272829303132333435(function (window,document) &#123; \"use strict\"; var jsonp = function (url,data,callback) &#123; // 1.将传入的data数据转化为url字符串形式 // &#123;id:1,name:'zhangsan'&#125; =&gt; id=1&amp;name=zhangsan var dataString = url.indexof('?') == -1? '?': '&amp;'; for(var key in data)&#123; dataString += key + '=' + data[key] + '&amp;'; &#125;; // 2 处理url中的回调函数 // cbFuncName回调函数的名字 ：my_json_cb_名字的前缀 + 随机数（把小数点去掉） var cbFuncName = 'my_json_cb_' + Math.random().toString().replace('.',''); dataString += 'callback=' + cbFuncName; // 3.创建一个script标签并插入到页面中 var scriptEle = document.createElement('script'); scriptEle.src = url + dataString; // 4.挂载回调函数 window[cbFuncName] = function (data) &#123; callback(data); // 处理完回调函数的数据之后，删除jsonp的script标签 document.body.removeChild(scriptEle); &#125; // 5.append到页面中 document.body.appendChild(scriptEle); &#125; // 因为jsonp是一个私有函数外部不能调用，所有jsonp函数作文window对象的一个方法，供外部调用 window.$jsonp = jsonp;&#125;)(window,document) jquery jsonp实现： 123456789101112 $.ajax(&#123; type : \"get\", async: false, url : \"http://127.0.0.1:3001/devices?t=\"+new Date(), dataType: \"jsonp\", jsonp:\"callback\", //请求php的参数名 jsonpCallback: \"doo\",//要执行的回调函数 success : function(data) &#123; console.log(data); &#125; &#125;);5 2.5 postMessage跨域1234567891011//捕获iframevar domain = 'http://scriptandstyle.com';var iframe = document.getElementById('myIFrame').contentWindow;//发送消息setInterval(function()&#123; var message = 'Hello! The time is: ' + (new Date().getTime()); console.log('blog.local: sending message: ' + message); //send the message and target URI iframe.postMessage(message,domain); &#125;,6000); 123456//响应事件window.addEventListener('message',function(event) &#123; if(event.origin !== 'http://davidwalsh.name') return; console.log('message received: ' + event.data,event); event.source.postMessage('holla back youngin!',event.origin);&#125;,false); 2.6 WebSocket1234567891011121314151617181920212223242526272829303132333435function WebSocketTest()&#123; if (\"WebSocket\" in window) &#123; alert(\"您的浏览器支持 WebSocket!\"); // 打开一个 web socket var ws = new WebSocket(\"ws://localhost:9998/echo\"); ws.onopen = function() &#123; // Web Socket 已连接上，使用 send() 方法发送数据 ws.send(\"发送数据\"); alert(\"数据发送中...\"); &#125;; ws.onmessage = function (evt) &#123; var received_msg = evt.data; alert(\"数据已接收...\"); &#125;; ws.onclose = function() &#123; // 关闭 websocket alert(\"连接已关闭...\"); &#125;; &#125; else &#123; // 浏览器不支持 WebSocket alert(\"您的浏览器不支持 WebSocket!\"); &#125;&#125; 2.7 hash跨域3 题目解答3.1 jquery对ajxax封装3.1.1 $.ajax1jQuery.ajax([settings]) 重要参数： url 类型：String 默认值: 当前页地址。发送请求的地址。 type 类型：String 默认值: “GET”)。请求方式 (“POST” 或 “GET”)， 默认为 “GET”。注意：其它 HTTP 请求方法，如 PUT 和 DELETE 也可以使用，但仅部分浏览器支持。 timeout 类型：Number 设置请求超时时间（毫秒）。此设置将覆盖全局设置。 success 类型：Function 请求成功后的回调函数。 jsonp，jsonpCallback error 类型：Function 默认值: 自动判断 (xml 或 html)。请求失败时调用此函数。 dataType 类型：String 123456&quot;xml&quot;: 返回 XML 文档，可用 jQuery 处理。&quot;html&quot;: 返回纯文本 HTML 信息；包含的 script 标签会在插入 dom 时执行。&quot;script&quot;: 返回纯文本 JavaScript 代码。不会自动缓存结果。除非设置了 &quot;cache&quot; 参数。注意：在远程请求时(不在同一个域下)，所有 POST 请求都将转为 GET 请求。（因为将使用 DOM 的 script标签来加载）&quot;json&quot;: 返回 JSON 数据 。&quot;jsonp&quot;: JSONP 格式。使用 JSONP 形式调用函数时，如 &quot;myurl?callback=?&quot; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。&quot;text&quot;: 返回纯文本字符串 data 类型：String 使用JSON.stringify转码 complete(XHR, TS) 类型：Function 请求完成后回调函数 (请求成功或失败之后均调用)。 async 类型：Boolean 默认值: true。默认设置下，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为 false。 contentType 类型：String 默认值: “application/x-www-form-urlencoded”。发送信息至服务器时内容编码类型。 键值对这样组织在一般的情况下是没有什么问题的，这里说的一般是，不带嵌套类型JSON，也就是 简单的JSON，形如这样： 12345&#123; a: 1, b: 2, c: 3&#125; 但是在一些复杂的情况下就有问题了。 例如在 ajax 中你要传一个复杂的 json 对像，也就说是对象嵌数组，数组中包括对象，你这样传： application/x-www-form-urlencoded 这种形式是没有办法将复杂的 JSON 组织成键值对形式 1234567&#123; data: &#123; a: [&#123; x: 2 &#125;] &#125;&#125; 可以用如下方式传递复杂的json对象 12345$.ajax(&#123; dataType: 'json', contentType: 'application/json', data: JSON.stringify(&#123;a: [&#123;b:1, a:1&#125;]&#125;)&#125;) 3.1.2 $.get和$.post12$(selector).get(url,data,success(response,status,xhr),dataType)jQuery.post(url,data,success(data, textStatus, jqXHR),dataType) url 必需。规定将请求发送的哪个 URL。 data 可选。规定连同请求发送到服务器的数据。 success(response,status,xhr) 可选。规定当请求成功时运行的函数。额外的参数：response - 包含来自请求的结果数据status - 包含请求的状态xhr - 包含 XMLHttpRequest 对象 dataType 可选。规定预计的服务器响应的数据类型。 请求数据和返回数据都可以直接使用JS对象。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.lisq.xyz/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://www.lisq.xyz/tags/基础/"},{"name":"面试","slug":"面试","permalink":"https://www.lisq.xyz/tags/面试/"},{"name":"ajax","slug":"ajax","permalink":"https://www.lisq.xyz/tags/ajax/"}]},{"title":"【前端面试】事件绑定","slug":"【前端面试】事件绑定","date":"2018-03-14T15:26:44.000Z","updated":"2018-11-23T08:54:33.696Z","comments":true,"path":"2018/03/14/【前端面试】事件绑定/","link":"","permalink":"https://www.lisq.xyz/2018/03/14/【前端面试】事件绑定/","excerpt":"","text":"1. 题目编写一个通用的事件监听函数 描述事件冒泡流程 对于一个无限下拉加载图片的页面，如何给每个图片加载页面 2. 知识点2.1 事件绑定1e.preventDefault() //阻止默认事件 ie低版本使用attachEvent,和W3C标准不一样 2.2 事件冒泡向上冒泡 p–div–body 123456789101112&lt;body&gt; &lt;div id=\"div1\"&gt; &lt;p id=\"p1\"&gt;激活&lt;/p&gt; &lt;p id=\"p2\"&gt;取消&lt;/p&gt; &lt;p id=\"p3\"&gt;取消&lt;/p&gt; &lt;p id=\"p4\"&gt;取消&lt;/p&gt; &lt;/div&gt; &lt;div id=\"div2\"&gt; &lt;p id=\"p5\"&gt;取消&lt;/p&gt; &lt;p id=\"p6\"&gt;取消&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 实现：点击激活弹出激活，点击取消弹出取消 1234567891011document.addEventListener('DOMContentLoaded', function () &#123; var p1 = document.getElementById('p1'); var body = document.body; p1.onclick = function (e) &#123; e.stopPropagation() alert('激活') &#125; body.onclick = function () &#123; alert('取消') &#125;&#125;); e.stopPropagation() : 阻止事件冒泡 2.3 事件代理会随时新增p标签，如何绑定事件 1234&lt;div id=\"div1\"&gt; &lt;p id=\"p1\" class=\"p1\"&gt;激活&lt;/p&gt; &lt;p id=\"p1\" class=\"p1\"&gt;激活&lt;/p&gt;&lt;/div&gt; 将事件代理给上一层，然后再判断 123456789101112131415document.addEventListener('DOMContentLoaded', function () &#123; var div1 = document.getElementById('div1'); div1.onclick = function(e)&#123; var p = document.createElement('p'); p.setAttribute('class','p1'); p.innerText = '激活'; div1.appendChild(p); // if(e.target.nodeName === 'P')&#123; // alert('事件绑定成功'); // &#125; if(e.target.getAttribute('class') === 'p1')&#123; alert('事件绑定成功'); &#125; &#125;&#125;); 2.4 dom事件级别1234567dom0 element.onclick = function()&#123;&#125;dom1标准没有跟事件相关的东西dom2 element.addEventListener('click',function()&#123;&#125;)dom3 element.addEventListener('keyup',function()&#123;&#125;) //增加了事件类型 2.5 dom事件模型是什么冒泡型事件处理模型（Bubbling） 如上图所示，冒泡型事件处理模型在事件发生时，首先在最精确的元素上触发，然后向上传播，直到根节点。反映到DOM树上就是事件从叶子节点传播到根节点。 捕获型事件处理模型（Captrue） 相反地，捕获型在事件发生时首先在最顶级的元素上触发，传播到最低级的元素上。在DOM树上的表现就是由根节点传播到叶子节点。 12document.getElementById(\"myBtn\").addEventListener(\"click\", myFunction,true);//第三个参数设置是否冒泡，默认冒泡值为true，捕获值为false 2.6 dom事件流 “DOM2级事件”规定的事件流包括三个阶段： ① 事件捕获阶段； ② 处于目标阶段； ③ 事件冒泡阶段； 2.7 描述dom事件捕获的具体流程 上图的最上级还有一级window 123456789101112131415161718192021222324252627282930313233window.onload = function()&#123; var oBtn = document.getElementById('btn'); oBtn.addEventListener('click',function()&#123; console.log('btn处于事件捕获阶段'); &#125;, true); oBtn.addEventListener('click',function()&#123; console.log('btn处于事件冒泡阶段'); &#125;, false); document.addEventListener('click',function()&#123; console.log('document处于事件捕获阶段'); &#125;, true); document.addEventListener('click',function()&#123; console.log('document处于事件冒泡阶段'); &#125;, false); document.documentElement.addEventListener('click',function()&#123; console.log('html处于事件捕获阶段'); &#125;, true); document.documentElement.addEventListener('click',function()&#123; console.log('html处于事件冒泡阶段'); &#125;, false); document.body.addEventListener('click',function()&#123; console.log('body处于事件捕获阶段'); &#125;, true); document.body.addEventListener('click',function()&#123; console.log('body处于事件冒泡阶段'); &#125;, false); &#125;; document、documentElement和document.body三者之间的关系： document代表的是整个html页面； document.documentElement代表的是标签； document.body代表的是标签； 2.8 event对象的常见应用123456event.preventDefault();//阻止默认行为 （阻止a标签跳转）event.stopPropagation();//阻止事件冒泡event.stopImmediatePropagation();//一个按钮绑定两个事件，阻止其他同级事件event.currentTarget;//当前绑定事件的元素event.target;//当前点击元素event.keyCode;//获取键盘值 2.9 自定义事件12345678//1、创建事件var clickElem = new Event(\"clickElem\");//2、注册事件监听器elem.addEventListener(\"clickElem\",function(e)&#123; //干点事&#125;)//3、触发事件elem.dispatchEvent(clickElem); 实际应用： 比如自己封装个ajax用法是这样的:1234567Ajax.open(…)Ajax.on(\"success\",function()&#123;//do&#125;)Ajax.on(\"error\",function()&#123;//do&#125;) 对于这样的用法在node异步编程中很多的，比如fs模块，http模块等。这个用法叫做事件发布/订阅，这是一种异步编程方法。 3.题目解答3.1 编写一个通用的事件监听函数123456789101112131415161718192021222324252627function addEvent(elem, type, selector, fn) &#123; if (!fn) &#123; fn = selector; selector = null; &#125; elem.addEventListener(type, function (e) &#123; if (selector) &#123; if (e.target.matches(selector)) &#123; fn.call(e.target, e); &#125; &#125; else &#123; fn(e); &#125; &#125;);&#125;$(function () &#123; var div1 = document.getElementById('div1'); var p1 = document.getElementById('p1'); //使用事件代理 addEvent(div1, 'click', '.p1', function () &#123; console.log(this); &#125;); //普通绑定 addEvent(p1, 'click', function (e) &#123; alert('普通绑定'); &#125;);&#125;) 1let result = element.matches(selectorString); result 的值为 true 或 false. selectorString 是个css选择器字符串. 1234document.getElementById('p1').addEventListener('click', function (e) &#123; console.log(this.matches('#p1')); console.log(e.target.matches('#p1'));&#125;) 3.2 描述事件冒泡流程按照dom树形结构往上一级冒泡。 触发元素事件 —》 触发元素父级事件 —》 再上级事件 阻止冒泡，不触发父级事件。1e.stopPropagation(); 3.3 无限下拉加载图片如何绑定事件使用事件代理 优点： 代码简介 减轻浏览器压力，提高性能","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.lisq.xyz/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://www.lisq.xyz/tags/基础/"},{"name":"面试","slug":"面试","permalink":"https://www.lisq.xyz/tags/面试/"},{"name":"事件","slug":"事件","permalink":"https://www.lisq.xyz/tags/事件/"}]},{"title":"【前端面试】dom和bom","slug":"【前端面试】dom和bom","date":"2018-03-02T08:18:10.000Z","updated":"2018-11-17T08:20:04.483Z","comments":true,"path":"2018/03/02/【前端面试】dom和bom/","link":"","permalink":"https://www.lisq.xyz/2018/03/02/【前端面试】dom和bom/","excerpt":"","text":"JavaScript语言 = ECMAScript标准（基础语法）+ W3C 标准（webapi） 1.题目1.dom是哪种基本的数据结构 2.dom操作的常用api 3.dom节点的attr和property的区别 4.如何检测浏览器类型 5.拆解url的各部分 2.知识点2.1 dom本质document object model dom可以理解为：浏览器把拿到的html代码，结构化一个浏览器能识别并且js可操作的一个模型。 2.2 获取dom节点123456var div1 = document.getElementById('div1');//元素var divList = document.getElementsByTagName('div'); //集合var divList2 = document.getElementsByClassName('d1'); //集合divList.length;divList[0];document.querySelectorAll('#div1'); //集合 2.3 querySelectorAllquerySelector 当用Document类型调用querySelector()方法时，会在文档元素范围内查找匹配的元素；而当用Element类型调用querySelector()方法时，只会在这个元素的后代元素中去查找匹配的元素。若不存在匹配的元素，则这两种类型调用该方法时，均返回null。 只返回一个dom节点 和querySelectorAll 当用Element类型调用querySelectorAll()方法时，只会在这个元素的后代中去查找匹配的Element对象。若不存在匹配的对象，则这Document和Element这两种类型调用该方法时，均返回一个空的NodeList对象。 返回一个dom节点集合 2.4 attribute和propertyattribute：只是dom节点的属性(html标签的属性)1234var o1 = document.getElementById('test'); console.log(o1.getAttribute('id')) o1.setAttribute('class','test2'); console.log(o1.getAttribute('class')) property：获取后JS对象的属性12var o1 = document.getElementById('test'); console.log(o1.innerText); 2.5 dom结构操作新增节点 1div1.appendChild(div2) 父节点子节点123var parent = div1.parentElementvar child = div1.childNodesdiv1.removeChild(child[0]) 2.6 bombrowser object model navigator 存浏览器的一些属性 123var ua = navigator.userAgent; var isChrome = ua.indexOf('Chrome'); console.log(isChrome); screen 12screen.availHeight //浏览器可用高度screen.height //屏幕高度 location 123456location.protocol//协议 http: location.host //域名 www.baidu.com location.pathname //pathnamel /search location.search //参数 ？cid=99 location.hash // #mid=100 location.href history 12history.back();history.forward(); 2.7 浏览器高度123456789101112131415161718网页可见区域宽： document.body.clientWidth; 网页可见区域高： document.body.clientHeight; (实际取值是整个浏览器的)网页可见区域宽： document.body.offsetWidth (包括边线的宽); 网页可见区域高： document.body.offsetHeight (包括边线的宽); (实际取值是整个浏览器的)网页正文全文宽： document.body.scrollWidth; 网页正文全文高： document.body.scrollHeight; 网页被卷去的高： document.body.scrollTop; 网页被卷去的左： document.body.scrollLeft; 屏幕分辨率的高： window.screen.height; 屏幕分辨率的宽： window.screen.width; 实际使用的文本可见高度：window.innerHeightdocument.documentElement.clientHeight 当浏览器滚动条拉到最底部时： 12网页正文全文高 = 网页被卷去的高 + 浏览器可用高度 document.body.scrollHeight = document.body.scrollTop + window.innerHeight 判断元素是否可视：1clientHeight - (element.offsetTop - getScrollTop()) &gt; 0 123456789101112131415什么是document.body？返回html dom中的body节点 即&lt;body&gt;什么是 document.documentElement？返回html dom中的root 节点 即&lt;html&gt;在HTML 中, body 是整个DOM 的根, 而在XHTML 中, document 才是根, body 不再是根, 所以取body 的属性时, 不能再取到整个页面的值.使用document.documentElement来取代document.body,兼容性写法例：var top = document.documentElement.scrollTop || document.body.scrollTop;在javascript里||是个好东西，除了能用在if等条件判断里，还能用在变量赋值上。那么上例等同于下例。 例：var top = document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop;这么写可以得到很好的兼容性。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.lisq.xyz/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://www.lisq.xyz/tags/基础/"},{"name":"面试","slug":"面试","permalink":"https://www.lisq.xyz/tags/面试/"},{"name":"dom","slug":"dom","permalink":"https://www.lisq.xyz/tags/dom/"}]},{"title":"【前端面试】数组和对象","slug":"【前端面试】数组和对象","date":"2018-02-26T10:43:23.000Z","updated":"2018-11-15T10:45:30.158Z","comments":true,"path":"2018/02/26/【前端面试】数组和对象/","link":"","permalink":"https://www.lisq.xyz/2018/02/26/【前端面试】数组和对象/","excerpt":"","text":"1. 题目获取 2017-06-10 格式的日期 获取随机数，要求是长度一致的字符串 写一个能便利对象和数组的通用forEach函数 2.知识点2.1 日期123456789var dt = new Date();console.log(dt);console.log(dt.getTime());log(dt.getFullYear());log(dt.getMonth()); //月份从0开始log(dt.getDate());log(dt.getHours());log(dt.getMinutes());log(dt.getSeconds()); 2.2 数组1var arr = [2,4,1,5,2,1,3]; 2.2.1.遍历所有123arr.forEach((item,index)=&gt;&#123; console.log(index,item);&#125;); 2.2.2.判断是否所有元素都复合条件every()当内部return false时跳出整个循环 判断数组中元素是否全小于2123456789var bool = arr.every((item)=&gt;&#123; if(item&gt;=2)&#123; return false; &#125;else&#123; return true; &#125;&#125;);console.log(bool); 2.2.3.是否至少一个元素复合条件some()当内部return true时跳出整个循环 判断数组中元素是否只要有一个大于等于8 12345678var bool = arr.some((item)=&gt;&#123; if(item&gt;=8)&#123; return true; &#125;&#125;);console.log(bool); 2.2.4.排序123456var arr2 = arr.sort((a,b)=&gt;&#123; // return a-b; //从小到大 return b-a; //从大到小&#125;); console.log(arr2); 2.2.5.对元素重新组装，生成新数组12345var arr2 = arr.map((item,index)=&gt;&#123; return item + index +'&lt;/br&gt;';&#125;); console.log(arr2); 2.2.6 api1234pop() 删除并返回数组的最后一个元素shift() 删除并返回数组的第一个元素push() 向数组的末尾添加一个或更多元素，并返回新的长度。unshift() 向数组的开头添加一个或更多元素，并返回新的长度。 6.过滤符合条件的元素12345var arr2 = arr.filter((item,index)=&gt;&#123; return item&gt;1;&#125;); console.log(arr2); 2.3 对象hasOwnProperty() 过滤原型链上的属性（高版本浏览器已经不需要使用它了） 3. 题目解答3.1 获取 2017-06-10 格式的日期123456789101112131415function formatDate(dt = new Date(),format = '-')&#123; var year = dt.getFullYear() var month = dt.getMonth() +1; var date = dt.getDate(); if(month&lt;10)&#123; month = '0' + month; &#125; if(date &lt; 10)&#123; date = '0' + date; &#125; return year + format + month + format + date;&#125;var dt = formatDate(new Date(),'/');console.log(dt); 3.2 获取随机数，要求是长度一致的字符串1234var r = Math.random();r = r + '0000000000';r = r.slice(0,11);console.log(r); 3.3 写一个能便利对象和数组的通用forEach函数1234567891011121314151617181920212223function forEach(obj,fn)&#123; var key; if(obj instanceof Array)&#123; obj.forEach(function(item,index)&#123; fn(index,item); &#125;) &#125;else&#123; for(key in obj)&#123; fn(key,obj[key]); &#125; &#125;&#125;var arr = [1,23,3];forEach(arr,function(index,item)&#123; console.log(index,item)&#125;);var obj = &#123;x:100,y:200&#125;forEach(obj,function(key,value)&#123; console.log(key,obj[key]);&#125;); 3.4 slice和splice的区别slice定义和用法 slice() 方法可从已有的数组中返回选定的元素。123arrayObject.slice(start,end)start 必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。end 可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。 返回值返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。请注意，该方法并不会修改数组，而是返回一个子数组。如果想删除数组中的一段元素，应该使用方法 Array.splice()。 1234var arr=[1,2,3,4,5,6];var arr2=arr.slice(2,4);console.log(\"arr2=\",arr2,\",arr=\",arr);//arr2= [3, 4] ,arr= [1, 2, 3, 4, 5, 6] splice定义和用法 splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。该方法会改变原始数组。1234arrayObject.splice(index,howmany,item1,.....,itemX)index 必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。howmany 必需。要删除的项目数量。如果设置为 0，则不会删除项目。item1, ..., itemX 可选。向数组添加的新项目。 返回值Array 包含被删除项目的新数组，如果有的话。 splice() 方法可删除从 index处开始的零个或多个元素，并且用参数列表中声明的一个或多个值来替换那些被删除的元素。如果从 arrayObject 中删除了元素，则返回的是含有被删除的元素的数组。提示和注释 请注意，splice() 方法与 slice() 方法的作用是不同的，splice() 方法会直接对数组进行修改。 1234567891011121314var arr = new Array(6)arr[0] = \"George\"arr[1] = \"John\"arr[2] = \"Thomas\"arr[3] = \"James\"arr[4] = \"Adrew\"arr[5] = \"Martin\"document.write(arr + \"&lt;br /&gt;\")document.write(arr.splice(2, 3, \"William\")+ \"&lt;br /&gt;\")document.write(arr)//George,John,Thomas,James,Adrew,Martin//Thomas,James,Adrew//George,John,William,Martin 3.5 深拷贝和浅拷贝浅复制：浅复制是复制引用，复制后的引用都是指向同一个对象的实例，彼此之间的操作会互相影响 深复制：深复制不是简单的复制引用，而是在堆中重新分配内存，并且把源对象实例的所有属性都进行新建复制，以保证深复制的对象的引用图不包含任何原有对象或对象图上的任何对象，复制后的对象与原来的对象是完全隔离的 方法11var target = JSON.parse(JSON.stringify(source)); 方法2 Array的slice和concat方法都会返回一个新的数组实例，但是这两个方法对于数组中的对象元素却没有执行深复制，而只是复制了引用了，因此这两个方法并不是真正的深复制，通过以下代码进行理解： 12345678var array = [1,2,3]; var array_shallow = array; var array_concat = array.concat(); var array_slice = array.slice(0); console.log(array === array_shallow); //true console.log(array === array_slice); //false console.log(array === array_concat); //false 手动实现：递归 12345678910111213141516171819function copy(obj,deep)&#123; //如果obj不是对象，那么直接返回值就可以了 if(obj === null typeof obj !== \"object\")&#123; return obj; &#125; //定义需要的局部变脸，根据obj的类型来调整target的类型 var i, target = util.isType(obj,\"array\") ? [] : &#123;&#125;,value,valueType; for(i in obj)&#123; value = obj[i]; valueType = util.getType(value); //只有在明确执行深复制，并且当前的value是数组或对象的情况下才执行递归复制 if(deep &amp;&amp; (valueType === \"array\" valueType === \"object\"))&#123; target[i] = copy(value); &#125;else&#123; target[i] = value; &#125; &#125; return target;&#125; sort方法底层原理V8 引擎 sort 函数只给出了两种排序 InsertionSort 和 QuickSort，数量小于10的数组使用 InsertionSort，比10大的数组则使用 QuickSort。 通过判断comparefn(a,b)来决定顺序; 快排：该值大于0左侧放小数右侧放大数 插入排序：该值大于0左侧有序数列按从小到大排列。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.lisq.xyz/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://www.lisq.xyz/tags/基础/"},{"name":"面试","slug":"面试","permalink":"https://www.lisq.xyz/tags/面试/"}]},{"title":"webworker","slug":"webworker","date":"2018-02-07T15:38:55.000Z","updated":"2018-11-15T10:46:48.576Z","comments":true,"path":"2018/02/07/webworker/","link":"","permalink":"https://www.lisq.xyz/2018/02/07/webworker/","excerpt":"","text":"假异步上面的文章得出，js使用event loop在单线程状态下实现了一个”假”异步。 即等同步代码执行完在执行异步代码，可模拟不阻塞的效果。 比如使用settimeout或者promise同时执行两个耗时任务： 12345678910setTimeout(() =&gt; &#123; for (let index = 0; index &lt; 100; index++) &#123; console.log(index); &#125;&#125;, 0);setTimeout(() =&gt; &#123; for (let index = 0; index &lt; 100; index++) &#123; console.log(index); &#125;&#125;, 0); 123456789101112131415new Promise(resolve =&gt; &#123; resolve();&#125;).then((val) =&gt; &#123; for (let index = 0; index &lt; 100; index++) &#123; console.log(index); &#125;&#125;)new Promise(resolve =&gt; &#123; resolve();&#125;).then((val) =&gt; &#123; for (let index = 0; index &lt; 100; index++) &#123; console.log(index); &#125;&#125;) 两者的效果是相同的，两次1-100的打印不能并发进行。 webworkerWeb Worker 是HTML5标准的一部分，这一规范定义了一套 API，它允许一段JavaScript程序运行在主线程之外的另外一个线程中。工作线程允许开发人员编写能够长时间运行而不被用户所中断的后台程序， 去执行事务或者逻辑，并同时保证页面对用户的及时响应，可以将一些大量计算的代码交给web worker运行而不冻结用户界面 12345//webworker.jsfor (let index = 0; index &lt; 100000; index++) &#123; console.log(index);&#125; 12var worker = new Worker(\"webworker.js\");var worker2 = new Worker(\"webworker.js\"); 耗时任务可以同时进行。 终止1234567// 方式一 main.js 在主线程停止方式 var worker = new Worker('./worker.js');...worker.terminate();// 方式二、worker.jsself.close() 通信12345678910111213141516171819//主线程 main.jsvar worker = new Worker(\"worker.js\");worker.onmessage = function(event)&#123; // 主线程收到子线程的消息&#125;;// 主线程向子线程发送消息worker.postMessage(&#123; type: \"start\", value: 12345&#125;);//web worker.jsonmessage = function(event)&#123; // 收到&#125;;postMessage(&#123; type: \"debug\", message: \"Starting processing...\"&#125;);","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.lisq.xyz/tags/javascript/"},{"name":"异步","slug":"异步","permalink":"https://www.lisq.xyz/tags/异步/"},{"name":"html5","slug":"html5","permalink":"https://www.lisq.xyz/tags/html5/"}]},{"title":"async-await","slug":"async-await","date":"2018-02-06T12:31:09.000Z","updated":"2018-11-12T12:34:05.115Z","comments":true,"path":"2018/02/06/async-await/","link":"","permalink":"https://www.lisq.xyz/2018/02/06/async-await/","excerpt":"","text":"基本用法async 表示这是一个async函数，await只能用在这个函数里面。 await 表示在这里等待promise返回结果了，再继续执行。 await 后面跟着的应该是一个promise对象（当然，其他返回值也没关系，只是会立即执行，不过那样就没有意义了…） 这里我们要实现一个暂停功能，输入N毫秒，则停顿N毫秒后才继续往下执行。 12345678910111213141516var sleep = function (time) &#123; return new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; resolve(); &#125;, time); &#125;)&#125;;var start = async function () &#123; // 在这里使用起来就像同步代码那样直观 console.log('start'); await sleep(3000); console.log('end');&#125;;start(); 返回值await等待的虽然是promise对象，但不必写.then(..)，直接可以得到返回值。 12345678910111213var sleep = function (time) &#123; return new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; // 返回 ‘ok’ resolve('ok'); &#125;, time); &#125;)&#125;;var start = async function () &#123; let result = await sleep(3000); console.log(result); // 收到 ‘ok’&#125;; 捕捉错误既然.then(..)不用写了，那么.catch(..)也不用写，可以直接用标准的try catch语法捕捉错误。 1234567891011121314151617181920var sleep = function (time) &#123; return new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; // 模拟出错了，返回 ‘error’ reject('error'); &#125;, time); &#125;)&#125;;var start = async function () &#123; try &#123; console.log('start'); await sleep(3000); // 这里得到了一个返回错误 // 所以以下代码不会被执行了 console.log('end'); &#125; catch (err) &#123; console.log(err); // 这里捕捉到错误 `error` &#125;&#125;; 这样做的好处是也可以捕获其他同步代码。 循环多个awaitawait看起来就像是同步代码，所以可以理所当然的写在for循环里，不必担心以往需要闭包才能解决的问题。12345678910111213141516171819202122232425..省略以上代码var start = async function () &#123; for (var i = 1; i &lt;= 10; i++) &#123; console.log(`当前是第$&#123;i&#125;次等待..`); await sleep(1000); &#125;&#125;;值得注意的是，await必须在async函数的上下文中的。..省略以上代码let 一到十 = [1,2,3,4,5,6,7,8,9,10];// 错误示范一到十.forEach(function (v) &#123; console.log(`当前是第$&#123;v&#125;次等待..`); await sleep(1000); // 错误!! await只能在async函数中运行&#125;);// 正确示范for(var v of 一到十) &#123; console.log(`当前是第$&#123;v&#125;次等待..`); await sleep(1000); // 正确, for循环的上下文还在async函数中&#125; 第二个例子这个例子是一个小应用，根据电影文件名，自动下载对应的海报。 直接贴出代码，就不说明了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import fs from 'fs';import path from 'path';import request from 'request';var movieDir = __dirname + '/movies', exts = ['.mkv', '.avi', '.mp4', '.rm', '.rmvb', '.wmv'];// 读取文件列表var readFiles = function () &#123; return new Promise(function (resolve, reject) &#123; fs.readdir(movieDir, function (err, files) &#123; resolve(files.filter((v) =&gt; exts.includes(path.parse(v).ext))); &#125;); &#125;);&#125;;// 获取海报var getPoster = function (movieName) &#123; let url = `https://api.douban.com/v2/movie/search?q=$&#123;encodeURI(movieName)&#125;`; return new Promise(function (resolve, reject) &#123; request(&#123;url: url, json: true&#125;, function (error, response, body) &#123; if (error) return reject(error); resolve(body.subjects[0].images.large); &#125;) &#125;);&#125;;// 保存海报var savePoster = function (movieName, url) &#123; request.get(url).pipe(fs.createWriteStream(path.join(movieDir, movieName + '.jpg')));&#125;;(async () =&gt; &#123; let files = await readFiles(); // await只能使用在原生语法 for (var file of files) &#123; let name = path.parse(file).name; console.log(`正在获取【$&#123;name&#125;】的海报`); savePoster(name, await getPoster(name)); &#125; console.log('=== 获取海报完成 ===');&#125;)();","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.lisq.xyz/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://www.lisq.xyz/tags/基础/"},{"name":"面试","slug":"面试","permalink":"https://www.lisq.xyz/tags/面试/"},{"name":"async","slug":"async","permalink":"https://www.lisq.xyz/tags/async/"},{"name":"es7","slug":"es7","permalink":"https://www.lisq.xyz/tags/es7/"},{"name":"异步","slug":"异步","permalink":"https://www.lisq.xyz/tags/异步/"}]},{"title":"promise","slug":"promise","date":"2018-01-29T09:18:05.000Z","updated":"2018-11-11T09:21:13.641Z","comments":true,"path":"2018/01/29/promise/","link":"","permalink":"https://www.lisq.xyz/2018/01/29/promise/","excerpt":"","text":"概念主要用于异步计算 可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果。 promise是一个代理对象，他和原先要进行的操作并无关系。 他通过引入一个回调，避免其他回调。 三个状态： pending【待定】初始状态 fulfilled【实现】操作成功 rejected【被否决】操作失败 promise状态改变，就会出发.then里的响应函数处理后续步骤 promise状态改变以后不会再改变。 回调的问题嵌套层次很深，难以维护 无法使用return 多个回调之间难以建立联系 简单实例1234567891011121314new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve('第一次输出'); &#125;, 1500);&#125;).then(value =&gt; &#123; console.log(value); return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve('第二次输出'); &#125;, 1500); &#125;)&#125;).then(value =&gt;&#123; console.log(value);&#125;) 在任何一个地方声明promise 在后面可以追寻任意多的then，会按照队列的顺序执行，如果promise已经完成再then那么还会得到结果。 在then函数中不直接返回promise123456789101112131415161718192021new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve('hello'); &#125;, 2000);&#125;) .then(value =&gt; &#123; console.log(value); console.log('everyone'); (function () &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log('Mr.Laurence'); resolve('Merry Xmas'); &#125;, 2000); &#125;); &#125;()); return false; &#125;) .then(value =&gt; &#123; console.log(value + ' world'); &#125;); 如果不直接返回promise实例，他就会默认去执行下一个环节。 then函数then接受两个函数作为函数，分别代表fulfilled和rejected then返回一个新的peomise实例，所以它可以链式调用 当前面的peomise状态改变，then根据其最终状态，选择特定的状态响应函数执行。 状态相应函数可以返回新的promise或者其他值。 如果返回新的promise，那么下一级.then会在新promise状态改变后执行 如果返回其他任何值，则会立即执行下一级then then嵌套当then函数中嵌套了then，会先将嵌套里面的then执行完毕，再去执行外面的then。 1234567891011121314151617181920212223242526new Promise( resolve =&gt; &#123; console.log('Step 1'); setTimeout(() =&gt; &#123; resolve(100); &#125;, 1000);&#125;) .then( value =&gt; &#123; return new Promise(resolve =&gt; &#123; console.log('Step 1-1'); setTimeout(() =&gt; &#123; resolve(110); &#125;, 1000); &#125;) .then( value =&gt; &#123; console.log('Step 1-2'); return value; &#125;) .then( value =&gt; &#123; console.log('Step 1-3'); return value; &#125;); &#125;) .then(value =&gt; &#123; console.log(value); console.log('Step 2'); &#125;); 错误处理promise会自动捕获内部异常，并交给rejected函数处理 错误处理的两种做法： 123456789101112new Promise( resolve =&gt; &#123; setTimeout( () =&gt; &#123; throw new Error('bye'); &#125;, 2000);&#125;) .then( value =&gt; &#123; console.log( value + ' world'); &#125;) .catch( error =&gt; &#123; console.log( 'Error：', error.message); &#125;); catch可以捕获之前所有then的错误。 12345678910new Promise( (resolve, reject) =&gt; &#123; setTimeout( () =&gt; &#123; reject('bye'); &#125;, 2000);&#125;) .then( value =&gt; &#123; console.log( value + ' world'); &#125;, value =&gt; &#123; console.log( 'Error：', value); &#125;); rejected只能捕获当前then的错误。 当catch函数后面再跟then时，后面还会执行。 强烈建议所有队列最后都加上catch，以便避免漏掉错误处理， promise.all参数为Promise对象数组，如果有不是Promise的对象，将会先通过上面的Promise.resolve()方法转换123456var promise = Promise.all( [p1, p2, p3] )promise.then( ...).catch( ...) 当p1、p2、p3的状态都变成resolved时，promise才会变成resolved，并调用then()的已完成回调，但只要有一个变成rejected状态，promise就会立刻变成rejected状态 promise.resolve返回一个fulfilled的promise实例，或原始promise实例 promise.reject返回一个rejected的实例 promise.race类似于promise.all ，区别在于他有一个实例完成就算完成。 回调包装成promise可读性好，返回结果可加入任意promise。 包装12345678910111213141516171819202122module.exports = &#123; readDir: function (path, options) &#123; return new Promise( resolve =&gt; &#123; fs.readdir(path, options, (err, files) =&gt; &#123; if (err) &#123; throw err; &#125; resolve(files); &#125;); &#125;); &#125;, readFile: function (path, options) &#123; return new Promise( resolve =&gt; &#123; fs.readFile(path, options, (err, content) =&gt; &#123; if (err) &#123; throw err; &#125; resolve(content); &#125;); &#125;); &#125;&#125;; 使用1234fs.readFile('../README.md', 'utf-8') .then(content =&gt; &#123; console.log(content); &#125;); 和map连用找到最大文件 异步读取文件列表，当所有文件列表读取完成执行then函数。12345678910111213141516171819202122232425262728function findLargest(dir) &#123; return FileSystem.readDir(dir, 'utf-8') .then( files =&gt; &#123; return Promise.all( files.map( file =&gt; &#123; return new Promise (resolve =&gt; &#123; fs.stat(path.join(dir, file), (err, stat) =&gt; &#123; if (err) throw err; if (stat.isDirectory()) &#123; return resolve(&#123; size: 0 &#125;); &#125; stat.file = file; resolve(stat); &#125;); &#125;); &#125;)); &#125;) .then( stats =&gt; &#123; let biggest = stats.reduce( (memo, stat) =&gt; &#123; if(memo.size &lt; stat.size) &#123; return stat; &#125; return memo; &#125;); return biggest.file; &#125;)&#125; ajax回调代替12345678910111213//例1function getUserId() &#123; return new Promise(function(resolve) &#123; //异步请求 http.get(url, function(results) &#123; resolve(results.id) &#125;) &#125;)&#125;getUserId().then(function(id) &#123; //一些处理&#125;) promise原理https://segmentfault.com/a/1190000009478377(1)12345678910111213141516function Promise(fn) &#123; var value = null, callbacks = []; //callbacks为数组，因为可能同时有很多个回调 this.then = function (onFulfilled) &#123; callbacks.push(onFulfilled); &#125;; function resolve(value) &#123; callbacks.forEach(function (callback) &#123; callback(value); &#125;); &#125; fn(resolve);&#125; (2) then resolve 回调 状态1234567891011121314151617181920212223242526function Promise(fn) &#123; var state = 'pending', value = null, callbacks = []; this.then = function (onFulfilled) &#123; if (state === 'pending') &#123; callbacks.push(onFulfilled); return this; &#125; onFulfilled(value); return this; &#125;; function resolve(newValue) &#123; value = newValue; state = 'fulfilled'; setTimeout(function () &#123; callbacks.forEach(function (callback) &#123; callback(value); &#125;); &#125;, 0); &#125; fn(resolve);&#125; (3)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function Promise(fn) &#123; var state = 'pending', value = null, callbacks = []; this.then = function (onFulfilled) &#123; return new Promise(function (resolve) &#123; handle(&#123; onFulfilled: onFulfilled || null, resolve: resolve &#125;); &#125;); &#125;; function handle(callback) &#123; if (state === 'pending') &#123; callbacks.push(callback); return; &#125; //如果then中没有传递任何东西 if(!callback.onFulfilled) &#123; callback.resolve(value); return; &#125; var ret = callback.onFulfilled(value); callback.resolve(ret); &#125; function resolve(newValue) &#123; if (newValue &amp;&amp; (typeof newValue === 'object' || typeof newValue === 'function')) &#123; var then = newValue.then; if (typeof then === 'function') &#123; then.call(newValue, resolve); return; &#125; &#125; state = 'fulfilled'; value = newValue; setTimeout(function () &#123; callbacks.forEach(function (callback) &#123; handle(callback); &#125;); &#125;, 0); &#125; fn(resolve);&#125;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.lisq.xyz/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://www.lisq.xyz/tags/基础/"},{"name":"面试","slug":"面试","permalink":"https://www.lisq.xyz/tags/面试/"},{"name":"异步","slug":"异步","permalink":"https://www.lisq.xyz/tags/异步/"},{"name":"promise","slug":"promise","permalink":"https://www.lisq.xyz/tags/promise/"},{"name":"es6","slug":"es6","permalink":"https://www.lisq.xyz/tags/es6/"}]},{"title":"【前端面试】异步和单线程","slug":"【前端面试】异步和单线程","date":"2018-01-22T12:56:02.000Z","updated":"2018-11-11T09:21:03.385Z","comments":true,"path":"2018/01/22/【前端面试】异步和单线程/","link":"","permalink":"https://www.lisq.xyz/2018/01/22/【前端面试】异步和单线程/","excerpt":"","text":"1.问题异步和同步的区别，分别举一个例子 一个关于settimeoit的比笔试题 前端使用异步的场景 2.知识点2.1 异步何时使用异步： 在可能发生等待的情况 使用异步的场景： 定时任务： settimeout 网络请求： ajax 动态img加载 事件绑定 2.2 单线程所有异步的代码都会暂存（任务队列）最后再执行。 3.问题解答3.1 异步和同步的区别，分别举一个例子同步会阻塞代码执行，异步不会 alert是同步，settimeout是异步 3.2 一个关于settimeoit的比笔试题123456789console.log(1);setTimeout(() =&gt; &#123; console.log(2);&#125;, 0);console.log(3);setTimeout(() =&gt; &#123; console.log(4);&#125;, 1000);console.log(5); 顺序 ：13524 3.3 前端使用异步的场景 定时任务： settimeout 网络请求： ajax 动态img加载 时间绑定 3.4 Event loop同步任务 –》 运行栈 –》 遇到异步任务 –》 暂存到临时队列中 –》 异步任务达到可以运行的时间 –》 放到任务队列中–》 运行栈中的任务执行完毕–》 在任务队列中取出可执行任务存入运行栈 –》 执行运行栈中的任务 –》 执行完毕…去任务队列查找任务… 3.5 事件队列高级1234567891011setTimeout(function()&#123;console.log(4)&#125;,0);new Promise(function(resolve)&#123; console.log(1) for( var i=0 ; i&lt;10000 ; i++ )&#123; i==9999 &amp;&amp; resolve() &#125; console.log(2)&#125;).then(function()&#123; console.log(5)&#125;);console.log(3); 执行顺序 11,2,3,5,4 由于整个 script 也属于一个 macrotask, 由于会先执行 macrotask 中的第一个任务，再加上promise 构造函数因为是同步的，所以会先打印出 1和2然后继续同步执行末尾的 console.log(3) 打印出3 此时 setTimeout 被推进到 macrotask 队列中， promise.then 回调被推进到 microtask 队列中 由于在第一步中已经执行完了第一个 macrotask , 所以接下来会顺序执行所有的 microtask, 也就是 promise.then 的回调函数，从而打印出5 microtask 队列中的任务已经执行完毕，继续执行剩下的 macrotask 队列中的任务，也就是 setTimeout, 所以打印出 4","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.lisq.xyz/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://www.lisq.xyz/tags/基础/"},{"name":"面试","slug":"面试","permalink":"https://www.lisq.xyz/tags/面试/"},{"name":"异步","slug":"异步","permalink":"https://www.lisq.xyz/tags/异步/"}]},{"title":"【前端面试】作用域和闭包","slug":"【前端面试】作用域和闭包","date":"2018-01-20T14:24:59.000Z","updated":"2018-11-09T14:34:46.555Z","comments":true,"path":"2018/01/20/【前端面试】作用域和闭包/","link":"","permalink":"https://www.lisq.xyz/2018/01/20/【前端面试】作用域和闭包/","excerpt":"","text":"1. 题目说一下对变量提升的理解 说明this的几种不同使用场景 创建10个a标签，点击的时候弹出来相应的序号 如何理解作用域 实际开发中闭包的应用 2. 知识点2.1 执行上下文范围：一段script或者一个函数 全局：变量定义、函数声明 script 函数：变量定义、函数声明、this、arguments （执行之前） 函数声明和函数表达式的区别： 12345a(); //报错 函数表达式 变量声明 会提前。var a = function()&#123;&#125;b(); // 不报错 函数声明function b()&#123;&#125; 变量定义时会默认把他的变量声明提升：(仅限于他的执行上下文，比如一段script和一个函数中) 12console.log(a);var a = 0; 实际上是 123var a;console.log(a);a = 0; 2.2 thisthis要在执行时才能确认，定义时无法确认。 1234567891011var a = &#123; name:'a', fn:function()&#123; console.log(this.name); &#125;&#125;a.fn(); // aa.fn.apply(&#123;name:'b'&#125;); // b a.fn.call(&#123;name:'b'&#125;);var fn1 = a.fn();fn1(); // undefined this的使用场景 构造函数中（指向构造的对象） 12345function Fun(name)&#123; this.name = name;&#125;var f = new Fun('a');console.log(f.name); 对象属性中（指向该对象） 普通函数中（指向window） call apply bind 12345var fun = function (name)&#123; console.log(this); console.log(name);&#125;.bind(&#123;a:1&#125;);fun(\"name\"); arguments中的this：12345678910var length = 10;function fn()&#123; alert(this.length)&#125;var obj = &#123; length: 5, method: function(fn) &#123; arguments[0]() &#125;&#125; obj.method(fn)//输出1这里没有输出5，也没有输出10，反而输出了1，有趣。这里arguments是javascript的一个内置对象（可以参见mdn：arguments - JavaScript），是一个类数组（就是长的比较像数组，但是欠缺一些数组的方法，可以用slice.call转换，具体参见上面的链接），其存储的是函数的参数。也就是说，这里arguments[0]指代的就是你method函数的第一个参数：fn，所以arguments0的意思就是：fn()。 不过这里有个疑问，为何这里没有输出5呢？我method里面用this，不应该指向obj么，至少也会输出10呀，这个1是闹哪样？ 实际上，这个1就是arguments.length，也就是本函数参数的个数。为啥这里的this指向了arguments呢？因为在Javascript里，数组只不过使用数字做属性名的方法，也就是说：arguments0的意思，和arguments.0()的意思差不多（当然这么写是不允许的），你更可以这么理解：1234567arguments = &#123; 0: fn, //也就是 functon() &#123;alert(this.length)&#125; 1: 第二个参数, //没有 2: 第三个参数, //没有 ..., length: 1 //只有一个参数&#125; 所以这里alert出来的结果是1。 如果要输出5应该咋写呢？直接 method: fn 就行了。 2.3 作用域没有块级作用域 1234if(true)&#123; var name = \"test\"&#125;console.log(name); 尽量不要在块中声明变量。 只有函数级作用域 2.4 作用域链自由变量 当前作用域没有定义的变量 即为自由变量。 自由变量会去其父级作用域找。是定义时的父级作用域，而不是执行。 123456789101112var a = 100;function f1()&#123; var b = 200; function f2()&#123; var c = 300; console.log(a); //自由变量 console.log(b); //自由变量 console.log(c); &#125; f2();&#125;;f1(); 2.5 闭包 一个函数中嵌套另外一个函数，并且将这个函数return出去，然后将这个return出来的函数保存到了一个变量中，那么就创建了一个闭包。 闭包的两个使用场景 1.函数作为返回值 12345678910function fun()&#123; var a = 0; return function()&#123; console.log(a); //自由变量，去定义时的父级作用域找 &#125;&#125;var f1 = fun();a = 1000;f1(); 2.函数作为参数 123456789101112131415function fun()&#123; var a = 0; return function()&#123; console.log(a); //自由变量，去定义时的父级作用域找 &#125;&#125;function fun2(f2)&#123; a = 10000 f2();&#125;var f1 = fun();fun2(f1); 具体解释看 高级-闭包中的说明 闭包的两个作用： 能够读取其他函数内部变量的函数 可以让函数内部的变量一直保存在内存中 实际应用场景1： 闭包可以将一些不希望暴露在全局的变量封装成“私有变量”。 假如有一个计算乘积的函数，mult函数接收一些number类型的参数，并返回乘积结果。为了提高函数性能，我们增加缓存机制，将之前计算过的结果缓存起来，下次遇到同样的参数，就可以直接返回结果，而不需要参与运算。这里，存放缓存结果的变量不需要暴露给外界，并且需要在函数运行结束后，仍然保存，所以可以采用闭包。 上代码：123456789101112function calculate(param)&#123; var cache = &#123;&#125;; return function()&#123; if(!cache.parame)&#123; return cache.param; &#125;else&#123; //缓存计算.... //cache.param = result //下次访问直接取 &#125; &#125;&#125; 实际应用场景2 延续局部变量的寿命 img 对象经常用于进行数据上报，如下所示：12345var report = function( src )&#123; var img = new Image(); img.src = src;&#125;;report( 'http://xxx.com/getUserInfo' ); 但是通过查询后台的记录我们得知，因为一些低版本浏览器的实现存在 bug，在这些浏览器下使用 report 函数进行数据上报会丢失 30%左右的数据，也就是说， report 函数并不是每一次都成功发起了 HTTP 请求。 丢失数据的原因是 img 是 report 函数中的局部变量，当 report 函数的调用结束后， img 局部变量随即被销毁，而此时或许还没来得及发出 HTTP 请求，所以此次请求就会丢失掉。 现在我们把 img 变量用闭包封闭起来，便能解决请求丢失的问题：12345678var report = (function()&#123; var imgs = []; return function( src )&#123; var img = new Image(); imgs.push( img ); img.src = src; &#125;&#125;)(); 闭包缺点：浪费资源！ 3. 题目解答3.1 说一下对变量提升的理解变量定义和函数声明 注意函数声明和函数表达式的区别 变量定义时会默认把他的变量声明提升：(仅限于他的执行上下文，比如一段script和一个函数中) 12console.log(a);var a = 0; 实际上是 123var a;console.log(a);a = 0; 3.2 说明this的几种不同使用场景 构造函数中（指向构造的对象） 对象属性中（指向该对象） 普通函数中（指向window） call apply bind 3.3 创建10个a标签，点击的时候弹出来相应的序号实现方法1：用let声明i 12345678910var body = document.body;console.log(body);for (let i = 0; i &lt; 10; i++) &#123; let obj = document.createElement('i'); obj.innerHTML = i + '&lt;br&gt;'; body.appendChild(obj); obj.addEventListener('click',function()&#123; alert(i); &#125;)&#125; 实现方法2 包装作用域 123456789101112var body = document.body;console.log(body);for (var i = 0; i &lt; 10; i++) &#123; (function (i) &#123; var obj = document.createElement('i'); obj.innerHTML = i + '&lt;br&gt;'; body.appendChild(obj); obj.addEventListener('click', function () &#123; alert(i); &#125;) &#125;)(i)&#125; 3.4 实际开发中闭包的应用能够读取其他函数内部变量的函数 可以让函数内部的变量一直保存在内存中 封装变量，权限收敛 应用1 12345678var report = (function()&#123; var imgs = []; return function( src )&#123; var img = new Image(); imgs.push( img ); img.src = src; &#125;&#125;)(); 用于防止变量销毁。 应用2 123456789101112131415function isFirstLoad() &#123; var arr = []; return function (str) &#123; if (arr.indexOf(str) &gt;= 0) &#123; console.log(false); &#125; else &#123; arr.push(str); console.log(true); &#125; &#125;&#125;var fun = isFirstLoad();fun(10);fun(10); 将arr封装在函数内部，禁止随意修改，防止变量销毁。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.lisq.xyz/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://www.lisq.xyz/tags/基础/"},{"name":"面试","slug":"面试","permalink":"https://www.lisq.xyz/tags/面试/"},{"name":"作用域","slug":"作用域","permalink":"https://www.lisq.xyz/tags/作用域/"}]},{"title":"【前端面试】原型和原型链","slug":"【前端面试】原型和原型链","date":"2018-01-17T04:23:59.000Z","updated":"2018-11-09T14:34:29.954Z","comments":true,"path":"2018/01/17/【前端面试】原型和原型链/","link":"","permalink":"https://www.lisq.xyz/2018/01/17/【前端面试】原型和原型链/","excerpt":"","text":"1.题目 如何准确判断一个变量是数组 写一个原型链继承的例子 继承实现的其他方式 描述new一个对象的过程 zepto及其他源码中如何使用原型链 2.知识点2.1 构造函数特点：以大写字母开头 12345678910function Foo(name,age)&#123; //var obj = &#123;&#125; //this = &#123;&#125; this.name = name; this.age = age; this.class = 'class1' // return this&#125;var f1 = new Foo('liming',19); 扩展 var o = {} 是 var o = new Object() 的语法糖 var a = [] 是 var a = new Array() 的语法糖 function Foo(){} 相当于 var Foo = new Function(){} 2.2 原型规则五条规则： 1.所有引用类型（对象，数组，函数）都具有对象特性，即可以自由扩展属性 2.所有引用类型（对象，数组，函数）都具有一个proto（隐式原型）属性，是一个普通对象 3.所有的函数都具有prototype（显式原型）属性，也是一个普通对象 4.所有引用类型（对象，数组，函数）proto值指向它构造函数的prototype 5.当试图得到一个对象的属性时，如果变量本身没有这个属性，则会去他的proto中去找 1234567for (var key in object) &#123; //高级浏览器中已经屏蔽了来自原型的属性 //建议加上判断保证程序的健壮性 if (object.hasOwnProperty(key)) &#123; console.log(object[key]); &#125;&#125; 2.3 thisthis的几种使用场景 全局/函数 构造函数 对象 内部函数 call/apply 2.4 原型链obj. proto . proto . proto … Object.prototype === null instanceof 用于判断引用类型属于哪个构造函数 obj instanceob Foo 实际意义：判断 Foo.prototype 在不在 obj的原型链上 3.题目解答3.1 如何准确判断一个变量是数组arr instanceof Array 3.2 写一个原型链继承的例子封装dom查询 123456789101112131415161718192021222324function Elem(id)&#123; this.elem = document.getElementById(id);&#125;;Elem.prototype.html = function(val)&#123; var elem = this.elem; if (val) &#123; elem.innerHTML = val; return this; &#125;else&#123; return elem.innerHTML; &#125;&#125;Elem.prototype.on = function(type,fun)&#123; var elem = this.elem; elem.addEventListener(type,fun); return this;&#125;var div1 = new Elem('id1');div1.html(\"test\").on('click',function()&#123; console.log('点击');&#125;) 3.3 继承实现的其他方式3.3.1 原型继承1234567891011121314151617181920var obj = &#123; 0:'a', 1:'b', arr:[1]&#125;function Foo(arr2)&#123; this.arr2 = [1]&#125;Foo.prototype = obj;var foo1 = new Foo();var foo2 = new Foo();foo1.arr.push(2);foo1.arr2.push(2);console.log(foo2.arr); //[1,2]console.log(foo2.arr2); //[1] 优点：实现简单 缺点： 1.无法向父类构造函数传参 2.同时new两个对象时改变一个对象的原型中的引用类型的属性时，另一个对象的该属性也会修改。因为来自原型对象的引用属性是所有实例共享的。 3.3.2 构造继承1234567891011function Super(b)&#123; this.b = b; this.fun = function()&#123;&#125;&#125;function Foo(a,b)&#123; this.a = a; Super.call(this,b);&#125;var foo1 = new Foo(1,2);console.log(foo1.b); 优点：可以向父类传参，子类不会共享父类的引用属性 缺点：无法实现函数复用，每个子类都有新的fun，太多了就会影响性能，不能继承父类的原型对象。 3.3.3 组合继承1234567891011121314function Super()&#123; // 只在此处声明基本属性和引用属性 this.val = 1; this.arr = [1];&#125;// 在此处声明函数Super.prototype.fun1 = function()&#123;&#125;;Super.prototype.fun2 = function()&#123;&#125;;//Super.prototype.fun3...function Sub()&#123; Super.call(this); // 核心 // ...&#125;Sub.prototype = new Super(); 优点：不存在引用属性共享问题，可传参，函数可复用 缺点：父类的属性会被实例化两次，获取不到真正实例父类（无法区分实例是父类创建还是父类创建的） 优化： 12345678910111213141516 function Super(b)&#123; this.b = b; this.fun = function()&#123;&#125;&#125;Super.prototype.c = function()&#123;console.log(1111)&#125;function Foo(a,b)&#123; this.a = a; Super.call(this,b);&#125;Foo.prototype = Super.prototype;//修复构造函数：var foo1 = new Foo(1,2); 缺点：无法区分实例是父类创建还是子类创建的 3.3.4 寄生组合继承1234567891011121314151617 function Super(b)&#123; this.b = b;&#125;Super.prototype.c = function()&#123;console.log(1111)&#125;function Foo(a,b)&#123; this.a = a; Super.call(this,b);&#125;var f = new Function();f.prototype = Super.prototype;Foo.prototype = new f();//等同于 Foo.prototype = Object.create(Super.prototype);var foo1 = new Foo(1,2); 对父类的prototype进行一次寄生，即包装成一个空对象的prototype，再把这个对象实例化出来作为子类的peototype。 缺点：无法区分实例是父类创建还是子类创建的 可以添加以下代码： 1Foo.prototype.constructor = Foo 这种解决方法不能用于上面的组合优化方法，因为子类父类引用的是同一个原型对象，修改会同时修改。 总结： 继承主要是实现子类对父类方法，属性的复用。 来自原型对象的引用属性是所有实例共享的，所以我们要避免从原型中继承属性。 在构造函数中通过call函数可以继承父类构造函数的属性和方法，但是通过这种方式实例化出来的实例会将父类方法多次存储，影响性能。 通过组合继承我们使用call继承属性，使用原型继承方法，可以解决以上两个问题，但是通过这种方式实例化出来的对象会存储两份父类构造函数中的属性。 用父类的原型构造一个新对象作为子类的原型，就解决了多次存储的问题，所以最终的寄生组合继承就是最佳继承方式，它的缺点就是书写起来比较麻烦。 3.3.6 node源码中的继承实现12345678910111213141516171819202122232425function inherits(ctor, superCtor) &#123; ctor.super_ = superCtor; ctor.prototype = Object.create(superCtor.prototype, &#123; constructor: &#123; value: ctor, enumerable: false, writable: true, configurable: true &#125; &#125;);&#125;; function Stream()&#123; //...&#125;function OutgoingMessage() &#123; Stream.call(this); //...&#125;inherits(OutgoingMessage, Stream);OutgoingMessage.prototype.setTimeout = ... 以上是寄生组合继承的一个实例。 1.在OutgoingMessage构造函数中通过call继承Stream构造中的属性。 2.调用inherits方法继承Stream原型中的属性。 3.扩展OutgoingMessage自身原型的函数。 inherits方法中使用了Object.create方法,该方法的作用是通过指定的原型对象和属性创建一个新的对象。 1ctor.prototype=Object.create(superCtor.prototype,&#123;.....&#125;); 该方法实际上就做了我们上面寄生组合继承中的工作 123var f = new Function();f.prototype =superCtor.prototype;return new f(); 后面的参数是给原型对象添加属性,可选属性(非必填),即把自身作为新创建对象的构造函数。 1234value: 表示constructor 的属性值；writable: 表示constructor 的属性值是否可写；[默认为: false]enumerable: 表示属性constructor 是否可以被枚举；[默认为: false]configurable: 表示属性constructor 是否可以被配置，例如 对obj.a做 delete操作是否允许；[默认为: false] 3.4 描述new一个对象的过程 创建一个对象 {}.proto = 构造函数.prototype this指向这个对象 执行代码即对this赋值 返回this 3.5 zepto及其他源码中如何使用原型链123456789101112131415161718192021222324252627282930313233343536373839404142434445var Zepto = (function()&#123; var $,zepto = &#123;&#125; // ...省略N行代码... $ = function(selector, context)&#123; return zepto.init(selector, context) &#125; zepto.init = function(selector, context) &#123; var dom // 针对参数情况，分别对dom赋值 // 最终调用 zepto.Z 返回的数据 return zepto.Z(dom, selector) &#125; fnction Z(dom, selector) &#123; var i, len = dom ? dom.length : 0 for (i = 0; i &lt; len; i++) this[i] = dom[i] this.length = len this.selector = selector || '' &#125; zepto.Z = function(dom, selector) &#123; return new Z(dom, selector) &#125; $.fn = &#123; // 里面有若干个工具函数 &#125; zepto.Z.prototype = Z.prototype = $.fn // ...省略N行代码... return $&#125;)()window.Zepto = Zeptowindow.$ === undefined &amp;&amp; (window.$ = Zepto)","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.lisq.xyz/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://www.lisq.xyz/tags/基础/"},{"name":"面试","slug":"面试","permalink":"https://www.lisq.xyz/tags/面试/"},{"name":"原型链","slug":"原型链","permalink":"https://www.lisq.xyz/tags/原型链/"}]},{"title":"【个人博客搭建及配置七】seo优化","slug":"【个人博客搭建及配置七】seo优化","date":"2018-01-05T09:39:37.000Z","updated":"2018-11-05T15:59:31.716Z","comments":true,"path":"2018/01/05/【个人博客搭建及配置七】seo优化/","link":"","permalink":"https://www.lisq.xyz/2018/01/05/【个人博客搭建及配置七】seo优化/","excerpt":"","text":"博客地址： https://www.lisq.xyz/ SEO是由英文Search Engine Optimization缩写而来， 中文意译为“搜索引擎优化”。SEO是指通过站内优化比如网站结构调整、网站内容建设、网站代码优化等以及站外优化。 简而言之，就是让人们更容易搜索到你的站点。 首先要做的就是让搜索引擎收录我们的站点。 1.百度1.1 提交网址在搜索引擎中输入site:&lt;域名&gt;,如果如下图所示就是说明我们的网站并没有被百度收录。我们可以直接点击下面的“网址提交”来提交我们的网站 然后点击途中的提交网址 选择站点的相关属性： 接下来进行网站验证，推荐使用第三种GNAME验证，简单快捷，只需要给你的链接增加一条解析即可: 1.2 生成网站地图接下来要让你的网站生成网站地图，及生产sitemap，将sitemap提交到百度，先安装地图生成插件： 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 注意根目录的_config.yml将url配置成你的站点1234# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://lisq.xyz/root: / 重新部署博客后就会生成两个新文件sitemap.xml和baidusitemap.xml 1.3 将sitemap提交给百度点击链接提交 使用主动推送 主动推送安装插件npm install hexo-baidu-url-submit –save然后再根目录的配置文件中新增字段12345baidu_url_submit: count: 100 host: https://lisq.xyz/ token: 8OGYpxowYnhgVsUM path: baidu_urls.txt # 文本文档的地址 在加入新的deploye12deploy: - type:baidu_url_submitter 百度收录的时间非常长，耐心等待吧。 2.谷歌点击这里添加你的网址 点击添加属性后即可添加你的博客地址。 进行验证： 谷歌收录的速度还是相当快的，而且操作比较简单。","categories":[],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.lisq.xyz/tags/博客搭建/"},{"name":"seo","slug":"seo","permalink":"https://www.lisq.xyz/tags/seo/"}]},{"title":"【个人博客搭建及配置六】评论系统","slug":"【个人博客搭建及配置六】评论系统","date":"2018-01-02T10:44:32.000Z","updated":"2018-11-05T15:39:23.193Z","comments":true,"path":"2018/01/02/【个人博客搭建及配置六】评论系统/","link":"","permalink":"https://www.lisq.xyz/2018/01/02/【个人博客搭建及配置六】评论系统/","excerpt":"","text":"博客地址： https://www.lisq.xyz/ 博客使用valine作为评论工具，原因是他使用简介，体积轻量，灵活配置，速度很快！ 1.注册LeanCloudvaline接住了LeanCloud的力量，所以需要LeanCloud的APP ID 和 APP Key 首先注册和登录LeanCloud 创建一个应用： 应用创建好以后，进入刚刚创建的应用，选择左下角的设置&gt;应用Key，然后就能看到你的APP ID和APP Key了： 代码将如下代码插入你的文章模板中 1234567891011121314151617&lt;head&gt; ... &lt;script src=&quot;//cdn1.lncld.net/static/js/3.0.4/av-min.js&quot;&gt;&lt;/script&gt; &lt;script src=&apos;//unpkg.com/valine/dist/Valine.min.js&apos;&gt;&lt;/script&gt; ...&lt;/head&gt;&lt;body&gt; ... &lt;div id=&quot;vcomments&quot;&gt;&lt;/div&gt; &lt;script&gt; new Valine(&#123; el: &apos;#vcomments&apos;, appId: &apos;&lt;API_ID&gt;&apos;, appKey: &apos;&lt;API_Key&gt;&apos; &#125;) &lt;/script&gt;&lt;/body&gt; 配置好这些，等待两分钟，就可以在文章里使用你的评论啦。 数据管理由于Valine 是无后端评论系统，所以也就没有开发评论数据管理功能。 可以在leanCloud中管理评论 1登录&gt;选择你创建的应用&gt;存储&gt;选择Class Comment 安全域名为了数据安全，在leanCloud中配置你的安全域名 配置项Valine还有一些其他的配置项 123456789new Valine(&#123; el: &apos;#vcomments&apos; , appId: &apos;&lt;APP_ID&gt;&apos;, appKey: &apos;&lt;APP_KEY&gt;&apos;, notify:false, verify:false, avatar:&apos;mm&apos;, placeholder: &apos;just go go&apos; &#125;); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788placeholder类型:String默认值:Just go go必要性:false评论框占位提示符。notify类型:Boolean默认值:false必要性:false评论回复邮件提醒，请参考配置。verify类型:Boolean默认值:false必要性:false验证码服务。path类型:String默认值:window.location.pathname必要性:false当前文章页路径，用于区分不同的文章页，以保证正确读取该文章页下的评论列表。可选值：window.location.pathname (默认值，推荐)window.location.href自定义I. 请保证每个文章页路径的唯一性，否则可能会出现不同文章页下加载相同评论列表的情况。II. 如果值为window.location.href，可能会出现随便加不同参数进入该页面，而被判断成新页面的情况。avatar类型:String默认值:mm必要性:falseGravatar 头像展示方式。可选值：&apos;&apos;(空字符串)mpidenticonmonsteridwavatarretrorobohashhide更多信息，请查看头像配置。meta类型:Array默认值:[&apos;nick&apos;,&apos;mail&apos;,&apos;link&apos;]必要性:false评论者相关属性。pageSize类型:Number默认值:10必要性:false评论列表分页，每页条数。lang类型:String默认值:zh-cn必要性:false多语言支持。可选值：zh-cnen如需自定义语言，请参考i18n。visitor类型:Boolean默认值:false必要性:false文章访问量统计。highlight类型：Boolean默认值: true必要性: false代码高亮，默认开启，若不需要，请手动关闭avatarForce类型: Boolean默认值: false必要性: false","categories":[],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.lisq.xyz/tags/博客搭建/"}]},{"title":"【个人博客搭建及配置五】阅读统计","slug":"【个人博客搭建及配置五】阅读统计","date":"2018-01-02T07:06:53.000Z","updated":"2018-11-05T15:38:07.315Z","comments":true,"path":"2018/01/02/【个人博客搭建及配置五】阅读统计/","link":"","permalink":"https://www.lisq.xyz/2018/01/02/【个人博客搭建及配置五】阅读统计/","excerpt":"","text":"博客地址： https://www.lisq.xyz/ 这里的统计是用来展示在页面上的，可以标示文章以及博客的热度。 使用不蒜子来展示文章访问统计和页面访问统计。 1.引入不蒜子将不蒜子js文件引入博客主题公共组件中。 1&lt;script async src=\"//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt; 这里我同站长统计一样放在themes/hueman/common/footer.ejs 2.文章访问统计要显示每篇文章的访问量，复制以下代码添加到你需要显示的位置。 可以在标签上自定义一些样式。 算法：pv的方式，单个用户点击1篇文章，本篇文章记录1次阅读量。 123&lt;span id=\"busuanzi_container_page_pv\"&gt; 本文总阅读量&lt;span id=\"busuanzi_value_page_pv\"&gt;&lt;/span&gt;次&lt;/span&gt; 3.整站访问统计算法a：pv的方式，单个用户连续点击n篇文章，记录n次访问量。 123&lt;span id=\"busuanzi_container_site_pv\"&gt; 本站总访问量&lt;span id=\"busuanzi_value_site_pv\"&gt;&lt;/span&gt;次&lt;/span&gt; 算法b：uv的方式，单个用户连续点击n篇文章，只记录1次访客数。123&lt;span id=\"busuanzi_container_site_uv\"&gt; 本站访客数&lt;span id=\"busuanzi_value_site_uv\"&gt;&lt;/span&gt;人次&lt;/span&gt;","categories":[],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.lisq.xyz/tags/博客搭建/"}]},{"title":"【个人博客搭建及配置四】站长统计","slug":"【个人博客搭建及配置四】站长统计","date":"2018-01-02T03:15:50.000Z","updated":"2018-11-05T15:37:10.070Z","comments":true,"path":"2018/01/02/【个人博客搭建及配置四】站长统计/","link":"","permalink":"https://www.lisq.xyz/2018/01/02/【个人博客搭建及配置四】站长统计/","excerpt":"","text":"博客地址： https://www.lisq.xyz/ 使用一个站长统计工具，可以为博客添加一个如上面似的详细的访问报表。 站长统计工具有很多，每个工具大同小异，这里我选择了CNZZ。 CNZZ配置1.注册一个账号。 2.添加网站。 按照如下要求添加网站 3.选择统计代码 添加完网站后就可以选择一段代码插入你的博客里了，CNZZ提供了几种样式，你可以选择展示真实的统计数量，一个cnzz图标或者什么都不显示。 代码配置将上面复制的代码插入到你主题代码的公共区域中。 每个主题的代码都不一样，但是大体结构是相同的，都会将通用的组件抽取出来。 这里我找到了每个页面都使用的footer组件，我使用的是hueman主题，代码在themes/hueman/common/footer.ejs 在此文件中找到合适的位置插入你的统计代码。 比如我的（script内的部分）：","categories":[],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.lisq.xyz/tags/博客搭建/"}]},{"title":"【个人博客搭建及配置三】同时托管到github和coding上","slug":"【个人博客搭建及配置三】同时托管到github和coding上","date":"2018-01-02T02:34:06.000Z","updated":"2018-11-08T04:01:31.309Z","comments":true,"path":"2018/01/02/【个人博客搭建及配置三】同时托管到github和coding上/","link":"","permalink":"https://www.lisq.xyz/2018/01/02/【个人博客搭建及配置三】同时托管到github和coding上/","excerpt":"","text":"博客地址： https://www.lisq.xyz/ github page毕竟是国外站点，访问速度相对来说比较慢，但是同时你又想在gihub上保存一下代码，可以尝试同时托管两个仓库。 做解析的时候海外的ip 指向到github，国内的或者说百度的直接指向coding。 1.在coding上提交代码首先做的操作和github是一样的，就是创建一个ssh。 这里要注意的是，你的电脑上已经有了gihub的ssh，如果还像github一样一路回车会把gihub的ssh给覆盖掉。 所以这里在执行 1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 时要注意，给生成的文件配置一个新路径： 然后配置生成的ssh 在coding中创建一个仓库，这里注意仓库的名字可以随意取，不像gihub一样可以随意给定。 将创建仓库的git地址添加到_config.yml中： 123456deploy: type: git repo: github: https://github.com/ConardLi/ConardLi.github.io.git coding: https://git.dev.tencent.com/ConardLi/lisqBlog.git branch: master 然后重新部署并上传博客，去仓库查看代码证明上传成功： 2.开启coding page点击coding的pages服务，直接点击一键开启即可。 开启后即可通过给定域名直接访问了： http://conardli.coding.me/ 3.域名解析将新生成的coding域名进行解析，这样国内就默认访问coding的页面，比github要快不少。 另外还可以将github的ip进行国外站点配置。 在coding page中将自己的域名进行绑定。 配置完成后发现速度快了不少，有木有… https://www.lisq.xyz/","categories":[],"tags":[{"name":"版本控制","slug":"版本控制","permalink":"https://www.lisq.xyz/tags/版本控制/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.lisq.xyz/tags/博客搭建/"},{"name":"github","slug":"github","permalink":"https://www.lisq.xyz/tags/github/"}]},{"title":"【个人博客搭建及配置二】绑定个人域名","slug":"【个人博客搭建及配置二】绑定个人域名","date":"2018-01-01T15:28:31.000Z","updated":"2018-11-05T15:35:02.609Z","comments":true,"path":"2018/01/01/【个人博客搭建及配置二】绑定个人域名/","link":"","permalink":"https://www.lisq.xyz/2018/01/01/【个人博客搭建及配置二】绑定个人域名/","excerpt":"","text":"博客地址： https://www.lisq.xyz/ 1.购买一个域名这里我选择的是阿里云，挑选一个自己喜欢的域名购买。 2.域名解析进入控制台添加域名解析。 按照如下规则添加两条记录。 这时去访问解析好的域名会出现如下页面。 这说明域名解析没有问题，接下来进入github进行配置 3.hexo配置在本地的博客目录中找到source文件夹。 新建一个没有后缀名的文件GNAME 在文件中添加你的域名，如： 1lisq.xyz 保存后重新生成，并提交你的博客。 4.github配置在github中找到你的博客仓库。 点击12找到```Custom domain 输入你的域名点击save 然后你就可以在浏览器用你的域名愉快的访问啦！","categories":[],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.lisq.xyz/tags/博客搭建/"}]},{"title":"【个人博客搭建及配置一】基础配置","slug":"【个人博客搭建及配置一】基础配置","date":"2018-01-01T12:13:20.000Z","updated":"2018-11-05T15:27:04.665Z","comments":true,"path":"2018/01/01/【个人博客搭建及配置一】基础配置/","link":"","permalink":"https://www.lisq.xyz/2018/01/01/【个人博客搭建及配置一】基础配置/","excerpt":"","text":"博客地址： https://www.lisq.xyz/ 1.本地安装hexo首先保证你电脑上有node环境，这个不懂的可以自定百度。 控制台输入node -v出现版本号说明安装成功。 有了node就可以安装hexo了，控制台输入如下命令 1npm i -g hexo 同样控制台输入hexo -v出现版本号说明安装成功。 然后开始初始化项目，控制台输入： 1hexo init 得到如下项目目录： 12345678node_modules：是依赖包public：存放的是生成的页面scaffolds：命令生成文章等的模板source：用命令创建的各种文章themes：主题_config.yml：整个博客的配置db.json：source解析所得到的package.json：项目所需模块项目的配置信息 2.本地运行首先在本地跑起来你的代码 控制台安装hexo-server 1npm i hexo-server 然后运行 hexo-server 在浏览器中访问：http://localhost:4000就可以看到你本定运行的页面了 这时你可以在本地调试一下你的blog。 3.github配置首先要创建一个github账号 并配置好ssh 这些不懂的可以自行百度。 创建一个repo，名称为yourname.github.io, 其中yourname是你的github名称，按照这个规则创建github page才会生效。 修改_config.yml中的git配置 1234deploy: type: git repo: https://github.com/xxxx.git branch: master 4.部署上传在本地安装上传工具 1npm install hexo-deployer-git --save 依次执行如下命令 123hexo clean //删除上次打包hexo generate //打包hexo deploy /上传 这里我单独写了sh执行这三段脚本，这样每次只需要执行这个sh即可。 在浏览器中输入http://yourgithubname.github.io就可以看到你的个人博客了！ 一些其他配置搜索功能使用搜索功能首先需要： 1npm install -S hexo-generator-json-content 然后： 12search: insight: true readme1.首先在source文件夹下建立一个README.md 2.修改_config.yml 1skip_render: README.md","categories":[],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.lisq.xyz/tags/博客搭建/"},{"name":"github","slug":"github","permalink":"https://www.lisq.xyz/tags/github/"}]},{"title":"【前端面试】变量和类型计算","slug":"【前端面试】变量和类型计算","date":"2017-12-27T14:28:48.000Z","updated":"2019-01-03T10:48:03.198Z","comments":true,"path":"2017/12/27/【前端面试】变量和类型计算/","link":"","permalink":"https://www.lisq.xyz/2017/12/27/【前端面试】变量和类型计算/","excerpt":"","text":"1.题目 1.JS使用typeof能得到哪些类型 === 和 == 的选择 JS中有哪些内置函数 JS变量按存储方式分为哪些类型，并描述其特点 如何理解JSON 2.知识点2.1 值类型和引用类型值类型（boolean,string,number,null,undefined） 1234var a = 10;var b = a;a = 20;console.log(b); //10 引用类型（对象，数组，函数） 1234var a = &#123;x:10&#125;var b = a;a.x = 20;console.log(b); //20 值类型直接把值存储在堆中，把a赋值给b在内存中是又给b开辟了一块新的空间，存储了同样的值。 引用类型分两块存储，先在堆中存储一个实际的值，再在栈中存储一个堆中值的引用地址，指向堆中的对象。把a赋值给b是在栈中重新开辟一块空间存储的还是相同对象的引用地址，a和b存储的地址相同，指向的对象也相同。当对象值发生改变时，两者会同时改变。 引用类型的值一般都比较大，采用此种存储方式可以节省内存空间。 2.2 typeof运算符12345678typeof 'abc' //stringtypeof 123 //numbertypeof true //booleantypeof undefined //undefinedtypeof null //objecttypeof &#123;a:10&#125; //objecttypeof [1,2,3] //objecttypeof console.log() //function 2.3 类型转换强类型转换：通过String（），Number（），Boolean（），parseInt（）函数强制转换 可能发生隐式类型转换的场景 字符串拼接 使用== if语句 逻辑循环 一、首先看双等号前后有没有NaN，如果存在NaN，一律返回false。 二、再看双等号前后有没有布尔，有布尔就将布尔转换为数字。（false是0，true是1） 三、接着看双等号前后有没有字符串, 有三种情况： 1、对方是对象，对象使用toString()或者valueOf()进行转换；2、对方是数字，字符串转数字；（前面已经举例）3、对方是字符串，直接比较；4、其他返回false四、如果是数字，对方是对象，对象取valueOf()或者toString()进行比较, 其他一律返回false 五、null, undefined不会进行类型转换, 但它们俩相等 上面的转换顺序一定要牢记，面试的时候，经常会出现类型的问题。 12345678910'100'==100 //转换成字符串''==0 //转换成falseundefined == null; // true1 == true; // true2 == true; // false0 == false; // true0 == ' '; // trueNaN == NaN; // false[] == false; // true[] == ![]; // true 1234567//在if中转换成false的：nullundefined''NaN0false 12310 &amp;&amp; 0 //0 10转换成true'' || 'abc' //abc ''转换成false!window.abc //true 2.4 null和undefined的区别null：是被赋值过的对象，刻意把一个对象赋值为null，故意表示其为空，不应有值，所以对象为null是正常的，typeof null 返回 ‘object’ ，null可以转换为0 undefined 表示“缺少值”，即此处应有一个值，但还没有定义；转为数值时为NaN(非数字值的特殊值) typeof undefined 返回 ‘undefined’ 3.题目解答3.1 JS使用typeof能得到哪些类型12345678typeof 'abc' //stringtypeof 123 //numbertypeof true //booleantypeof undefined //undefinedtypeof null //objecttypeof &#123;a:10&#125; //objecttypeof [1,2,3] //objecttypeof console.log() //function 3.2 === 和 == 的选择jquery源码中的写法： 除了以下方式其他全部使用 === 123if(obj.a == null)&#123; //相当于 obj.a === undefined || obj.a === null&#125; 3.3 JS中有哪些内置函数单纯作为语言来说，不考虑node和浏览器web Object Array Boolean Number String Function Date RegExp Error 内置对象：Math,JSON 3.4 JS变量按存储方式分为哪些类型，并描述其特点值类型何引用类型 3.5 如何理解JSONJSON是JS中的一个内置对象 区别 JS对象 {x:10} JSON对象 {‘x’:10} JSON串 “{‘x’:10}” 1234//将JS对象转换成json串JSON.stringify(&#123;x:10&#125;);//将json字符串转换成json对象JSON.parse(\"&#123;'x':10&#125;\"); 3.6 严格模式目的 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的Javascript做好铺垫。 特性 1 \"use strict\"; 可以选择放在一个函数中或自定义作用域中。 禁止this指向全局对象 123456789 function f()&#123; return !this; &#125; // 返回false，因为\"this\"指向全局对象，\"!this\"就是false function f()&#123; \"use strict\"; return !this; &#125; // 返回true，因为严格模式下，this的值为undefined，所以\"!this\"为true。 创设eval作用域 正常模式下，Javascript语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：eval作用域。正常模式下，eval语句的作用域，取决于它处于全局作用域，还是处于函数作用域。严格模式下，eval语句本身就是一个作用域，不再能够生成全局变量了，它所生成的变量只能用于eval内部。 1234 \"use strict\"; var x = 2; console.info(eval(\"var x = 5; x\")); // 5 console.info(x); // 2 全局变量显式声明 123 v = 1; // 报错，v未声明 for(i = 0; i &lt; 2; i++) &#123; // 报错，i未声明 &#125; 禁止删除变量 严格模式下无法删除变量。只有configurable设置为true的对象属性，才能被删除。 12345678 \"use strict\"; var x; delete x; // 语法错误 var o = Object.create(null, &#123;'x': &#123; value: 1, configurable: true &#125;&#125;); delete o.x; // 删除成功 函数不能有重名的参数 保留字 为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。使用这些词作为变量名将会报错。1234 function package(protected) &#123; // 语法错误 \"use strict\"; var implements; // 语法错误 &#125; 3.7 eval1.没有必须使用的应用场景 2.不容易调试，可读性不好 3.在旧的浏览器中如果你使用了eval，性能会下降10倍。 4.容易xss 前端基础知识面试，万变不离其宗。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://www.lisq.xyz/tags/javascript/"},{"name":"基础","slug":"基础","permalink":"https://www.lisq.xyz/tags/基础/"},{"name":"面试","slug":"面试","permalink":"https://www.lisq.xyz/tags/面试/"}]},{"title":"vue问题记录","slug":"vue问题记录","date":"2017-12-24T05:26:55.000Z","updated":"2018-12-31T14:49:40.279Z","comments":true,"path":"2017/12/24/vue问题记录/","link":"","permalink":"https://www.lisq.xyz/2017/12/24/vue问题记录/","excerpt":"","text":"vue生命周期https://segmentfault.com/a/1190000008010666 v-show和v-if指令的共同点和不同点?v-show指令是通过修改元素的displayCSS属性让其显示或者隐藏 v-if指令是直接销毁和重建DOM达到让元素显示和隐藏的效果 如何让CSS只在当前组件中起作用?将当前组件的12修改为```&lt;style scoped&gt; 的作用是什么?大白话: 比如有一个列表和一个详情，那么用户就会经常执行打开详情=&gt;返回列表=&gt;打开详情…这样的话列表和详情都是一个频率很高的页面，那么就可以对列表组件使用进行缓存，这样用户每次返回列表的时候，都能从缓存中快速渲染，而不是重新渲染 vue中使用组件1.采用ES6的import … from …语法或CommonJS的require()方法引入组件 2.对组件进行注册,代码如下1234// 注册Vue.component('my-component', &#123; template: '&lt;div&gt;A custom component!&lt;/div&gt;'&#125;) 3.使用组件 使用插件采用ES6的import … from …语法或CommonJSd的require()方法引入插件 使用全局方法Vue.use( plugin )使用插件,可以传入一个选项对象Vue.use(MyPlugin, { someOption: true }) 如使用vue-router，vue-resource插件 组件通信父组件向子组件先定义一个子组件，在组件中注册props 12345678910111213&lt;template&gt; &lt;div&gt; &lt;div&gt;&#123;&#123;message&#125;&#125;(子组件)&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; message: String //定义传值的类型&lt;br&gt; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 在父组件中，引入子组件，并传入子组件内需要的值 1234567891011121314151617181920212223&lt;template&gt; &lt;div&gt; &lt;div&gt;父组件&lt;/div&gt; &lt;child :message=\"parentMsg\"&gt;&lt;/child&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt; import child from './child' //引入child组件export default &#123; data() &#123; return &#123; parentMsg: 'a message from parent' //在data中定义需要传入的值 &#125; &#125;, components: &#123; child &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 子组件向父组件12345678910子组件:&lt;template&gt; &lt;div @click=\"up\"&gt;&lt;/div&gt;&lt;/template&gt;methods: &#123; up() &#123; this.$emit('upup','hehe'); //主动触发upup方法，'hehe'为向父组件传递的数据 &#125;&#125; 12345678&lt;div&gt; &lt;child @upup=\"change\" :msg=\"msg\"&gt;&lt;/child&gt; //监听子组件触发的upup事件,然后调用change方法&lt;/div&gt;methods: &#123; change(msg) &#123; this.msg = msg; &#125;&#125; 兄弟组件通信组件1触发：123456&lt;div @click=\"eve\"&gt;&lt;/div&gt;methods: &#123; eve() &#123; Hub.$emit('change','hehe'); //Hub触发事件 &#125;&#125; 组件2接收:123456&lt;div&gt;&lt;/div&gt;created() &#123; Hub.$on('change', () =&gt; &#123; // Hub接收事件 this.msg = 'hehe'; &#125;);&#125; 这样就实现了非父子组件之间的通信了.原理就是把Hub当作一个中转站！ computed 和 watch12345678910111213141516 new Vue(&#123; el: '#myDiv', data: &#123; firstName: 'Foo', lastName: 'Bar', fullName: 'Foo Bar' &#125;, watch: &#123; firstName: function (val) &#123; this.fullName = val + ' ' + this.lastName &#125;, lastName: function (val) &#123; this.fullName = this.firstName + ' ' + val &#125; &#125;&#125;) 12345678910111213new Vue(&#123; el:\"#myDiv\", data:&#123; firstName:\"Den\", lastName:\"wang\", &#125;, computed:&#123; fullName:function()&#123; return this.firstName + \" \" +this.lastName; &#125; &#125; &#125;) 12345678910111213computed:&#123; fullName:&#123; //这里用了es6书写方法 set()&#123; alert(\"set\"); &#125;, get()&#123; alert(\"get\"); return this.firstName + \" \" +this.lastName; &#125;, &#125; &#125; 1.从属性名上，computed是计算属性，也就是依赖其它的属性计算所得出最后的值。watch是去监听一个值的变化，然后执行相对应的函数。 2.从实现上，computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时才会重新调用对应的getter来计算。watch在每次监听的值变化时，都会执行回调。其实从这一点来看，都是在依赖的值变化之后，去执行回调。很多功能本来就很多属性都可以用，只不过有更适合的。如果一个值依赖多个属性（多对一），用computed肯定是更加方便的。如果一个值变化后会引起一系列操作，或者一个值变化会引起一系列值的变化（一对多），用watch更加方便一些。 3.watch的回调里面会传入监听属性的新旧值，通过这两个值可以做一些特定的操作。computed通常就是简单的计算。 4.watch和computed并没有哪个更底层，watch内部调用的是vm.$watch，它们的共同之处就是每个定义的属性都单独建立了一个Watcher对象。","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.lisq.xyz/tags/vue/"}]},{"title":"webpack使用小结","slug":"webpack小结","date":"2017-12-06T12:10:06.000Z","updated":"2018-10-29T12:12:03.505Z","comments":true,"path":"2017/12/06/webpack小结/","link":"","permalink":"https://www.lisq.xyz/2017/12/06/webpack小结/","excerpt":"","text":"1.将图片输出成base64，减少http请求2.loadercss-loader,style-loader:两个建议配合使用，用来解析css文件，能够解释@import,url()如果需要解析less就在后面加一个less-loader babel-loader： 让下一代的js文件转换成现代浏览器能够支持的JS文件 pluginExtractTextWebpackPlugin: 它会将入口中引用css文件，都打包都独立的css文件中，而不是内嵌在js打包文件中。 123456789101112131415161718192021var ExtractTextPlugin = require('extract-text-webpack-plugin') var lessRules = &#123; use: [ &#123;loader: 'css-loader'&#125;, &#123;loader: 'less-loader'&#125; ] &#125; var baseConfig = &#123; // ... module: &#123; rules: [ // ... &#123;test: /\\.less$/, use: ExtractTextPlugin.extract(lessRules)&#125; ] &#125;, plugins: [ new ExtractTextPlugin('main.css') ] &#125; entryoutput: 即使入口文件有多个，但是只有一个输出配置1234567891011var path = require('path') var baseConfig = &#123; entry: &#123; main: './src/index.js' &#125;, output: &#123; filename: 'main.js', path: path.resolve('./build') &#125; &#125; module.exports = baseConfig 1234output: &#123; filename: '[name].js', path: path.resolve('./build') &#125; 开发环境和生产环境在开发时，不可避免会产生大量debug又或是测试的代码，这些代码不应出现在生产环境中（也即不应提供给用户）。 在把页面部署到服务器时，为了追求极致的技术指标，我们会对代码进行各种各样的优化，比如说混淆、压缩，这些手段往往会彻底破坏代码本身的可读性，不利于我们进行debug等工作。 数据源的差异化，比如说在本地开发时，读取的往往是本地mock出来的数据，而正式上线后读取的自然是API提供的数据了。 把原来开发用的的webpack.config.js改成webpack.dev.config.js，并备份一份命名为webpack.prod.config.js。修改package.json和server中对配置文件的引用。 然后针对生成环境的配置文件做一些修改，主要涉及导出目录、代码混淆、去除冗余代码等相关配置。用到了以下插件：1234DefinePlugin：定义环境变量webpack.LoaderOptionsPlugin：去除调试代码，压缩代码webpack.optimize.UglifyJsPlugin：针对JS的混淆配置CopyWebpackPlugin：复制手动引入的资源文件到指定目录 原理Webpack的核心原理Webpack的两个最核心的原理分别是： 一切皆模块 正如js文件可以是一个“模块（module）”一样，其他的（如css、image或html）文件也可视作模 块。因此，你可以require(‘myJSfile.js’)亦可以require(‘myCSSfile.css’)。这意味着我们可以将事物（业务）分割成更小的易于管理的片段，从而达到重复利用等的目的。 按需加载 传统的模块打包工具（module bundlers）最终将所有的模块编译生成一个庞大的bundle.js文件。但是在真实的app里边，“bundle.js”文件可能有10M到15M之大可能会导致应用一直处于加载中状态。因此Webpack使用许多特性来分割代码然后生成多个“bundle”文件，而且异步加载部分代码以实现按需加载。 打包原理每个文件都是一个资源，可以用require/import导入js 每个入口文件会把自己所依赖(即require)的资源全部打包在一起，一个资源多次引用的话，只会打包一份 对于多个入口的情况，其实就是分别独立的执行单个入口情况，每个入口文件不相干 把所有依赖打包成一个bundle.js文件，通过代码分割成单元片段并按需加载。 如图，entry.js是入口文件，调用了util1.js和util2.js，而util1.js又调用了util2.js。 打包后的bundle.js例子 1234567891011121314151617181920212223242526/******/ ([/* 0 */ //模块id/***/ function(module, exports, __webpack_require__) &#123; __webpack_require__(1); //require资源文件id __webpack_require__(2);/***/ &#125;,/* 1 *//***/ function(module, exports, __webpack_require__) &#123; //util1.js文件 __webpack_require__(2); var util1=1; exports.util1=util1;/***/ &#125;,/* 2 *//***/ function(module, exports) &#123; //util2.js文件 var util2=1; exports.util2=util2;/***/ &#125;....../******/ ]); 1.bundle.js是以模块 id 为记号，通过函数把各个文件依赖封装达到分割效果，如上代码 id 为 0 表示 entry 模块需要的依赖， 1 表示 util1模块需要的依赖 2.require资源文件 id 表示该文件需要加载的各个模块，如上代码_webpack_require__(1) 表示 util1.js 模块，webpack_require(2) 表示 util2.js 模块 3.exports.util1=util1 模块化的体现，输出该模块","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://www.lisq.xyz/tags/webpack/"},{"name":"打包工具","slug":"打包工具","permalink":"https://www.lisq.xyz/tags/打包工具/"}]},{"title":"vue双向绑定浅析","slug":"vue双向绑定浅析","date":"2017-12-02T13:53:09.000Z","updated":"2018-10-28T14:26:22.821Z","comments":true,"path":"2017/12/02/vue双向绑定浅析/","link":"","permalink":"https://www.lisq.xyz/2017/12/02/vue双向绑定浅析/","excerpt":"","text":"原理数据劫持: vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 实现流程1、实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者 2、实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数 3、实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图 4、mvvm入口函数，整合以上三者 实现Observer可以利用Obeject.defineProperty()来监听属性变动那么将需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。。相关代码可以是这样： 12345678910111213141516171819202122232425262728var data = &#123;name: 'kindeng'&#125;;observe(data);data.name = 'dmq'; // 哈哈哈，监听到值变化了 kindeng --&gt; dmqfunction observe(data) &#123; if (!data || typeof data !== 'object') &#123; return; &#125; // 取出所有属性遍历 Object.keys(data).forEach(function(key) &#123; defineReactive(data, key, data[key]); &#125;);&#125;;function defineReactive(data, key, val) &#123; observe(val); // 监听子属性 Object.defineProperty(data, key, &#123; enumerable: true, // 可枚举 configurable: false, // 不能再define get: function() &#123; return val; &#125;, set: function(newVal) &#123; console.log('哈哈哈，监听到值变化了 ', val, ' --&gt; ', newVal); val = newVal; &#125; &#125;);&#125; depdep的作用是消息订阅器，很简单，维护一个数组，用来收集订阅者，数据变动触发notify，再调用订阅者的update方法 compliecompile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图 因为遍历解析的过程有多次操作dom节点，为提高性能和效率，会先将跟节点el转换成文档碎片fragment进行解析编译操作，解析完成，再将fragment添加回原来的真实dom节点中。 12345678910111213141516171819function Compile(el) &#123; this.$el = this.isElementNode(el) ? el : document.querySelector(el); if (this.$el) &#123; this.$fragment = this.node2Fragment(this.$el); this.init(); this.$el.appendChild(this.$fragment); &#125;&#125;Compile.prototype = &#123; init: function() &#123; this.compileElement(this.$fragment); &#125;, node2Fragment: function(el) &#123; var fragment = document.createDocumentFragment(), child; // 将原生节点拷贝到fragment while (child = el.firstChild) &#123; fragment.appendChild(child); &#125; return fragment; &#125;&#125;; compileElement方法将遍历所有节点及其子节点，进行扫描解析编译，调用对应的指令渲染函数进行数据渲染，并调用对应的指令更新函数进行绑定。遍历后将自己每一个元素作为一个订阅者添加到dep的数组中。 在compileElement中做监听，值改变了再去改变MVVM的值。 watcher1、在自身实例化时往属性订阅器(dep)里面添加自己 2、自身必须有一个update()方法 3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调 主要作用是将元素封装成一个订阅对象，内含有updae函数，从而把自身加入到订阅器列表中作为订阅者。","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.lisq.xyz/tags/vue/"},{"name":"双向绑定","slug":"双向绑定","permalink":"https://www.lisq.xyz/tags/双向绑定/"},{"name":"数据流","slug":"数据流","permalink":"https://www.lisq.xyz/tags/数据流/"}]},{"title":"前端常见算法","slug":"前端常见算法","date":"2017-11-09T05:44:18.000Z","updated":"2018-10-28T14:28:26.377Z","comments":true,"path":"2017/11/09/前端常见算法/","link":"","permalink":"https://www.lisq.xyz/2017/11/09/前端常见算法/","excerpt":"","text":"判断回文123function checkPalindrom(str) &#123; return str == str.split('').reverse().join('');&#125; 去掉一组整型数组重复的值123比如输入: [1,13,24,11,11,14,1,2] 输出: [1,13,24,11,14,2]需要去掉重复的11 和 1 这两个元素。 方法1：使用object 考察个人对Object的使用，利用key来进行筛选。 1234567891011function unique(arr)&#123; var hasTable = &#123;&#125;; var result = []; for (let i = 0; i &lt; arr.length; i++) &#123; if(!hasTable[arr[i]])&#123; result.push(arr[i]); hasTable[arr[i]] = true; &#125; &#125; return result;&#125; 方法2：使用indexOf(IE8以下不支持)1234567function unique1(array) &#123; var n = []; for (var i = 0; i &lt; array.length; i++) &#123; if (n.indexOf(array[i]) == -1) n.push(array[i]); &#125; return n;&#125; 方法3：利用filter方法 判断数据元素是不是第一次出现 123var r = arr.filter(function (element, index, self) &#123; return self.indexOf(element) === index;&#125;); 统计一个字符串出现最多的字母123输入 ： afjghdfraaaasdenas 输出 ： a 1234567891011121314151617181920212223function findMaxChar(str) &#123; var arr = str.split(''); var countObj = &#123;&#125;; for (let i = 0; i &lt; arr.length; i++) &#123; const element = arr[i]; if (countObj[element]) &#123; countObj[element]++; &#125; else &#123; countObj[element] = 1; &#125; &#125; let maxNum = 0, maxValue = ''; for (const key in countObj) &#123; if (countObj.hasOwnProperty(key)) &#123; const element = countObj[key]; if(element&gt;maxNum)&#123; maxNum = element; maxValue = key; &#125; &#125; &#125; return maxValue;&#125; 获取数组中的最大差12Math.max()Math.min() 最快捷的数组求最大值12var arr = [ 1,5,1,7,5,9]; Math.max(...arr) // 9 随机生成指定长度的字符串123Math.floor() 向下取整Math.round() 四舍五入Math.Ceil() 向上取整 123456789function randomString(n)&#123; var base = 'abcdefghijklmnopqrstuvwxyz0123456789'; var l = base.length; var m =''; for (let i = 0; i &lt; n; i++) &#123; m = m + base.charAt(Math.floor(Math.random()*l)); &#125; return m;&#125; 寻找第k大的数使用快速排序思想 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function getk(arr, left, right, k) &#123; var temp = arr[left];//基准数 var i = left;//副本可改变 var j = right;//副本可改变 var t;//临时交换值 if (i &gt;= j) &#123; return arr[i]; &#125; while (i != j) &#123; //从右侧找基准数大的放左边 while (arr[j] &lt;= temp &amp;&amp; i &lt; j) &#123; j--; &#125; //从左侧找基准数小的放右边 while (arr[i] &gt;= temp &amp;&amp; i &lt; j) &#123; i++; &#125; //交换i和j if (i != j) &#123; t = arr[i]; arr[i] = arr[j]; arr[j] = t; &#125; &#125; if (i == k) &#123; return temp; &#125; arr[left] = arr[i]; arr[i] = temp; if (k &lt; i) &#123; return getk(arr, left, i - 1, k); &#125; else if (k &gt; i) &#123; return getk(arr, i + 1, right, k); &#125;&#125;var arr = [1, 4, 2, 4, 5, 6, 3, 2, 1, 4, 22];console.log(getk(arr, 0, arr.length - 1, 5));//注意这里的k参数为下标值 数组乱序12345678var a = [1, 2, 3, 4, 5, 6, 7, 8, 9];var random = function(array) &#123; return array.sort(function()&#123;return Math.random() &gt; 0.5&#125;);&#125;;console.log(random(a)); 如果要某一定值不变就先将其用splice取出来，乱序完成在加进去。","categories":[],"tags":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"https://www.lisq.xyz/tags/算法和数据结构/"}]},{"title":"排序总结","slug":"排序总结","date":"2017-11-05T13:21:04.000Z","updated":"2018-10-28T14:29:27.902Z","comments":true,"path":"2017/11/05/排序总结/","link":"","permalink":"https://www.lisq.xyz/2017/11/05/排序总结/","excerpt":"","text":"冒泡排序基本思路： 从第一个数开始，和右侧的数比较，如果右侧比左侧小，交换左右位置。 这样第一轮比较后，最大的数排到最后。 第二轮比较，不用比较最后一个数。 优化算法 直接使用普通的冒泡排序，无论排序是否完成，都会执行数组的总个数次，实际情况下排序成功所需次数可能非常少。 所以优化思路就是在已经完成排序后跳出循环。 12345678910111213141516171819function bubling(arr) &#123; var isComplete; var temp; for (let i = 0; i &lt; arr.length - 1; i++) &#123; isComplete = true; for (let j = 0; j &lt; arr.length - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; a = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = a; isComplete = false; &#125; &#125; if (isComplete) &#123; break; &#125; &#125; return arr;&#125; 测试排序10000个数花费1113毫秒 插入排序思路对于给定的一组记录，初始时假设第一个记录自成一个有序序列，其余记录为无序序列。 从第二个记录开始，按照记录的大小依次将当期处理的记录插入到其之前的有序序列中，直至最后一个记录插入到有序序列为止。 思路： 取出第二个数，将它插入到由开头1个数组成的有序序列中。 取出第三个数，插入到开头2个数组成的有序序列中。 取出第n个数，插入到开头n-1个数组成的有序序列中。 直到n为最后一个数。 关键找到插入的节点m 让arr[m] - arr[i-1] 整体后移一位 1234567891011121314151617181920212223function insert(arr) &#123; //最大插入次数 n-1次 var temp; for (let i = 1; i &lt; arr.length; i++) &#123; var m = -1; for (let j = 0; j &lt; i; j++) &#123; if(arr[i]&lt;arr[j])&#123; m = j; break; &#125; &#125; if(m != -1)&#123; //将arr[i] 插入 arr[m] //即将arr[m] - arr[i-1]整体后移一位 temp = arr[i]; for (let j = i; j &gt; m; j--) &#123; arr[j] = arr[j-1]; &#125; arr[m] = temp; &#125; &#125; return arr;&#125; 一万个数花费700毫秒 上述实现可以改进： 不去先找m的位置，而是直接进行插入。 让i和有序序列从右到左开始比较，如果比较的值比i大，交换两个数的位置。 1234567891011121314function insert(arr) &#123; //最大插入次数 n-1次 var temp,j; for (let i = 1; i &lt; arr.length; i++) &#123; temp = arr[i]; j = i - 1; while( j&gt;=0 &amp;&amp; temp &lt; arr[j] )&#123; arr[j+1] = arr[j]; j--; &#125; arr[j+1] = temp; &#125; return arr;&#125; 快速排序思路 找出一个基准数 从右侧找比基准数小的 从左侧找比基准数大的 交换值直到没有可以交换的。 将基准数复位 将基准数左侧的数进行快排 将基准数右侧的数进行快排 关键退出快排的条件：left == right 先找基准数小的数 大于等于和小于等于（避免找到相同的数） 123456789101112131415161718192021222324252627282930313233343536function quick(arr,left,right) &#123; var temp = arr[left];//基准数 var i = left;//副本可改变 var j = right;//副本可改变 var t;//临时交换值 if(i&gt;=j)&#123; return; &#125; while(i!=j)&#123; //找到比基准数小的数 （如果没有比基准数小的数，那么i=j=left 不用做交换） while(arr[j]&gt;=temp &amp;&amp; i&lt;j )&#123; j--; &#125; //找到比基准数大的数 while (arr[i]&lt;=temp &amp;&amp; i&lt;j) &#123; i++; &#125; //交换i和j if(i!=j)&#123; t = arr[i]; arr[i] = arr[j]; arr[j] = t; &#125; &#125; arr[left] = arr[i]; arr[i] = temp; quick(arr,left,i-1); quick(arr,i+1,right);&#125; 一万个数花费7毫秒 优化版比temp小的数放在左数组里，比temp大的数放在右数组里，左数组+右数组+temp就是排序好的数。 12345678910111213141516function quick(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; let left = []; let right = []; let temp = arr[0]; for (let i = 1, l = arr.length; i &lt; l; i++) &#123; if (arr[i] &gt; temp) &#123; right.push(arr[i]); &#125; else &#123; left.push(arr[i]); &#125; &#125; return [].concat(quick(left), [temp], quick(right));&#125; 选择排序将每个数与开头数作比较，比它小则交换位置。重复比较n-1轮 12345678910111213function select(arr) &#123; var temp; for (let i = 0; i &lt; arr.length - 1; i++) &#123; for (let j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[i]) &#123; temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return arr;&#125; 希尔排序把记录按步长 gap 分组，对每组记录采用直接插入排序方法进行排序。随着步长逐渐减小，所分成的组包含的记录越来越多，当步长的值减小到 1 时，整个数据合成为一组，构成一组有序记录，则完成排序。 例子：9 1 2 5 7 4 8 6 3 5 gap是步长，也就是两个数之间的间隔。 gap=length/2 gap=gap/2 跳出循环的条件为gap&gt;0 插入排序 1234567891011121314function insert(arr) &#123; //最大插入次数 n-1次 var temp,j; for (let i = 1; i &lt; arr.length; i++) &#123; temp = arr[i]; j = i - 1; while( j&gt;=0 &amp;&amp; temp &lt; arr[j] )&#123; arr[j+1] = arr[j]; j--; &#125; arr[j+1] = temp; &#125; return arr; &#125; 给定增量值 123456789101112function shellSort(arr, gap) &#123; var temp, j; for (let i = gap; i &lt; arr.length; i++) &#123; temp = arr[i]; j = i - gap; while (j &gt; 0 &amp;&amp; temp &lt; arr[i]) &#123; arr[j + gap] = arr[j]; j -= gap; &#125; arr[j + 1] = temp; &#125;&#125; 增量值递减： 123456789101112131415161718function shell(arr) &#123; var gap = Math.floor(arr.length / 2); var temp, j; while (gap &gt; 0) &#123; console.log(gap); for (let i = gap; i &lt; arr.length; i++) &#123; temp = arr[i]; j = i - gap; while (j &gt;= 0 &amp;&amp; temp &lt; arr[j]) &#123; arr[j + gap] = arr[j]; j -= gap; &#125; arr[j + gap] = temp; &#125; gap = Math.floor(gap / 2); &#125; return arr;&#125;","categories":[],"tags":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"https://www.lisq.xyz/tags/算法和数据结构/"},{"name":"排序","slug":"排序","permalink":"https://www.lisq.xyz/tags/排序/"}]},{"title":"二叉树","slug":"二叉树","date":"2017-11-03T07:42:10.000Z","updated":"2018-10-28T14:28:15.200Z","comments":true,"path":"2017/11/03/二叉树/","link":"","permalink":"https://www.lisq.xyz/2017/11/03/二叉树/","excerpt":"","text":"基本结构插入，遍历，深度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293function Node(data, left, right) &#123; this.data = data; this.left = left; this.right = right;&#125;Node.prototype = &#123; show: function () &#123; console.log(this.data); &#125;&#125;function Tree() &#123; this.root = null;&#125;Tree.prototype = &#123; insert: function (data) &#123; var node = new Node(data, null, null); if (!this.root) &#123; this.root = node; return; &#125; var current = this.root; var parent = null; while (current) &#123; parent = current; if (data &lt; parent.data) &#123; current = current.left; if (!current) &#123; parent.left = node; return; &#125; &#125; else &#123; current = current.right; if (!current) &#123; parent.right = node; return; &#125; &#125; &#125; &#125;, preOrder: function (node) &#123; if (node) &#123; node.show(); this.preOrder(node.left); this.preOrder(node.right); &#125; &#125;, middleOrder: function (node) &#123; if (node) &#123; this.middleOrder(node.left); node.show(); this.middleOrder(node.right); &#125; &#125;, laterOrder: function (node) &#123; if (node) &#123; this.laterOrder(node.left); this.laterOrder(node.right); node.show(); &#125; &#125;, getMin: function () &#123; var current = this.root; while(current)&#123; if(!current.left)&#123; return current; &#125; current = current.left; &#125; &#125;, getMax: function () &#123; var current = this.root; while(current)&#123; if(!current.right)&#123; return current; &#125; current = current.right; &#125; &#125;, getDeep: function (node,deep) &#123; deep = deep || 0; if(node == null)&#123; return deep; &#125; deep++; var dleft = this.getDeep(node.left,deep); var dright = this.getDeep(node.right,deep); return Math.max(dleft,dright); &#125;&#125; 1234567891011121314var t = new Tree();t.insert(3);t.insert(8);t.insert(1);t.insert(2);t.insert(5);t.insert(7);t.insert(6);t.insert(0);console.log(t);// t.middleOrder(t.root);console.log(t.getMin(), t.getMax());console.log(t.getDeep(t.root, 0));console.log(t.getNode(5,t.root)); 树查找12345678910111213getNode: function (data, node) &#123; if (node) &#123; if (data === node.data) &#123; return node; &#125; else if (data &lt; node.data) &#123; return this.getNode(data,node.left); &#125; else &#123; return this.getNode(data,node.right); &#125; &#125; else &#123; return null; &#125;&#125; 利用二分的思想 二分查找二分查找的条件是必须是有序的线性表。 和线性表的中点值进行比较，如果小就继续在小的序列中查找，如此递归直到找到相同的值。 123456789101112131415function binarySearch(data, arr, start, end) &#123; if (start &gt; end) &#123; return -1; &#125; var mid = Math.floor((end + start) / 2); if (data == arr[mid]) &#123; return mid; &#125; else if (data &lt; arr[mid]) &#123; return binarySearch(data, arr, start, mid - 1); &#125; else &#123; return binarySearch(data, arr, mid + 1, end); &#125;&#125;var arr = [0, 1, 1, 1, 1, 1, 4, 6, 7, 8]console.log(binarySearch(1, arr, 0, arr.length-1));","categories":[],"tags":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"https://www.lisq.xyz/tags/算法和数据结构/"}]},{"title":"基本数据结构及特点","slug":"基本数据结构及特点","date":"2017-11-02T13:13:54.000Z","updated":"2018-10-28T14:28:45.117Z","comments":true,"path":"2017/11/02/基本数据结构及特点/","link":"","permalink":"https://www.lisq.xyz/2017/11/02/基本数据结构及特点/","excerpt":"","text":"什么是数据结构数据元素相互之间存在的一种和多种特定的关系集合 包括二个部分组成逻辑结构，存储结构。 逻辑结构 简单的来说 逻辑结构就是数据之间的关系,逻辑结构大概统一的可以分成两种 一种是线性结构，非线性结构 。 线性结构 是一个有序数据元素的集合。 其中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的。 常用的线性结构有: 栈，队列，链表，线性表。 非线性结构 各个数据元素不再保持在一个线性序列中，每个数据元素可能与零个或者多个其他数据元素发生联系。 常见的线性结构有 二维数组，树(二叉树等)等。 存储结构 逻辑结构指的是数据间的关系，而存储结构是逻辑结构用计算机语言的实现。 常见的存储结构有顺序存储、链式存储、索引存储以及散列存储（哈希表）。 时间复杂度一个算法的时间复杂度反映了程序运行从开始到结束所需要的时间。 把算法中基本操作重复执行的次数（频度）作为算法的时间复杂度。 没有循环语句，记作O(1)，也称为常数阶。 只有一重循环，则算法的基本操作的执行频度与问题规模n呈线性增大关系，记作O（n），也叫线性阶。 常用的还有平方阶O（n2）、立方阶O（n3）、对数阶O(log2n)等。 常见的时间复杂度有：1O(1)&lt; O(log2n)&lt; O（n）&lt; O（n2）&lt; O（ n3 ）&lt; O（ 2n ） 顺序表把线性表的结点按逻辑顺序一次存放在一组地址连续的存储单元中。 可以直接通过下标获取到数据，查询快。 插入和删除时要移动后续元素，还要考虑扩容问题，插入慢。 12345678910function List() &#123; // 列表的元素个数 this.listSize = 0; // 列表的当前位置 是第几个 this.pos = 0; // 初始化一个空数组来保存列表元素 this.dataStore = [];&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374List.prototype = (function () &#123; return &#123; clear: clear, find: find, toString: toString, insert: insert, append: append, remove: remove, front: front, end: end, prev: prev, next: next, hasNext: hasNext, hasPrev: hasPrev, length: length, currPos: currPos, moveTo: moveTo, getElement: getElement &#125;; /** * 给列表最后添加元素的时候，列表元素个数+1 * @param element */ function append(element) &#123; this.listSize++; this.dataSource.push(element); &#125; /** * @param element * @returns &#123;number&#125; 如果找到，返回位置，否则-1 */ function find(element) &#123; for (var i = 0; i &lt; this.dataSource.length; i++) &#123; if (this.dataSource[i] === element) &#123; return i; &#125; &#125; return -1; &#125; /** * 删除元素成功，元素个数-1 * @param element * @returns &#123;boolean&#125; */ function remove(element) &#123; var removeIndex = this.find(element); if (removeIndex !== -1) &#123; this.dataSource.splice(removeIndex, 1); this.listSize--; return true; &#125; return false; &#125; /** * 插入某个元素 * @param element 要插入的元素 * @param afterElement 列表中的元素之后 * @returns &#123;boolean&#125; */ function insert(element, afterElement) &#123; var insertIndex = this.find(afterElement); if (insertIndex !== -1) &#123; this.dataSource.splice(insertIndex + 1, 0, element); this.listSize++; return true; &#125; return false; &#125; &#125;()); 链表用一组任意存储的单元来存储线性表的数据元素。 一个对象存储着本身的值和下一个元素的地址。 需要遍历才能查询到元素，查询慢。 插入元素只需断开连接重新赋值，插入快。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function LinkList()&#123; function node(element)&#123; this.value = element; this.next = null; &#125; let length = 0; let head = null;&#125;LinkList.prototype = &#123; append:function(element)&#123; var node = new node(element); var temp = this.head; if(this.head)&#123; //遍历找到链表的终点 while(temp.next)&#123; temp = temp.next; &#125; temp.next = node; &#125;else&#123; this.head = node; &#125; this.length++; &#125;, insert:function(element,index)&#123; if(index &lt;= this.length &amp;&amp; index&gt;0)&#123; var node = new node(element); var currentIndex = 0; var currentNode = this.head; var preNode = null; if (currentIndex === 0) &#123; node.next = currentNode; this.head = node; return; &#125; while(currentIndex&lt;index)&#123; preNode = currentNode; currentNode = currentNode.next; currentIndex++; &#125; preNode.next = node; node.next = currentNode; this.length++; &#125; &#125;&#125; 链表翻转12345678910reverse: function (node) &#123; //把初始链表头当做基准点，移动下一个元素到头部，直到下一个元素为空 var currentNode = node.next; node.next = node.next.next; currentNode.next = this.head; this.head = currentNode; if(node.next)&#123; this.reverse(node); &#125; &#125;z 栈先进后出 进栈：push (在尾部插入元素) 出栈：pop（在尾部删除元素并返回此元素） 队列先进先出 进队列：unshift（在头部插入元素） 出队列：pop(在尾部删除元素并返回) 哈希表哈希的基本原理是将给定的键值转换为偏移地址来检索记录。 键转换为地址是通过一种关系（公式）来完成的，这就是哈希（散列）函数。 虽然哈希表是一种有效的搜索技术，但是它还有些缺点。两个不同的关键字，由于哈希函数值相同，因而被映射到同一表位置上。该现象称为冲突(Collision)或碰撞。发生冲突的两个关键字称为该哈希函数的同义词(Synonym)。 好的哈希函数的选择有两条标准： 1)简单并且能够快速计算 2)能够在址空间中获取键的均匀人分布 除余法是最为简单常用的一种方法。它是以表长m来除关键字，取其余数作为散列地址，即 h(key)=key％m 解决hash冲突：链表法 链表法解决冲突的做法是：将所有关键字为同义词的结点链接在同一个单链表中。 具体的关键字列表为（19,14,23,01,68,20,84,27,55,11,10,79），则哈希函数为H（key）=key MOD 13。则采用除留余数法和链地址法后得到的预想结果应该为： 哈希造表完成后，进行查找时，首先是根据哈希函数找到关键字的位置链，然后在该链中进行搜索，如果存在和关键字值相同的值，则查找成功，否则若到链表尾部仍未找到，则该关键字不存在。 插入元素：直接按地址插入到链表末尾。 综合了链表和数组的优点，查询插入都很快。 构造hash表 12345678function linklist()&#123; ...&#125;funtion hashtable&#123; length 0 data [] &#125;","categories":[],"tags":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"https://www.lisq.xyz/tags/算法和数据结构/"}]},{"title":"老版本浏览器兼容问题总结","slug":"老版本浏览器兼容问题总结","date":"2017-10-28T15:43:12.000Z","updated":"2018-12-22T14:40:33.193Z","comments":true,"path":"2017/10/28/老版本浏览器兼容问题总结/","link":"","permalink":"https://www.lisq.xyz/2017/10/28/老版本浏览器兼容问题总结/","excerpt":"","text":"1.ajax12345try&#123; xhr = new XMLHttpRequest();&#125;catch(e)&#123; xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);&#125;; 2.事件12345678var addEvent = function(element,type,callback)&#123; if(element.addEventListener)&#123; element.addEventListener(type,callback,false); &#125;else if(element.attachEvent)&#123; element.attachEvent(&apos;on&apos; + type,callback) &#125; &#125; 3.innerText123function getInnerText(element) &#123; return (typeof element.textContent == &quot;string&quot;) ? element.textContent : element.innerText;&#125; 4.indexof()IE8以下不兼容indexof()方法, 添加indexof的原型方法即可；12345if (!Array.prototype.indexOf)&#123; Array.prototype.indexOf = function(elt)&#123; ... &#125;;&#125; 5.父节点parentElement1234ele.parentElement//firebox不支持ele.parentNode//通用 6.setattribute1234object.setAttribute(&quot;class&quot;,&quot;style&quot;);//在IE8、Chrome、火狐、Opera10中都能设置成功；但是在IE7下无法设置。object.setAttribute(&quot;className&quot;,&quot;className&quot;);//只有IE7能设置成功，但是其他浏览器均无法设置。 7.IE6 高度无法小于10px12添加overflow的属性设置font-size的属性为高度的大小 8.双倍float123456.divBox&#123; float:left; width:100px; margin:0 0 0 100px; //这种情况之下IE会产生200px的距离 display:inline; //使浮动忽略&#125;","categories":[],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"https://www.lisq.xyz/tags/浏览器/"}]},{"title":"git分支操作","slug":"git分支操作","date":"2017-10-21T13:02:18.000Z","updated":"2018-10-31T15:30:16.136Z","comments":true,"path":"2017/10/21/git分支操作/","link":"","permalink":"https://www.lisq.xyz/2017/10/21/git分支操作/","excerpt":"","text":"应用场景，代码运行过程中一部分要上线，新修改的代码不能影响上线代码，上线代码和正在修改的代码就要使用两个分支。 开发分支，线上分支 查看本地分支：1git branch 查看远程分支1git branch -a 创建分支：1git branch dev 创建并切换分支1git checkout -b dev 切换分支1git checkout master 提交到远程分支1git push origin dev 与另一个分支代码合并（切换到master后）1git merge dev 流程： 创建本地dev分支 提交代码到本地dev分支 提交本地dev分支到远程dev分支 合并本地master分支和本地dev分支 提交本地master分支到远程master分支","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://www.lisq.xyz/tags/git/"},{"name":"版本控制","slug":"版本控制","permalink":"https://www.lisq.xyz/tags/版本控制/"}]},{"title":"本地git链接到github","slug":"本地git链接到github","date":"2017-09-20T15:07:36.000Z","updated":"2018-10-28T14:29:37.134Z","comments":true,"path":"2017/09/20/本地git链接到github/","link":"","permalink":"https://www.lisq.xyz/2017/09/20/本地git链接到github/","excerpt":"","text":"本地git服务器与github建立链接Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。 我们使用GitHub完全可以代替这个中心仓库，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。 由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置： 第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key： 1ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。 如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有==id_rsa==和==id_rsa.pub==两个文件，这两个就是SSH Key的秘钥，==id_rsa==是私钥，不能泄露出去，==id_rsa.pub==是公钥，可以放心地告诉任何人。 第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面： 然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴==id_rsa.pub==文件的内容： 为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。 当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。 推送本地代码到github你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。 首先，登陆GitHub，然后，在右上角找到“Create a new project”按钮，创建一个新的仓库： 在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库： 目前，在GitHub上的这个learngit仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。 现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令： 1git remote add origin git@github.com:michaelliao/learngit.git 注意 ==git remote add origin==后面的部分是你在上图看到的你自己的链接，每个人的都不相同。 如果你没有修改，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。 添加后，远程库的名字就是==origin==，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。 下一步，就可以把本地库的所有内容推送到远程库上： 1git push -u origin master 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的==master==分支内容推送的远程新的==master==分支，还会把本地的==master==分支和远程的==master==分支关联起来，在以后的推送或者拉取时就可以简化命令。 推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样： 从现在起，只要本地作了提交，就可以通过命令： 1git push origin master 从远程库克隆1git clone git@github.com:michaelliao/gitskills.git 注意把Git库的地址换成你自己的，然后进入gitskills目录看看，已经有README.md文件了。 如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://www.lisq.xyz/tags/git/"},{"name":"版本控制","slug":"版本控制","permalink":"https://www.lisq.xyz/tags/版本控制/"},{"name":"github","slug":"github","permalink":"https://www.lisq.xyz/tags/github/"}]},{"title":"git工作区和暂存区","slug":"git工作区和暂存区","date":"2017-09-09T12:56:00.000Z","updated":"2018-10-28T14:26:05.779Z","comments":true,"path":"2017/09/09/git工作区和暂存区/","link":"","permalink":"https://www.lisq.xyz/2017/09/09/git工作区和暂存区/","excerpt":"","text":"Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。 工作区（Working Directory） 就是你在电脑里能看到的目录，比如我的myproject文件夹就是一个工作区： 版本库（Repository） 工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 Git的版本库里存了很多东西，其中最重要的就是称为==stage==（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支==master==，以及指向==master==的一个指针叫==HEAD==。 第一步是用==git add==把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用==git commit==提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个==master==分支，所以，现在，==git commit==就是往==master==分支上提交更改。 你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 先对==readme.txt==做个修改，比如加上一行内容： 123Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage. 然后，在工作区新增一个==LICENSE==文本文件（内容随便写）。 先用==git status==查看一下状态： 1234567891011121314G:\\myproject&gt;git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txtUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) LICENSE.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) Git非常清楚地告诉我们，==readme.txt==被修改了，而==LICENSE==还从来没有被添加过，所以它的状态是==Untracked==。 现在，使用两次命令==git add==，把==readme.txt==和==LICENSE==都添加后，用==git status==再查看一下： 1234567G:\\myproject&gt;git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: LICENSE.txt modified: readme.txt 现在，暂存区的状态就变成这样了： 所以，==git add==命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行==git commit==就可以一次性把暂存区的所有修改提交到分支。 1234G:\\myproject&gt;git commit -m &quot;fourth&quot;[master 9069b76] fourth 2 files changed, 3 insertions(+), 1 deletion(-) create mode 100644 LICENSE.txt 一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的： 123G:\\myproject&gt;git statusOn branch masternothing to commit, working tree clean 现在版本库变成了这样，暂存区就没有任何内容了： 每次修改，如果不==add==到暂存区，那就不会加入到==commit==中。 所以为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://www.lisq.xyz/tags/git/"},{"name":"版本控制","slug":"版本控制","permalink":"https://www.lisq.xyz/tags/版本控制/"}]},{"title":"git基本操作","slug":"git基本操作","date":"2017-09-08T13:47:57.000Z","updated":"2018-10-26T11:43:11.244Z","comments":true,"path":"2017/09/08/git基本操作/","link":"","permalink":"https://www.lisq.xyz/2017/09/08/git基本操作/","excerpt":"","text":"创建版本库版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 第一步很简单，就是找到你想让git管理的项目目录或者新建一个目录。 第二步，通过git init命令把这个目录变成Git可以管理的仓库： 12G:\\myproject&gt;git initInitialized empty Git repository in G:/myproject/.git/ 瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。 如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。 上传文件到版本库我们编写一个readme.txt文件，内容如下： 12Git is a version control system.Git is free software. 一定要放到版本库目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。 第一步，用命令git add告诉Git，把文件添加到仓库： 1G:\\myproject&gt;git add readme.txt 执行上面的命令，没有任何显示，这就对了 第二步，用命令git commit告诉Git，把文件提交到仓库： 1234G:\\myproject&gt;git commit -m &quot;first time&quot;[master (root-commit) 6d5bb1a] first time 1 file changed, 2 insertions(+) create mode 100644 readme.txt 简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容,当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。 git commit命令执行成功后会告诉你，1个文件被改动（我们新添加的readme.txt文件），插入了两行内容（readme.txt有两行内容）。 为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如： 123$ git add file1.txt$ git add file2.txt file3.txt$ git commit -m &quot;add 3 files.&quot; 查看文件修改信息我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件，改成如下内容： 12Git is a distributed version control system.Git is free software. 现在，运行git status命令看看结果： 123456789G:\\myproject&gt;git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) git status命令可以让我们时刻掌握仓库当前的状态，上面的命令告诉我们，readme.txt被修改过了，但还没有准备提交的修改。 虽然Git告诉我们readme.txt被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的readme.txt，所以，需要用git diff这个命令看看： 123456789101112G:\\myproject&gt;git diffdiff --git a/readme.txt b/readme.txtindex 188e70b..013b5bc 100644--- a/readme.txt+++ b/readme.txt@@ -1,2 +1,2 @@-Git is a version control system.-Git is free software.1\\ No newline at end of file+Git is a distributed version control system.+Git is free software.\\ No newline at end of file 可以从上面的命令输出看到，我们在第一行添加了一个“distributed”单词。知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了。 版本回退现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下： 然后尝试提交： 12345G:\\myproject&gt;git add readme.txtG:\\myproject&gt;git commit -m &quot;third&quot;[master 52a89b8] third 1 file changed, 1 insertion(+), 1 deletion(-) 我们可以使用 git log 命令查看我们一共有几个版本提交到git版本库中了 123456789101112131415161718G:\\myproject&gt;git logcommit 52a89b86b2b54f223e17a84801ae6f78d01f3057Author: admin &lt;admin@qq.com&gt;Date: Sat Sep 9 09:26:06 2017 +0800 thirdcommit 95c55bfa753a2827e499b5ab2f58b442fedc8a4fAuthor: admin &lt;admin@qq.com&gt;Date: Fri Sep 8 22:10:53 2017 +0800 secondcommit 6d5bb1a4018c70bd01e4927c4c5af8449ef8aad5Author: admin &lt;admin@qq.com&gt;Date: Fri Sep 8 21:05:49 2017 +0800 first time git log命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是third，上一次是second，最早的一次是first time。如果嫌输出信息太多，看得眼花缭乱的，可以试试加上–pretty=oneline参数： 1234G:\\myproject&gt;git log --pretty=oneline52a89b86b2b54f223e17a84801ae6f78d01f3057 third95c55bfa753a2827e499b5ab2f58b442fedc8a4f second6d5bb1a4018c70bd01e4927c4c5af8449ef8aad5 first time 你看到的一大串类似3628164…882e1e0的是commit id（版本号） 好了，现在我们启动时光穿梭机，准备把readme.txt回退到上一个版本，也就是“second”的那个版本，怎么做呢？ Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交3628164…882e1e0（注意我的提交ID和你的肯定不一样）， 上一个版本就是1HEAD^ 上上一个版本就是1HEAD^^ 当然往上100个版本写1100个^ 比较容易数不过来，所以写成1HEAD~100 12git reset --hard HEAD~1HEAD is now at 95c55bf second 这样我们就回退到了第二个版本,此时HEAD也指向了second版本 12Git is a distributed version control system.Git is free software. 在使用git log命令查看版本情况 123456789101112G:\\myproject&gt;git logcommit 95c55bfa753a2827e499b5ab2f58b442fedc8a4fAuthor: admin &lt;admin@qq.com&gt;Date: Fri Sep 8 22:10:53 2017 +0800 secondcommit 6d5bb1a4018c70bd01e4927c4c5af8449ef8aad5Author: admin &lt;admin@qq.com&gt;Date: Fri Sep 8 21:05:49 2017 +0800 first time 如果你现在又想回到third版本怎么办？只需要找到third版本的版本号，版本号没必要写全，前几位就可以了，Git会自动去找。 可以使用git reflog命令查看以前每次版本的版本号（这个命令用于查看你的每一次操作） 12345G:\\myproject&gt;git reflog95c55bf HEAD@&#123;0&#125;: reset: moving to HEAD~152a89b8 HEAD@&#123;1&#125;: commit: third95c55bf HEAD@&#123;2&#125;: commit: second6d5bb1a HEAD@&#123;3&#125;: commit (initial): first time 我们看到thid版本的版本号前几位是52a89b8，输入如下命令： 12git reset --hard 52a89bHEAD is now at 52a89b third 这是readme的内容又回到了third版本。 撤销修改凌晨两点，你正在赶一份工作报告，你在readme.txt中添加了一行： 12345Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.My stupid boss still prefers SVN. 在你准备提交前，一杯咖啡起了作用，你猛然发现了“stupid boss”可能会让你丢掉这个月的奖金！ 既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用git status查看一下： 123456789G:\\myproject&gt;git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 你可以发现，Git会告诉你，git checkout – file可以丢弃工作区的修改： 1git checkout -- readme.txt 命令git checkout – readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 git checkout – file命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://www.lisq.xyz/tags/git/"},{"name":"版本控制","slug":"版本控制","permalink":"https://www.lisq.xyz/tags/版本控制/"}]},{"title":"git命令大全","slug":"git命令大全","date":"2017-09-08T05:10:01.000Z","updated":"2018-10-26T11:43:11.246Z","comments":true,"path":"2017/09/08/git命令大全/","link":"","permalink":"https://www.lisq.xyz/2017/09/08/git命令大全/","excerpt":"","text":"指令 作用 git init 创建版本库 git add 将工作区文件放到暂存区,可反复多次使用，添加多个文件 git commit 将暂存区文件放到分支 git statu 查看仓库当前状况（有多少文件修改，在什么位置） git diff 查看文件具体做了什么修改 git log 查看提交历史，以便确定要回退到哪个版本 git reset 重新设定版本 HEAD HEAD代表当前版本，HEAD~100代表回退一百个版本 git reflog 查看命令历史，以便确定要回到未来的哪个版本 git remote add origin 后面跟远程版本库的唯一url，表示本地版本库和远程版本库建立连接 git push -u origin master 将本地版本库commit过的内容提交到远程版本库的marster分支 git clone 从远程版本库克隆代码 git add . 提交所有修改到暂存区 git rebase 用于把一个分支的修改合并到当前分支","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://www.lisq.xyz/tags/git/"},{"name":"版本控制","slug":"版本控制","permalink":"https://www.lisq.xyz/tags/版本控制/"}]},{"title":"一款非常好用的全景生成，全景标记编辑插件","slug":"一款非常好用的全景生成，全景标记编辑插件","date":"2017-08-24T14:56:47.000Z","updated":"2018-10-28T14:28:07.284Z","comments":true,"path":"2017/08/24/一款非常好用的全景生成，全景标记编辑插件/","link":"","permalink":"https://www.lisq.xyz/2017/08/24/一款非常好用的全景生成，全景标记编辑插件/","excerpt":"","text":"最近一直在研究全景功能，于是封装成一个方便小巧的插件以便大家使用！ 插件包括两部分：全景展示部分，全景标记编辑部分，二者结合使用非常方便！ 使用插件首先需要引用 three.js 1.全景展示1.1 参数说明 参数名称 类型 说明 container string 存放全景的容器id url string 存放全景图片的路径 lables array {position:{lon:经度,lat:纬度},logoUrl:’logo路径’,text:’内容’} widthSegments num 水平切段数 heightSegments num 垂直切段数（值小粗糙速度快，值大精细速度慢） pRadius num 全景球的半径，影响视觉效果，推荐使用默认值 minFocalLength num 镜头最小拉近距离 maxFocalLength num 镜头最大拉近距离 showlable ‘show’/‘click’ 显示标记的方式，分为直接显示和点击显示 1.2 公用方法 方法名称 说明 config 给全景对象设置配置信息 init 初始化全景对象 clean 清除全景对象 1.3 使用初始化：（参数不设置则采用默认参数） 123456789101112131415161718var opt,tp;window.onload = function () &#123; opt = &#123; container:'panoramaConianer',//容器 url:'img/p1.png', lables:[ &#123;position:&#123;lon:180,lat:0&#125;,logoUrl:'',text:'我是一个标记'&#125; ], widthSegments: 60,//水平切段数 heightSegments: 40,//垂直切段数（值小粗糙速度快，值大精细速度慢） pRadius: 1000,//全景球的半径，推荐使用默认值 minFocalLength: 6,//镜头最a小拉近距离 maxFocalLength: 100,//镜头最大拉近距离 showlable: 'show' // show,click &#125; tp = new tpanorama(opt); tp.init();&#125; 修改某些参数 123456opt.showlable = 'click';opt.lables = [&#123;position:&#123;lon:180,lat:0&#125;,logoUrl:'img/logo.png',text:'点击了这个标记'&#125;];opt.url = 'img/p1.png';tp.clean();tp.config(opt);tp.init(); 2.添加全景标记工具在展示全景的时候，你或许会对标记的位置产生了疑问，如何确定标记的位置？ 我们可以使用类似经纬度的参数来表达它，注意这里使用的经纬度并不是真正的经纬度，是我们根据地球的经纬度模拟出来的一个参数。 下面这个工具就是用于获取我们想标记位置的 ‘经纬度’的一种方法，有了这个工具就可以完美结合上面的全景展示工具来使用了。 2.1 参数说明 参数名称 类型 说明 container string 存放全景设置的容器id imgUrl string 全景图路径 width string 指定宽度（这里图片必须严格按比例放置），高度自适应 showGrid bool 是否显示全景图的网格 showPosition bool 是否显示经纬度信息框 lableColor string 标记在图上的颜色 gridColor string 绘制格网的颜色 lables array 以前标记过的标记 {lon:114,lat:38,text:’标记一’} addLable bool 是否开启双击添加标记(必须开启经纬度提示) getLable bool 是否开启右键查询标记 (必须开启经纬度提示) deleteLbale bool 开启默认中键删除 （必须开启经纬度提示） 2.2 公共方法 方法名称 说明 config 给全景对象重新设置配置信息 init 初始化全景设置对象 getAllLables 获取所有已经添加的标记 addLable 用于手动设置添加标记 getLable 用于手动设置获取标记 delete 用于手动删除标记 listen 对全景对象监听事件 2.3 使用2.3.1 默认参数使用使用默认参数，对标记的增删查改已封装好，所有标记设置完成时可使用getAll方法与数据库进行交互 初始化（参数不设置则采用默认参数） 1234567891011121314151617181920var opt,s;window.onload = function () &#123; opt = &#123; container: 'set',//setting容器 imgUrl: 'img/p3.png', width: '1000px',//指定宽度，高度自适应 showGrid: true,//是否显示格网 showPosition: true,//是否显示经纬度提示 lableColor: '#9400D3',//标记颜色 gridColor: '#48D1CC',//格网颜色 lables: [ &#123;lon:-72.00,lat:9.00,text:'蓝窗户'&#125;,&#123;lon:114.12,lat:69.48,text:'一片云彩'&#125;,&#123;lon:132.48,lat:-12.24,text:'大海'&#125; ],//标记 &#123;lon:114,lat:38,text:'标记一'&#125; addLable: true,//开启后双击添加标记 (必须开启经纬度提示) getLable: true,//开启后右键查询标记 (必须开启经纬度提示) deleteLbale:true//开启后中键删除(必须开启经纬度提示) &#125;; s = new tpanoramaSetting(opt); s.init();&#125; 参数切换 123456789101112131415function changeImg(name) &#123; if (name == \"p1\")&#123; opt.lables = [&#123;lon:178.56,lat:-15.84,text:'神像'&#125;] &#125; if (name == \"p2\")&#123; opt.lables = [&#123;lon:-80.64,lat:-16.92,text:'蓝色'&#125;,&#123;lon:46.80,lat:10.44,text:'绿色'&#125;] &#125; if (name == \"p4\")&#123; opt.lables = [&#123;lon:48.96,lat:-20.16,text:'樱花'&#125;] &#125; opt.imgUrl = 'img/'+name+'.png'; s.clean(); s.config(opt); s.init();&#125; 2.3.2 自定义事件很多情况下默认参数不能满足我们的业务需求，这时可以自定义事件。 插件提供了listen函数用于监听各种事件。 添加标记： 1234567s.listen('dblclick',function (e) &#123; var text = prompt(\"标记名称\"); if (text!=null &amp;&amp; text!= undefined &amp;&amp; text!=\"\") &#123; s.addLable(e,text); alert(\"添加标记：\"+text+\" 后台交互\"); &#125;&#125;); 查询标记: 12345678s.listen('mousedown',function (e) &#123; if (e.button == 2) &#123; var p = s.getLable(e); if (p.lon!=null &amp;&amp;p.lon!=undefined&amp;&amp;p.lon!=\"\" ) &#123; alert(\"经度：\" + p.lon + \",纬度：\" + p.lat + \",名称：\" + p.text +\" 其他操作\"); &#125; &#125;&#125;); 删除标记: 1234567891011121314s.listen('mousedown',function (e) &#123; if (e.button == 1) &#123; var p = s.getLable(e); if (p.lon!=null &amp;&amp;p.lon!=undefined&amp;&amp;p.lon!=\"\" ) &#123; var c = confirm(\"您确认要删除该标记吗？\"); if (c) &#123; s.delete(p); s.clean(); s.init(); alert(\"删除成功！ 后台交互\") &#125; &#125; &#125;&#125;); 完整源码及DEMO地址：https://github.com/ConardLi/tpanorama","categories":[],"tags":[{"name":"三维","slug":"三维","permalink":"https://www.lisq.xyz/tags/三维/"},{"name":"全景","slug":"全景","permalink":"https://www.lisq.xyz/tags/全景/"},{"name":"three.js","slug":"three-js","permalink":"https://www.lisq.xyz/tags/three-js/"}]},{"title":"webgl基础","slug":"webgl基础","date":"2017-07-09T02:47:34.000Z","updated":"2018-10-28T14:27:32.242Z","comments":true,"path":"2017/07/09/webgl基础/","link":"","permalink":"https://www.lisq.xyz/2017/07/09/webgl基础/","excerpt":"","text":"1. canvas和webglWebGL是利用canvas来实现的 canvas和img等标签一样，是一个可以自由制定大小的矩形区域。 通过javascript可以对矩形区域进行操作，可以自由的绘制图形，文字等。而且，可以添加影子，进行涂色，另外还可以对绘制的图形进行旋转等操作。 一般使用canvas都是使用它的2d的context功能，但是也仅限于此，像它的名字一样，只能用于2d空间的绘图。 和这个相对的，WebGL是三维，可以描画3D图形，区别于之前的2dcontext，它叫做webglcontext。 2. 3D绘图基础利用WebGL可以模拟三维空间，但是最终必须输出显示在一个二维的显示器上。由深度决定的前后关系，根据远近进行放大和缩小，这些都必须提前进行运算得出结果。 这时候，坐标变换就是必须的了。坐标变换大致可以分为三种，将这些正确的组合在一起，最终决定显示器上的位置。 模型变换：第一种变换 定义参照物在三维空间的什么位置。假设，虚拟的三维空间里有一个苹果，那么为了表示这个苹果在什么位置，就需要进行相应的模型变换了。 视图变换：第二种变换 为了决定镜头的位置和角度所进行的坐标变换就叫做视图变换。即使三维空间中有一个苹果，如果镜头的方向不对着苹果的话，同样也是看不到这个苹果的。而且，如果将镜头大幅度远离苹果，那么也有可能看不到苹果了。 投影变换：这个变换，定义了三维空间的摄影区域。比如，是横向摄影，还是纵向摄影，最远拍摄多远距离等。 3. 矩阵矩阵虽然有很多种，其中的一种叫做方阵。就是行数和列数相同的矩阵。 一般的3D渲染的世界中使用的是4x4的矩阵。 实际3D渲染的时候，准备好模型坐标变换，视图坐标变换，投影坐标变换的各个矩阵。再具体一点，就是准备好各种坐标变换的矩阵，然后相乘。将最终得到的矩阵传给WebGL的顶点着色器。 矩阵可以将上面提到的变换保存起来，比如，如果是模型变换的矩阵，想要绘制的3D模型的位置，扩大缩小，以及旋转等信息，都可以定义在一个矩阵中。视图变换矩阵，镜头的位置，镜头的方向，以及镜头对准了哪个点（注视点）等可以定义在一个矩阵中。投影变换矩阵的话，显示的横竖比例和视角等信息可以定义在一个矩阵中。 需要注意一点，如果是普通的数学计算，相乘的时候，不需要注意相乘的顺序，比如2x3等于6，3x2也等于6。但是矩阵的话，根据相乘的顺序得出的结果是不同的。因为矩阵的这种性质，所以进行模型，视图，投影的矩阵相乘的时候，要特别注意相乘的顺序。 顶点着色器从传过来的矩阵中，获取到模型的坐标，加工到画面上显示出来。也就是说，操作坐标变换的矩阵，就可以决定模型在画面上如何绘制。 4. webgl可描述的东西要说在WebGL的世界里能够描画什么，其实任何东西都可以描画。而描画的最基本的东西就是下面几种。 点 线段 三角形 WebGL就是使用三角形在画面上绘制一些东西。这个三角形就是一个多边形，一个多边形至少是将三个顶点连接画出来的三角形，所以一个绘制一个多边形，最少需要三个顶点。 顶点，就是三维空间上存在的一个点。当然，这个点需要有坐标位置。顶点的横坐标是x，纵坐标是y，深度是z。将包含这些信息的点连接起来就形成了一个多边形。 非常逼真的3D游戏用了你想像不到的大量的三角形，制作出了无比精美的人物和场景。 想要绘制复杂构造的模型的话，需要准备大量的非常小的多边形。用的多边形越少，绘制的模型的棱角就越明显。 想要绘制精美的模型，就需要更多的多边形，当然，这些多边形的数量增加的话，定点数量也会成倍成倍的增加，坐标计算的负荷就越大。 顶点链接顺序和遮挡剔除3D渲染的世界里，看不到的东西不绘制的是减轻负担的最普通的方法。这就叫做遮挡剔除，如果设定了遮挡剔除，就只会绘制外侧看得见的多边形，内侧的所有多边形就都不再进行绘制了。 顺时针连接顶点的多边形是在外侧，而逆时针连接的多边形在内侧。所以，在定义顶点情报的时候，要特别注意。如果设定了遮挡剔除，本来应该在某个位置有个多边形，但是根本就不会进行绘制。 5.context初始化12345678window.onload = function () &#123; var c = document.getElementById('canvas'); c.width = 500; c.height = 300; var gl = c.getContext('webgl') || c.getContext('experimental-webgl'); gl.clearColor(0.0, 0.0, 0.0, 1.0); gl.clear(gl.COLOR_BUFFER_BIT);&#125; 1gl.clear(gl.COLOR_BUFFER_BIT); 这个函数将画面清空，回到一个全新的状态。参数是要清空的对象，或者是WebGL中定义的常量。这一次，只是清空一下画面上的颜色，所以使用COLOR_BUFFER_BIT这个常量，这个常量是为了使用canvas里面指定的颜色来清空画面而定义的。 1gl.clearColor(0.0, 0.0, 0.0, 1.0); 如果要清空画面所使用的颜色的话，就必须得另外定义了。这个函数是clearColor。clearColor函数的参数有四个，就是单纯的RGBA，很直观吧，使用方法如下。 6.着色器WebGL中，所谓的固定渲染管线是不存在的。 固定渲染管线，简单来说，就是3d渲染所进行的一连串的计算流程，就像流水线一样。如果有了固定渲染管线，编写程序就比较容易了，因为所有的变换都是由固定渲染管线来完成的，但是缺点就是自由度低。固定渲染管线只能完成一些最基本的操作，如果想要做一些特殊的处理，就比较麻烦了。 WebGL中不存在固定渲染管线。也就是说，坐标变换必须全部由自己来做。而且，这个记述了坐标变换的机制就叫做着色器(Shader)。 这样可以由程序员控制的机制叫做可编辑渲染管线。而着色器又有 处理几何图形顶点的顶点着色器和处理像素的片段着色器两种类型。由于WebGL中没有固定管线，所以必须准备好顶点着色器和片段着色器。 着色器的添加可以有多种做法。着色器是由程序员自己编写的，而且着色器的代码就是简单的字符串而已。所以，不管用什么方法，只要把这个着色器字符串传给程序就可以了。 最简单的方法，就是把着色器记录在HTML中。使用这种方法的话，是利用HTML的script标签来做的。下面是一个简单的例子。 1234567&lt;script id=\"vshader\" type=\"x-shader/x-vertex\"&gt; ※顶点着色器 &lt;/script&gt; &lt;script id=\"fshader\" type=\"x-shader/x-fragment\"&gt; ※片段着色器 &lt;/script&gt; 指定type属性的理由:type属性指定了［x-shader/x-vertex］和［x-shader/x-fragment］，这并不是HTML中定义的正式的写法。但是一般的浏览器如果遇到不识别的标签的话会无视掉的，浏览器不会认为这是javascript代码的。浏览器只会把它当成无意义的字符串，而程序中则可以使用标签里面的内容。","categories":[],"tags":[{"name":"webgl","slug":"webgl","permalink":"https://www.lisq.xyz/tags/webgl/"},{"name":"三维","slug":"三维","permalink":"https://www.lisq.xyz/tags/三维/"}]}]}